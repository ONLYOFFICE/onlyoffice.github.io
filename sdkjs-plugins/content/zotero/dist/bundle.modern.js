/*
 * (c) Copyright Ascensio System SIA 2010-2025
 *
 * This program is a free software product. You can redistribute it and/or
 * modify it under the terms of the GNU Affero General Public License (AGPL)
 * version 3 as published by the Free Software Foundation. In accordance with
 * Section 7(a) of the GNU AGPL its Section 15 shall be amended to the effect
 * that Ascensio System SIA expressly excludes the warranty of non-infringement
 * of any third-party rights.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without even the implied
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE. For
 * details, see the GNU AGPL at: http://www.gnu.org/licenses/agpl-3.0.html
 *
 * You can contact Ascensio System SIA at 20A-6 Ernesta Birznieka-Upish
 * street, Riga, Latvia, EU, LV-1050.
 *
 * The  interactive user interfaces in modified source and object code versions
 * of the Program must display Appropriate Legal Notices, as required under
 * Section 5 of the GNU AGPL version 3.
 *
 * Pursuant to Section 7(b) of the License you must retain the original Product
 * logo when distributing the program. Pursuant to Section 7(e) we decline to
 * grant you any rights under trademark law for use of our trademarks.
 *
 * All the Product's GUI elements, including illustrations and icon sets, as
 * well as technical writing content are licensed under the terms of the
 * Creative Commons Attribution-ShareAlike 4.0 International. See the License
 * terms at http://creativecommons.org/licenses/by-sa/4.0/legalcode
 *
 */
var Theme = {
    addStylesForComponents: function addStylesForComponents(theme) {
        var styles = "";
        if (theme["background-normal"]) {
            styles += ".custom-button-secondary-icon,\n" + ".custom-button-secondary,\n" + ".input-field-element,\n" + ".selectbox-search-input,\n" + ".selectbox-header,\n" + ".selectbox-dropdown,\n" + ".radio-visual, \n" + ".checkbox-visual, \n" + ".message { background-color: " + theme["background-normal"] + "; }\n";
        }
        if (theme["text-inverse"]) {
            styles += ".custom-button-primary { color: " + theme["text-inverse"] + "; }\n";
        }
        if (theme["border-regular-control"]) {
            styles += ".custom-button-icon-only:active:not(.custom-button-disabled),\n" + ".custom-button-secondary-icon:active:not(.custom-button-disabled),\n" + ".custom-button-secondary:active:not(.custom-button-disabled),\n" + ".custom-button-icon-only:hover:not(.custom-button-disabled),\n" + ".custom-button-secondary-icon:hover:not(.custom-button-disabled),\n" + ".custom-button-secondary:hover:not(.custom-button-disabled),\n" + ".custom-button-secondary,\n" + ".custom-button-secondary-icon,\n" + ".input-field-element,\n" + ".checkbox-visual,\n" + ".radio-visual,\n" + ".selectbox-header,\n" + ".selectbox-dropdown,\n" + ".selectbox-search-input:focus,\n" + ".message { border-color: " + theme["border-regular-control"] + "; }\n";
            styles += ".selectbox-search,\n" + ".selectbox-option-divider { border-color: " + theme["border-regular-control"] + " !important; }\n";
        }
        if (theme["border-error"]) {
            styles += ".input-field-invalid .input-field-element { border-color: " + theme["border-error"] + "; }\n";
        }
        if (theme["border-control-focus"]) {
            styles += ".custom-button-icon-only:focus:not(:active):not(:hover),\n" + ".custom-button-secondary-icon:focus:not(:active):not(:hover),\n" + ".custom-button-secondary:focus:not(:active):not(:hover),\n" + ".input-field-element:focus,\n" + ".input-field-focused .input-field-element,\n" + ".selectbox-header:active,\n" + ".selectbox-header:focus,\n" + ".selectbox-header-open { border-color: " + theme["border-control-focus"] + "; }\n";
        }
        if (theme["highlight-button-hover"]) {
            styles += ".custom-button-icon-only:hover:not(.custom-button-disabled),\n" + ".custom-button-secondary-icon:hover:not(.custom-button-disabled),\n" + ".custom-button-secondary:hover:not(.custom-button-disabled),\n" + ".selectbox-custom-option:hover,\n" + ".selectbox-option:hover { background-color: " + theme["highlight-button-hover"] + "; }\n";
        }
        if (theme["highlight-button-pressed"]) {
            styles += ".custom-button-icon-only:active:not(.custom-button-disabled),\n" + ".custom-button-secondary-icon:active:not(.custom-button-disabled),\n" + ".custom-button-secondary:active:not(.custom-button-disabled),\n" + ".selectbox-option-selected:hover,\n" + ".selectbox-option-selected { background-color: " + theme["highlight-button-pressed"] + "; }\n";
            styles += ".selectbox-dropdown { box-shadow: 1px 1px 4px -1px " + theme["highlight-button-pressed"] + "; }\n";
        }
        if (theme["highlight-primary-dialog-button-hover"]) {
            styles += ".custom-button-primary:hover:not(.custom-button-disabled) { background-color: " + theme["highlight-primary-dialog-button-hover"] + "; border-color: " + theme["highlight-primary-dialog-button-hover"] + "; }\n";
        }
        if (theme["background-primary-dialog-button"]) {
            styles += ".checkbox-indeterminate,\n" + ".custom-button-primary { background-color: " + theme["background-primary-dialog-button"] + "; border-color: " + theme["background-primary-dialog-button"] + "; }\n";
        }
        if (theme["background-toolbar-additional"]) {
            styles += ".custom-button-secondary-icon:disabled,\n" + ".custom-button-secondary-icon.custom-button-disabled,\n" + ".custom-button-secondary:disabled,\n" + ".custom-button-secondary.custom-button-disabled { background-color: " + theme["background-toolbar-additional"] + "; border-color: " + theme["background-toolbar-additional"] + "; }\n";
        }
        if (theme["text-normal"]) {
            styles += ".custom-button-secondary-icon,\n" + ".custom-button-secondary,\n" + ".custom-button-secondary-icon,\n" + ".custom-button-icon-only,\n" + ".selectbox-search-input,\n" + ".input-field-element { color: " + theme["text-normal"] + "; }\n";
            styles += ".input-field-search-icon svg { fill: " + theme["text-normal"] + "; }\n";
        }
        if (theme["text-secondary"]) {
            styles += ".message-close:hover,\n" + ".input-field-clear:hover { color: " + theme["text-secondary"] + "; }\n";
        }
        if (theme["text-tertiary"]) {
            styles += ".input-field-clear,\n" + ".message-container:hover .message-close,\n" + ".custom-button-secondary-icon:disabled,\n" + ".custom-button-secondary-icon.custom-button-disabled,\n" + ".custom-button-secondary:disabled,\n" + ".custom-button-secondary.custom-button-disabled,\n" + ".input-field-element::placeholder,\n" + ".selectbox-search-input::placeholder { color: " + theme["text-tertiary"] + "; }\n";
        }
        var fontSize = "11px";
        if ([ "theme-white", "theme-night" ].indexOf(theme.name) !== -1 || [ "theme-white", "theme-night" ].indexOf(theme.Name) !== -1) {
            fontSize = "12px";
            styles += ".message,\n" + ".custom-button,\n" + ".selectbox-header,\n" + ".input-field-element { border-radius: 4px; }\n";
            styles += ".radio--checked .radio-visual { border-width: 4px; }\n";
            styles += ".checkbox-checkmark { color: " + theme["text-inverse"] + "; }\n";
            styles += ".checkbox--checked .checkbox-visual { background-color: " + theme["background-primary-dialog-button"] + "; }\n";
            styles += ".radio--checked .radio-visual,\n" + ".checkbox--checked .checkbox-visual { border-color: " + theme["background-primary-dialog-button"] + "; }\n";
            styles += ".radio-button-container:hover:not(.radio--checked) .radio-visual,\n" + ".checkbox-container:hover:not(.checkbox--disabled) .checkbox-visual { background-color: " + theme["highlight-button-hover"] + "; }\n";
            styles += ".checkbox--checked:hover:not(.checkbox--disabled) .checkbox-visual { border-color: " + theme["highlight-primary-dialog-button-hover"] + "; background-color: " + theme["highlight-primary-dialog-button-hover"] + "; }\n";
            styles += ".radio--checked:hover:not(.radio--disabled) .radio-visual { border-color: " + theme["highlight-primary-dialog-button-hover"] + "; }\n";
            styles += "body { font-size: 12px; }\n";
        } else {
            styles += ".checkbox-checkmark { color: " + theme["text-normal"] + "; }\n";
            styles += ".radio--checked .radio-visual { background-color: " + theme["text-normal"] + ";\n box-shadow: 0 0 0 2px" + theme["background-normal"] + " inset; }\n";
            styles += ".radio-button-container:hover .radio-visual,\n" + ".checkbox-container:hover:not(.checkbox--disabled) .checkbox-visual { border-color: " + theme["border-control-focus"] + "; }\n";
        }
        styles += "body, input, textarea, select, button { font-size: " + fontSize + "; }\n";
        var styleTheme = document.getElementById("componentsStyles");
        if (!styleTheme) {
            styleTheme = document.createElement("style");
            styleTheme.id = "componentsStyles";
            styleTheme.innerHTML = styles;
            document.getElementsByTagName("head")[0].appendChild(styleTheme);
            return styles;
        }
        styleTheme.innerHTML = styles;
        return styles;
    },
    fixThemeForIE: function fixThemeForIE(theme) {
        if (!theme["text-normal"]) {
            theme["text-normal"] = "rgb(51, 51, 51)";
        }
        if (!theme["text-secondary"]) {
            theme["text-secondary"] = "#848484";
        }
        if (!theme["highlight-button-hover"]) {
            theme["highlight-button-hover"] = "#e0e0e0";
        }
        if (!theme["background-normal"]) {
            theme["background-normal"] = "white";
        }
        if (!theme["highlight-button-pressed"]) {
            theme["highlight-button-pressed"] = "#cbcbcb";
        }
        if (!theme["text-inverse"]) {
            theme["text-inverse"] = "white";
        }
        if (!theme["border-regular-control"]) {
            theme["border-regular-control"] = "#c0c0c0";
        }
        if (!theme["border-error"]) {
            theme["border-error"] = "#f62211";
        }
        if (!theme["border-control-focus"]) {
            theme["border-control-focus"] = "#848484";
        }
        if (!theme["highlight-primary-dialog-button-hover"]) {
            theme["highlight-primary-dialog-button-hover"] = "#1c1c1c";
        }
        if (!theme["background-primary-dialog-button"]) {
            theme["background-primary-dialog-button"] = "#444444";
        }
        if (!theme["background-toolbar-additional"]) {
            theme["background-toolbar-additional"] = "#efefef";
        }
        if (!theme["text-tertiary"]) {
            theme["text-tertiary"] = "#bdbdbd";
        }
        return theme;
    }
};

function Router() {
    this._states = [ "mainState", "loginState", "settingsState" ];
    this._routes = [ "main", "login", "settings" ];
    this._currentRoute = "login";
    this._currentRouteIndex = 1;
    this._containers = this._states.map(function(route) {
        var container = document.getElementById(route);
        if (!container) throw new Error("container ".concat(route, " not found"));
        return container;
    });
}

Router.prototype.getRoute = function() {
    return this._currentRoute;
};

Router.prototype._setCurrentRoute = function(route) {
    this._containers[this._currentRouteIndex].classList.add("hidden");
    this._currentRoute = route;
    this._currentRouteIndex = this._routes.indexOf(route);
    this._containers[this._currentRouteIndex].classList.remove("hidden");
};

Router.prototype.openMain = function() {
    this._setCurrentRoute("main");
};

Router.prototype.openLogin = function() {
    this._setCurrentRoute("login");
};

Router.prototype.openSettings = function() {
    this._setCurrentRoute("settings");
};

var zoteroEnvironment = {
    restApiUrl: "https://api.zotero.org/",
    desktopApiUrl: "http://127.0.0.1:23119/api/"
};

var ZoteroApiChecker = {
    _done: false,
    _desktop: false,
    _hasPermission: true,
    _online: false,
    _hasKey: false,
    _timeout: 1e3,
    _callback: function _callback(e) {},
    _desktopVersion: function() {
        if (window.navigator && window.navigator.userAgent.toLowerCase().indexOf("ascdesktopeditor") < 0) return false;
        if (window.location && window.location.protocol == "file:") return true;
        var src = window.document.currentScript ? window.document.currentScript.getAttribute("src") : "";
        if (src && 0 == src.indexOf("file:///")) return true;
        return false;
    }(),
    runApisChecker: function runApisChecker(sdk) {
        var self = this;
        self._done = false;
        function attemptCheck() {
            if (self._done) return;
            self._checkApiAvailable(sdk).then(function(res) {
                if (self._done) return;
                if (res.online && res.hasKey) {
                    self._done = true;
                } else if (res.desktop && res.hasPermission) {
                    self._done = true;
                }
                self._callback(res);
                setTimeout(attemptCheck, self._timeout);
            });
        }
        attemptCheck();
        return {
            subscribe: function subscribe(callbackFn) {
                self._callback = callbackFn;
            },
            unsubscribe: function unsubscribe() {
                self._done = true;
                self._callback = function() {};
            }
        };
    },
    checkStatus: function checkStatus(sdk) {
        return this._checkApiAvailable(sdk);
    },
    successfullyLoggedInUsingApiKey: function successfullyLoggedInUsingApiKey() {
        this._done = true;
        this._callback({
            online: true,
            hasKey: true,
            desktop: this._desktop,
            hasPermission: this._hasPermission,
            desktopVersion: this._desktopVersion
        });
    },
    _checkApiAvailable: function _checkApiAvailable(sdk) {
        var self = this;
        return new Promise(function(resolve) {
            Promise.all([ fetch(zoteroEnvironment.restApiUrl, {
                method: "GET",
                cache: "no-cache"
            }).then(function(res) {
                return res.status === 200;
            }).catch(function() {
                return false;
            }), self._sendDesktopRequest(zoteroEnvironment.desktopApiUrl).then(function(res) {
                self._hasPermission = res.hasPermission;
                return res.isZoteroRunning;
            }).catch(function() {
                return false;
            }) ]).then(function(apisAvailable) {
                self._online = apisAvailable[0];
                self._desktop = apisAvailable[1];
                self._hasKey = sdk.hasSettings();
                resolve({
                    online: self._online,
                    hasKey: self._hasKey,
                    desktop: self._desktop,
                    hasPermission: self._hasPermission,
                    desktopVersion: self._desktopVersion
                });
            });
        });
    },
    _sendDesktopRequest: function _sendDesktopRequest(url) {
        var self = this;
        return new Promise(function(resolve, reject) {
            if (!self._desktopVersion) {
                resolve({
                    hasPermission: false,
                    isZoteroRunning: false
                });
                return;
            }
            window.AscSimpleRequest.createRequest({
                url: url,
                method: "GET",
                headers: {
                    "Zotero-API-Version": "3",
                    "User-Agent": "AscDesktopEditor"
                },
                complete: function complete(e) {
                    console.warn(e);
                    var hasPermission = false;
                    var isZoteroRunning = false;
                    if (e.responseStatus == 403) {
                        hasPermission = false;
                        isZoteroRunning = true;
                    } else if (e.responseStatus === 200) {
                        isZoteroRunning = true;
                        hasPermission = true;
                    }
                    resolve({
                        hasPermission: hasPermission,
                        isZoteroRunning: isZoteroRunning
                    });
                },
                error: function error(e) {
                    if (e.statusCode == -102) e.statusCode = 404;
                    reject(e);
                }
            });
        });
    }
};

var ZoteroSdk = function ZoteroSdk() {
    this._apiKey = null;
    this._userId = 0;
    this._userGroups = [];
    this._isOnlineAvailable = true;
};

ZoteroSdk.prototype.ZOTERO_API_VERSION = "3";

ZoteroSdk.prototype.USER_AGENT = "AscDesktopEditor";

ZoteroSdk.prototype.DEFAULT_FORMAT = "csljson";

ZoteroSdk.prototype.STORAGE_KEYS = {
    USER_ID: "zoteroUserId",
    API_KEY: "zoteroApiKey"
};

ZoteroSdk.prototype.API_PATHS = {
    USERS: "users",
    GROUPS: "groups",
    ITEMS: "items",
    KEYS: "keys"
};

ZoteroSdk.prototype._getBaseUrl = function() {
    return this._isOnlineAvailable ? zoteroEnvironment.restApiUrl : zoteroEnvironment.desktopApiUrl;
};

ZoteroSdk.prototype._getDesktopRequest = function(url) {
    var self = this;
    return new Promise(function(resolve, reject) {
        window.AscSimpleRequest.createRequest({
            url: url,
            method: "GET",
            headers: {
                "Zotero-API-Version": self.ZOTERO_API_VERSION,
                "User-Agent": self.USER_AGENT
            },
            complete: resolve,
            error: function error(_error) {
                if (_error.statusCode === -102) {
                    _error.statusCode = 404;
                    _error.message = "Connection to Zotero failed. Make sure Zotero is running";
                }
                reject(_error);
            }
        });
    });
};

ZoteroSdk.prototype._getOnlineRequest = function(url) {
    var self = this;
    var headers = {
        "Zotero-API-Version": self.ZOTERO_API_VERSION,
        "Zotero-API-Key": self._apiKey || ""
    };
    return fetch(url, {
        headers: headers
    }).then(function(response) {
        if (!response.ok) {
            throw new Error(response.status + " " + response.statusText);
        }
        return response;
    }).catch(function(error) {
        console.error("Zotero API request failed:", error.message);
        if (typeof error === "object") {
            error.message = "Connection to Zotero failed";
        }
        throw error;
    });
};

ZoteroSdk.prototype._getRequestWithOfflineSupport = function(url) {
    return this._isOnlineAvailable ? this._getOnlineRequest(url) : this._getDesktopRequest(url.href);
};

ZoteroSdk.prototype._buildGetRequest = function(path, queryParams) {
    queryParams = queryParams || {};
    var url = new URL(path, this._getBaseUrl());
    Object.keys(queryParams).forEach(function(key) {
        if (queryParams[key] !== undefined && queryParams[key] !== null) {
            url.searchParams.append(key, queryParams[key]);
        }
    });
    return this._getRequestWithOfflineSupport(url);
};

ZoteroSdk.prototype._parseLinkHeader = function(headerValue) {
    var links = {};
    var linkHeaderRegex = /<(.*?)>; rel="(.*?)"/g;
    if (!headerValue) return links;
    var match;
    while ((match = linkHeaderRegex.exec(headerValue.trim())) !== null) {
        links[match[2]] = match[1];
    }
    return links;
};

ZoteroSdk.prototype._parseDesktopItemsResponse = function(promise, resolve, reject, id) {
    return promise.then(function(response) {
        return {
            items: JSON.parse(response.responseText),
            id: id
        };
    }).then(resolve).catch(reject);
};

ZoteroSdk.prototype._parseItemsResponse = function(promise, resolve, reject, id) {
    var self = this;
    return promise.then(function(response) {
        return Promise.all([ response.json(), response ]);
    }).then(function(results) {
        var json = results[0];
        var response = results[1];
        var links = self._parseLinkHeader(response.headers.get("Link") || "");
        var result = {
            items: json,
            id: id
        };
        if (typeof json === "object" && json.items) {
            result.items = json.items;
        }
        if (links.next) {
            result.next = function() {
                return new Promise(function(rs, rj) {
                    self._parseItemsResponse(self._getOnlineRequest(new URL(links.next)), rs, rj, id);
                });
            };
        }
        resolve(result);
    }).catch(reject);
};

ZoteroSdk.prototype._parseResponse = function(promise, resolve, reject, id) {
    if (this._isOnlineAvailable) {
        var fetchPromise = promise;
        this._parseItemsResponse(fetchPromise, resolve, reject, id);
    } else {
        var ascSimplePromise = promise;
        this._parseDesktopItemsResponse(ascSimplePromise, resolve, reject, id);
    }
};

ZoteroSdk.prototype.getItems = function(search, itemsID, format) {
    var self = this;
    format = format || self.DEFAULT_FORMAT;
    return new Promise(function(resolve, reject) {
        var queryParams = {
            format: format
        };
        if (search) {
            queryParams.q = search;
        } else if (itemsID) {
            queryParams.itemKey = itemsID.join(",");
        }
        var path = self.API_PATHS.USERS + "/" + self._userId + "/" + self.API_PATHS.ITEMS;
        var request = self._buildGetRequest(path, queryParams);
        return self._parseResponse(request, resolve, reject, self._userId);
    });
};

ZoteroSdk.prototype.getGroupItems = function(search, groupId, itemsID, format) {
    var self = this;
    format = format || self.DEFAULT_FORMAT;
    return new Promise(function(resolve, reject) {
        var queryParams = {
            format: format
        };
        if (search) {
            queryParams.q = search;
        } else if (itemsID) {
            queryParams.itemKey = itemsID.join(",");
        }
        var path = self.API_PATHS.GROUPS + "/" + groupId + "/" + self.API_PATHS.ITEMS;
        var request = self._buildGetRequest(path, queryParams);
        return self._parseResponse(request, resolve, reject, groupId);
    });
};

ZoteroSdk.prototype.getUserGroups = function() {
    var self = this;
    return new Promise(function(resolve, reject) {
        if (self._userGroups.length > 0) {
            resolve(self._userGroups);
            return;
        }
        var path = self.API_PATHS.USERS + "/" + self._userId + "/groups";
        self._buildGetRequest(path).then(function(response) {
            if (self._isOnlineAvailable) {
                var fetchResponse = response;
                if (!fetchResponse.ok) {
                    throw new Error(fetchResponse.status + " " + fetchResponse.statusText);
                }
                return fetchResponse.json();
            }
            var ascSimpleResponse = response;
            return JSON.parse(ascSimpleResponse.responseText);
        }).then(function(groups) {
            self._userGroups = groups.map(function(group) {
                return {
                    id: group.id,
                    name: group.data.name
                };
            });
            resolve(self._userGroups);
        }).catch(reject);
    });
};

ZoteroSdk.prototype.setApiKey = function(key) {
    var self = this;
    var path = this.API_PATHS.KEYS + "/" + key;
    return this._buildGetRequest(path).then(function(response) {
        var fetchResponse = response;
        if (!fetchResponse.ok) {
            throw new Error(fetchResponse.status + " " + fetchResponse.statusText);
        }
        return fetchResponse.json();
    }).then(function(keyData) {
        self._saveSettings(keyData.userID, key);
        return true;
    });
};

ZoteroSdk.prototype._applySettings = function(userId, apiKey) {
    this._userId = userId;
    this._apiKey = apiKey;
};

ZoteroSdk.prototype._saveSettings = function(userId, apiKey) {
    this._applySettings(userId, apiKey);
    localStorage.setItem(this.STORAGE_KEYS.USER_ID, String(userId));
    localStorage.setItem(this.STORAGE_KEYS.API_KEY, apiKey);
};

ZoteroSdk.prototype.hasSettings = function() {
    var userId = localStorage.getItem(this.STORAGE_KEYS.USER_ID);
    var apiKey = localStorage.getItem(this.STORAGE_KEYS.API_KEY);
    if (userId && apiKey) {
        this._applySettings(Number(userId), apiKey);
        return true;
    }
    return false;
};

ZoteroSdk.prototype.clearSettings = function() {
    localStorage.removeItem(this.STORAGE_KEYS.USER_ID);
    localStorage.removeItem(this.STORAGE_KEYS.API_KEY);
    this._userGroups = [];
    this._userId = 0;
    this._apiKey = null;
};

ZoteroSdk.prototype.getUserId = function() {
    return this._userId;
};

ZoteroSdk.prototype.setIsOnlineAvailable = function(isOnline) {
    this._isOnlineAvailable = isOnline;
};

function InputField(input, options) {
    var self = this;
    options = options || {};
    if (typeof input === "string") {
        var temp = document.getElementById(input);
        if (temp instanceof HTMLInputElement) {
            input = temp;
        }
    }
    if (input instanceof HTMLInputElement) {
        this.input = input;
    } else {
        throw new Error("Invalid input element");
    }
    this._container = document.createElement("div");
    this._options = {
        type: options.type || input.type || "text",
        placeholder: options.placeholder || input.placeholder || "",
        value: options.value || input.value || "",
        autofocus: options.autofocus || false,
        disabled: options.disabled || false,
        readonly: options.readonly || false,
        required: options.required || false,
        showCounter: options.showCounter || false,
        showClear: options.showClear !== undefined ? options.showClear : true,
        autocomplete: options.autocomplete || "off"
    };
    for (var key in options) {
        if (!this._options.hasOwnProperty(key)) {
            this._options[key] = options[key];
        }
    }
    this._id = input.id || "input_" + Math.random().toString(36).slice(2, 9);
    this.isFocused = false;
    this.isValid = true;
    this._validationMessage = "";
    this._subscribers = [];
    this._boundHandles = {
        focus: function focus(e) {
            self._handleFocus(e);
        },
        blur: function blur(e) {
            self._handleBlur(e);
        },
        input: function input(e) {
            self._handleInput(e);
        },
        keydown: function keydown(e) {
            self._handleKeydown(e);
        },
        clear: function clear() {
            self.clear();
        },
        validate: function validate() {
            self.validate();
        }
    };
    this._clearButton = null;
    this._counter = null;
    this._counterCurrent = null;
    this._counterMax = null;
    this._validationElement = document.createElement("div");
    if (this._options.type === "search") {
        this._searchIcon = document.createElement("span");
        this._boundHandles.search = this._triggerSubmit.bind(this);
        this._container.classList.add("input-field-search");
    }
    this._createDOM();
    this._bindEvents();
    this._updateState();
    if (this._options.autofocus) {
        setTimeout(function(self) {
            return function() {
                self.focus();
            };
        }(this), 100);
    }
}

InputField.prototype = {
    constructor: InputField,
    input: null,
    _container: null,
    _options: {},
    _id: "",
    isFocused: false,
    isValid: true,
    _validationMessage: "",
    _subscribers: [],
    _boundHandles: null,
    _clearButton: null,
    _counter: null,
    _counterCurrent: null,
    _counterMax: null,
    _validationElement: null,
    _createDOM: function _createDOM() {
        var parent = this.input.parentNode;
        var fragment = document.createDocumentFragment();
        fragment.appendChild(this._container);
        this._container.className += " input-field-container  input-field-container-" + this._id;
        var inputField = document.createElement("div");
        this._container.appendChild(inputField);
        inputField.className += " input-field";
        if (this._options.disabled) {
            inputField.className += " input-field-disabled";
        }
        var inputFieldMain = document.createElement("div");
        inputField.appendChild(inputFieldMain);
        inputFieldMain.className += " input-field-main";
        this.input.className += " input-field-element";
        this.input.type = this._options.type || "text";
        this.input.placeholder = this._options.placeholder || "";
        this.input.value = String(this._options.value) || "";
        if (this._options.disabled) {
            this.input.disabled = true;
        }
        if (this._options.readonly) {
            this.input.readOnly = true;
        }
        if (this._options.required) {
            this.input.required = true;
        }
        if (this._options.maxLength) {
            this.input.maxLength = this._options.maxLength;
        }
        if (this._options.pattern) {
            this.input.pattern = this._options.pattern;
        }
        if (this._options.autocomplete) {
            this.input.autocomplete = this._options.autocomplete;
        }
        if (this._options.showCounter) {
            this._counter = document.createElement("div");
            inputField.appendChild(this._counter);
            this._counter.className += " input-field-counter";
            this._counterCurrent = document.createElement("span");
            this._counterCurrent.className += " input-field-counter-current";
            this._counterCurrent.textContent = "0";
            this._counter.appendChild(this._counterCurrent);
            var span = document.createElement("span");
            span.textContent = "/";
            this._counter.appendChild(span);
            this._counterMax = document.createElement("span");
            this._counterMax.className += " input-field-counter-max";
            this._counterMax.textContent = String(this._options.maxLength) || "∞";
            this._counter.appendChild(this._counterMax);
        }
        inputField.appendChild(this._validationElement);
        this._validationElement.className += " input-field-validation";
        this._validationElement.style.display = "none";
        if (this._options.showClear) {
            this.input.className += " input-field-clearable";
            this._clearButton = document.createElement("button");
            inputField.appendChild(this._clearButton);
            this._clearButton.className += " input-field-clear";
            this._clearButton.style.display = "none";
            this._clearButton.textContent = "×";
        }
        if (this._options.showSearchIcon) {
            this._searchIcon.classList.add("input-field-search-icon");
            this._searchIcon.innerHTML = '<svg width="14" height="14" viewBox="0 0 14 14" ' + 'fill="none" xmlns="http://www.w3.org/2000/svg">' + '<path fill-rule="evenodd" clip-rule="evenodd" ' + 'd="M10 5.5C10 7.98528 7.98528 10 5.5 10C3.01472 10 1 7.98528 1 5.5C1 3.01472 3.01472 1 5.5 1C7.98528 1 10 3.01472 10 5.5ZM9.01953 9.72663C8.06578 10.5217 6.83875 11 5.5 11C2.46243 11 0 8.53757 0 5.5C0 2.46243 2.46243 0 5.5 0C8.53757 0 11 2.46243 11 5.5C11 6.83875 10.5217 8.06578 9.72663 9.01953L13.8536 13.1465L13.1465 13.8536L9.01953 9.72663Z" ' + 'fill="currentColor"/>' + "</svg>";
            inputFieldMain.appendChild(this._searchIcon);
        }
        if (parent) {
            parent.insertBefore(fragment, this.input);
        }
        inputFieldMain.appendChild(this.input);
    },
    _bindEvents: function _bindEvents() {
        this.input.addEventListener("focus", this._boundHandles.focus);
        this.input.addEventListener("blur", this._boundHandles.blur);
        this.input.addEventListener("input", this._boundHandles.input);
        this.input.addEventListener("keydown", this._boundHandles.keydown);
        if (this._clearButton) {
            this._clearButton.addEventListener("click", this._boundHandles.clear);
        }
        if (this._options.showSearchIcon && this._boundHandles.search) {
            this._searchIcon.addEventListener("click", this._boundHandles.search);
        }
        this.input.addEventListener("change", this._boundHandles.validate);
    },
    _handleFocus: function _handleFocus(e) {
        this.isFocused = true;
        this._container.className += " input-field-focused";
        this._updateClearButton();
        this._triggerFocusEvent(e);
    },
    _handleBlur: function _handleBlur(e) {
        this.isFocused = false;
        var classes = this._container.className.split(" ");
        var newClasses = [];
        for (var i = 0; i < classes.length; i++) {
            if (classes[i] !== "input-field-focused") {
                newClasses.push(classes[i]);
            }
        }
        this._container.className = newClasses.join(" ");
        this.validate();
        this._triggerBlurEvent(e);
    },
    _handleInput: function _handleInput(e) {
        this._updateClearButton();
        this._updateCounter();
        this._triggerInputEvent(e);
    },
    _handleKeydown: function _handleKeydown(e) {
        var key = e.key || e.keyCode;
        if ((key === "Escape" || key === 27) && this._options.showClear) {
            this.clear();
            e.preventDefault();
        }
        if (key === "Enter" || key === 13) {
            this._triggerSubmit();
        }
    },
    _updateClearButton: function _updateClearButton() {
        if (this._clearButton) {
            var hasValue = this.input.value.length > 0;
            this._clearButton.style.display = hasValue ? "block" : "none";
        }
    },
    _updateCounter: function _updateCounter() {
        if (this._counter && this._options.maxLength) {
            var current = this.input.value.length;
            var max = this._options.maxLength;
            if (this._counterCurrent) {
                this._counterCurrent.textContent = String(current);
            }
            if (this._counterMax) {
                this._counterMax.textContent = String(max);
            }
            if (current > max * .9) {
                var counterClasses = this._counter.className.split(" ");
                if (counterClasses.indexOf("input-field-counter-warning") === -1) {
                    this._counter.className += " input-field-counter-warning";
                }
            } else {
                this._counter.className = this._counter.className.split(" ").filter(function(cls) {
                    return cls !== "input-field-counter-warning";
                }).join(" ");
            }
            if (current > max) {
                var counterClasses = this._counter.className.split(" ");
                if (counterClasses.indexOf("input-field-counter-error") === -1) {
                    this._counter.className += " input-field-counter-error";
                }
            } else {
                this._counter.className = this._counter.className.split(" ").filter(function(cls) {
                    return cls !== "input-field-counter-error";
                }).join(" ");
            }
        }
    },
    validate: function validate() {
        if (!this._options.validation) {
            this.isValid = true;
            return true;
        }
        var value = this.input.value;
        var isValid = true;
        var message = "";
        if (this._options.required && !value.trim()) {
            isValid = false;
            message = "This field is required";
        } else if (this._options.minLength && value.length < this._options.minLength) {
            isValid = false;
            message = "Minimum length is " + this._options.minLength + " characters";
        } else if (this._options.maxLength && value.length > this._options.maxLength) {
            isValid = false;
            message = "Maximum length is " + this._options.maxLength + " characters";
        } else if (this._options.pattern && !new RegExp(this._options.pattern).test(value)) {
            isValid = false;
            message = "Invalid format";
        }
        if (isValid && typeof this._options.validation === "function") {
            var customValidation = this._options.validation(value);
            if (customValidation && !customValidation.isValid) {
                isValid = false;
                message = customValidation.message || "Invalid value";
            }
        }
        this.isValid = isValid;
        this._validationMessage = message;
        this.updateValidationState();
        return isValid;
    },
    updateValidationState: function updateValidationState() {
        if (!this.isValid) {
            this._validationElement.textContent = this._validationMessage;
            this._validationElement.style.display = "block";
            var containerClasses = this._container.className.split(" ");
            if (containerClasses.indexOf("input-field-invalid") === -1) {
                this._container.className += " input-field-invalid";
            }
            this._container.className = this._container.className.split(" ").filter(function(cls) {
                return cls !== "input-field-valid";
            }).join(" ");
        } else if (this.input.value.length > 0) {
            this._validationElement.style.display = "none";
            var containerClasses = this._container.className.split(" ");
            if (containerClasses.indexOf("input-field-valid") === -1) {
                this._container.className += " input-field-valid";
            }
            this._container.className = this._container.className.split(" ").filter(function(cls) {
                return cls !== "input-field-invalid";
            }).join(" ");
        } else {
            this._validationElement.style.display = "none";
            this._container.className = this._container.className.split(" ").filter(function(cls) {
                return cls !== "input-field-valid" && cls !== "input-field-invalid";
            }).join(" ");
        }
    },
    _updateState: function _updateState() {
        this._updateClearButton();
        this._updateCounter();
        this.validate();
    },
    getValue: function getValue() {
        return this.input.value.trim();
    },
    setValue: function setValue(value) {
        this.input.value = value;
        this._updateState();
        this._triggerChange();
    },
    setPlaceholder: function setPlaceholder(value) {
        this.input.placeholder = value;
        this._options.placeholder = value;
    },
    clear: function clear(bFocus) {
        bFocus = bFocus !== undefined ? bFocus : true;
        this.setValue("");
        if (bFocus) {
            this.input.focus();
        }
    },
    focus: function focus() {
        this.input.focus();
    },
    blur: function blur() {
        this.input.blur();
    },
    enable: function enable() {
        this.input.disabled = false;
        this._options.disabled = false;
        this._container.className = this._container.className.split(" ").filter(function(cls) {
            return cls !== "input-field-disabled";
        }).join(" ");
    },
    disable: function disable() {
        this.input.disabled = true;
        this._options.disabled = true;
        var containerClasses = this._container.className.split(" ");
        if (containerClasses.indexOf("input-field-disabled") === -1) {
            this._container.className += " input-field-disabled";
        }
    },
    subscribe: function subscribe(callback) {
        var self = this;
        this._subscribers.push(callback);
        return {
            unsubscribe: function unsubscribe() {
                self._subscribers = self._subscribers.filter(function(cb) {
                    return cb !== callback;
                });
            }
        };
    },
    _triggerInputEvent: function _triggerInputEvent(e) {
        var detail = {
            value: this.input.value,
            originalEvent: e
        };
        this._subscribers.forEach(function(cb) {
            cb({
                type: "inputfield:input",
                detail: detail
            });
        });
    },
    _triggerFocusEvent: function _triggerFocusEvent(e) {
        var detail = {
            value: this.input.value,
            originalEvent: e
        };
        this._subscribers.forEach(function(cb) {
            cb({
                type: "inputfield:focus",
                detail: detail
            });
        });
    },
    _triggerBlurEvent: function _triggerBlurEvent(e) {
        var detail = {
            value: this.input.value,
            originalEvent: e
        };
        this._subscribers.forEach(function(cb) {
            cb({
                type: "inputfield:blur",
                detail: detail
            });
        });
    },
    _triggerChange: function _triggerChange() {
        var detail = {
            value: this.input.value,
            isValid: this.isValid
        };
        this._subscribers.forEach(function(cb) {
            cb({
                type: "inputfield:change",
                detail: detail
            });
        });
    },
    _triggerSubmit: function _triggerSubmit() {
        var detail = {
            value: this.input.value,
            isValid: this.isValid
        };
        this._subscribers.forEach(function(cb) {
            cb({
                type: "inputfield:submit",
                detail: detail
            });
        });
    },
    destroy: function destroy() {
        this._subscribers = [];
        if (this._boundHandles) {
            try {
                this.input.removeEventListener("focus", this._boundHandles.focus);
                this.input.removeEventListener("blur", this._boundHandles.blur);
                this.input.removeEventListener("input", this._boundHandles.input);
                this.input.removeEventListener("keydown", this._boundHandles.keydown);
                if (this._clearButton) {
                    this._clearButton.removeEventListener("click", this._boundHandles.clear);
                }
                if (this._options.showSearchIcon && this._boundHandles.search) {
                    this._searchIcon.removeEventListener("click", this._boundHandles.search);
                }
                this.input.removeEventListener("change", this._boundHandles.validate);
            } catch (error) {
                console.error(error);
            }
        }
        this._container.innerHTML = "";
        this._container.className = this._container.className.split(" ").filter(function(cls) {
            return cls !== "input-field-container";
        }).join(" ");
    }
};

function Message(container, options) {
    if (typeof container === "string") {
        var temp = document.getElementById(container);
        if (temp instanceof HTMLElement) {
            container = temp;
        }
    }
    if (container instanceof HTMLElement) {
        this.container = container;
    } else {
        throw new Error("Invalid container element");
    }
    this._options = Object.assign(this._options, options);
    this._isShow = false;
}

Message.prototype = {
    constructor: Message,
    _options: {
        type: "info",
        text: "",
        title: "",
        duration: 0,
        closeButton: true,
        autoClose: false,
        closeOnClickOutside: true
    },
    _outsideClickListener: null,
    _element: null,
    _timeoutId: null,
    _create: function _create() {
        var messageEl = document.createElement("div");
        messageEl.className = "message message-" + this._options.type;
        messageEl.setAttribute("role", "alert");
        var title = this._options.title;
        if (!title) {
            title = "Error";
            switch (this._options.type) {
              case "success":
                title = "Success";
                break;

              case "warning":
                title = "Warning";
                break;

              case "info":
                title = "Information";
                break;
            }
        }
        var text = this._options.text;
        if (!text) {
            text = "";
            switch (this._options.type) {
              case "success":
                text = "Operation completed successfully.";
                break;

              case "warning":
                text = "Please be cautious.";
                break;

              case "error":
                text = "Something went wrong.";
                break;
            }
        }
        messageEl.innerHTML = '<div class="message-content">' + '<span class="message-title">' + title + "</span>" + '<span class="message-text">' + text + "</span>" + "</div>";
        if (this._options.closeButton) {
            var closeBtn = document.createElement("button");
            closeBtn.className = "message-close";
            closeBtn.textContent = "×";
            closeBtn.setAttribute("aria-label", "Close");
            closeBtn.onclick = this.close.bind(this);
            messageEl.appendChild(closeBtn);
        }
        return messageEl;
    },
    addOutsideClickListener: function addOutsideClickListener() {
        if (this._outsideClickListener) {
            document.removeEventListener("click", this._outsideClickListener);
        }
        var self = this;
        this._outsideClickListener = function(e) {
            if (e.target instanceof HTMLElement === false) {
                return;
            }
            if (self._element && !self._element.contains(e.target)) {
                self.close();
            }
        };
        setTimeout(function() {
            if (!self._outsideClickListener) {
                return;
            }
            document.addEventListener("click", self._outsideClickListener);
        }, 10);
    },
    removeOutsideClickListener: function removeOutsideClickListener() {
        if (this._outsideClickListener) {
            document.removeEventListener("click", this._outsideClickListener);
            this._outsideClickListener = null;
        }
    },
    show: function show(text, title) {
        if (this._isShow) {
            return this;
        }
        this._isShow = true;
        if (!this.container.classList.contains("message-container")) {
            this.container.classList.add("message-container");
        }
        if (title) {
            this._options.title = title;
        }
        if (text) {
            this._options.text = text;
        }
        var messageEl = this._create();
        this._element = messageEl;
        this.container.appendChild(messageEl);
        setTimeout(function() {
            messageEl.style.opacity = "1";
            messageEl.style.transform = "translateY(0)";
        }, 10);
        if (this._options.autoClose && Number(this._options.duration) > 0) {
            this._timeoutId = setTimeout(this.close.bind(this), this._options.duration);
        }
        if (this._options.closeOnClickOutside) {
            this.addOutsideClickListener();
        }
        return this;
    },
    close: function close() {
        this._isShow = false;
        if (!this._element || !this._element.parentNode) {
            return;
        }
        if (this._timeoutId) {
            clearTimeout(this._timeoutId);
            this._timeoutId = null;
        }
        this.removeOutsideClickListener();
        var _element = this._element;
        _element.style.opacity = "0";
        _element.style.transform = "translateY(-20px)";
        setTimeout(function() {
            if (_element.parentNode) {
                _element.parentNode.removeChild(_element);
            }
        }, 300);
    }
};

function Button(button, options) {
    var self = this;
    if (typeof button === "string") {
        var temp = document.getElementById(button);
        if (temp instanceof HTMLButtonElement) {
            button = temp;
        }
    }
    if (button instanceof HTMLButtonElement) {
        this._button = button;
    } else {
        throw new Error("Invalid button");
    }
    this._container = document.createElement("div");
    this._options = options || {};
    this._options.text = this._options.text || button.textContent.trim();
    this._options.type = this._options.type || "button";
    this._options.variant = this._options.variant || "primary";
    this._options.size = this._options.size || "medium";
    this._options.iconPosition = this._options.iconPosition || "left";
    this.isLoading = false;
    this._originalText = this._options.text;
    this._subscribers = [];
    this._boundHandles = {
        click: function click(e) {
            self._handleClick(e);
        },
        mouseenter: function mouseenter() {
            self._handleMouseEnter();
        },
        mouseleave: function mouseleave() {
            self._handleMouseLeave();
        },
        focus: function focus() {
            self._handleFocus();
        },
        blur: function blur() {
            self._handleBlur();
        },
        keydown: function keydown(e) {
            self._handleKeydown(e);
        }
    };
    this._createDOM();
    this._bindEvents();
    this.updateState();
}

Button.prototype = {
    constructor: Button,
    _button: null,
    _buttonText: null,
    _spinner: null,
    _badgeElement: null,
    _createDOM: function _createDOM() {
        var parent = this._button.parentNode;
        var fragment = document.createDocumentFragment();
        fragment.appendChild(this._container);
        this._container.className += " custom-button-container";
        this._button.className += " custom-button";
        this._button.className += " custom-button-" + this._options.variant;
        this._button.className += " custom-button-" + this._options.size;
        if (this._options.disabled) {
            this._button.className += " custom-button-disabled";
        }
        if (this._options.loading) {
            this._container.className += " custom-button-loading";
        }
        if (this._options.type) {
            this._button.type = this._options.type;
        }
        if (this._options.tooltip) {
            this._button.title = this._options.tooltip;
        }
        if (this._options.disabled) {
            this._button.disabled = true;
        }
        if (this._options.text) {
            this._button.textContent = "";
            this._buttonText = document.createElement("span");
            this._buttonText.className = "custom-button-text";
            this._buttonText.textContent = this._options.text || "";
            if (this._options.icon) {
                var iconSpan = document.createElement("span");
                iconSpan.className = "custom-button-icon";
                if (this._options.iconPosition === "left") {
                    iconSpan.className += " custom-button-icon-left";
                    this._button.appendChild(iconSpan);
                    this._button.appendChild(this._buttonText);
                } else {
                    iconSpan.className += " custom-button-icon-right";
                    this._button.appendChild(this._buttonText);
                    this._button.appendChild(iconSpan);
                }
                iconSpan.innerHTML = this._options.icon;
            } else {
                this._button.appendChild(this._buttonText);
            }
        }
        if (this._options.loading) {
            this._spinner = document.createElement("span");
            this._spinner.className = "custom-button-spinner";
            this._button.appendChild(this._spinner);
        }
        if (this._options.badge) {
            this._badgeElement = document.createElement("span");
            this._badgeElement.className = "custom-button-badge";
            this._badgeElement.textContent = this._options.badge;
            this._button.appendChild(this._badgeElement);
        }
        if (parent) {
            parent.insertBefore(fragment, this._button);
        }
        this._container.appendChild(this._button);
    },
    _bindEvents: function _bindEvents() {
        this._button.addEventListener("click", this._boundHandles.click);
        this._button.addEventListener("mouseenter", this._boundHandles.mouseenter);
        this._button.addEventListener("mouseleave", this._boundHandles.mouseleave);
        this._button.addEventListener("focus", this._boundHandles.focus);
        this._button.addEventListener("blur", this._boundHandles.blur);
        this._button.addEventListener("keydown", this._boundHandles.keydown);
    },
    _handleClick: function _handleClick(e) {
        if (this._options.disabled || this.isLoading) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }
        this.triggerClickEvent(e);
    },
    _handleMouseEnter: function _handleMouseEnter() {
        var classes = this._button.className.split(" ");
        if (classes.indexOf("custom-button-hover") === -1) {
            this._button.className += " custom-button-hover";
        }
        this.triggerEvent("mouseenter");
    },
    _handleMouseLeave: function _handleMouseLeave() {
        this._button.className = this._button.className.split(" ").filter(function(cls) {
            return cls !== "custom-button-hover";
        }).join(" ");
        this.triggerEvent("mouseleave");
    },
    _handleFocus: function _handleFocus() {
        var classes = this._button.className.split(" ");
        if (classes.indexOf("custom-button-focused") === -1) {
            this._button.className += " custom-button-focused";
        }
        this.triggerEvent("focus");
    },
    _handleBlur: function _handleBlur() {
        this._button.className = this._button.className.split(" ").filter(function(cls) {
            return cls !== "custom-button-focused";
        }).join(" ");
        this.triggerEvent("blur");
    },
    _handleKeydown: function _handleKeydown(e) {
        var key = e.key || e.keyCode;
        if (key === " " || key === "Enter" || key === 32 || key === 13) {
            if (this._button.tagName === "BUTTON") ; else {
                e.preventDefault();
                this._button.click();
            }
        } else if (key === "Escape" || key === 27) {
            this._button.blur();
        }
        this.triggerEvent("keydown", {
            key: key
        });
    },
    subscribe: function subscribe(callback) {
        var self = this;
        this._subscribers.push(callback);
        return {
            unsubscribe: function unsubscribe() {
                self._subscribers = self._subscribers.filter(function(cb) {
                    return cb !== callback;
                });
            }
        };
    },
    setText: function setText(text) {
        if (typeof text === "undefined") return;
        this._options.text = text;
        if (!this._buttonText) {
            this._buttonText = document.createElement("span");
            this._buttonText.className = "custom-button-text";
            this._buttonText.textContent = "";
            this._button.appendChild(this._buttonText);
        }
        this._buttonText.textContent = text;
    },
    setIcon: function setIcon(icon, position) {
        this._options.icon = icon;
        this._options.iconPosition = position || "left";
    },
    setBadge: function setBadge(badge) {
        if (typeof badge === "undefined") return;
        this._options.badge = badge;
        if (this._badgeElement) {
            this._badgeElement.textContent = badge;
            this._badgeElement.style.display = badge ? "flex" : "none";
        }
    },
    setVariant: function setVariant(variant) {
        if (typeof variant === "undefined") return;
        var oldClass = "custom-button-" + this._options.variant;
        var newClass = "custom-button-" + variant;
        this._button.className = this._button.className.split(" ").filter(function(cls) {
            return cls !== oldClass;
        }).join(" ") + " " + newClass;
        this._options.variant = variant;
    },
    setSize: function setSize(size) {
        if (typeof size === "undefined") return;
        var oldClass = "custom-button-" + this._options.size;
        var newClass = "custom-button-" + size;
        this._button.className = this._button.className.split(" ").filter(function(cls) {
            return cls !== oldClass;
        }).join(" ") + " " + newClass;
        this._options.size = size;
    },
    enable: function enable() {
        this._options.disabled = false;
        this._button.disabled = false;
        this._button.className = this._button.className.split(" ").filter(function(cls) {
            return cls !== "custom-button-disabled";
        }).join(" ");
    },
    disable: function disable() {
        this._options.disabled = true;
        this._button.disabled = true;
        var classes = this._button.className.split(" ");
        if (classes.indexOf("custom-button-disabled") === -1) {
            this._button.className += " custom-button-disabled";
        }
    },
    startLoading: function startLoading() {
        this.isLoading = true;
        if (typeof this._options.text !== "undefined") this._originalText = this._options.text;
        var containerClasses = this._container.className.split(" ");
        if (containerClasses.indexOf("custom-button-loading") === -1) {
            this._container.className += " custom-button-loading";
        }
        if (this._spinner) {
            this._spinner.style.display = "inline-block";
        }
        if (this._buttonText) {
            this._buttonText.textContent = "Loading...";
        }
        this._button.disabled = true;
    },
    stopLoading: function stopLoading() {
        this.isLoading = false;
        this._container.className = this._container.className.split(" ").filter(function(cls) {
            return cls !== "custom-button-loading";
        }).join(" ");
        if (this._spinner) {
            this._spinner.style.display = "none";
        }
        if (this._buttonText) {
            this._buttonText.textContent = this._originalText;
        }
        this._button.disabled = !!this._options.disabled;
    },
    setTooltip: function setTooltip(tooltip) {
        if (typeof tooltip === "undefined") return;
        this._options.tooltip = tooltip;
        this._button.title = tooltip || "";
    },
    triggerClickEvent: function triggerClickEvent(e) {
        var detail = {
            originalEvent: e,
            button: this
        };
        this._subscribers.forEach(function(cb) {
            cb({
                type: "button:click",
                detail: detail
            });
        });
    },
    triggerEvent: function triggerEvent(eventName, detail) {
        detail = detail || {};
        detail.button = this;
        this._subscribers.forEach(function(cb) {
            cb({
                type: "button:" + eventName,
                detail: detail
            });
        });
    },
    updateState: function updateState() {
        if (this._options.disabled) {
            this.disable();
        } else {
            this.enable();
        }
        if (this._options.loading) {
            this.startLoading();
        }
    },
    destroy: function destroy() {
        this._subscribers = [];
        if (this._boundHandles) {
            try {
                this._button.removeEventListener("click", this._boundHandles.click);
                this._button.removeEventListener("mouseenter", this._boundHandles.mouseenter);
                this._button.removeEventListener("mouseleave", this._boundHandles.mouseleave);
                this._button.removeEventListener("focus", this._boundHandles.focus);
                this._button.removeEventListener("blur", this._boundHandles.blur);
                this._button.removeEventListener("keydown", this._boundHandles.keydown);
            } catch (error) {
                console.error(error);
            }
        }
        this._container.innerHTML = "";
        var containerClasses = this._container.className.split(" ").filter(function(cls) {
            return cls !== "custom-button-container";
        }).join(" ");
        this._container.className = containerClasses;
    }
};

function _assertClassBrand(e, t, n) {
    if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
    throw new TypeError("Private element is not present on this object");
}

function _checkPrivateRedeclaration(e, t) {
    if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}

function _classPrivateFieldGet2(s, a) {
    return s.get(_assertClassBrand(s, a));
}

function _classPrivateFieldInitSpec(e, t, a) {
    _checkPrivateRedeclaration(e, t), t.set(e, a);
}

function _classPrivateFieldSet2(s, a, r) {
    return s.set(_assertClassBrand(s, a), r), r;
}

function _classPrivateMethodInitSpec(e, a) {
    _checkPrivateRedeclaration(e, a), a.add(e);
}

var _container = new WeakMap;

var _input = new WeakMap;

var _visualRadio = new WeakMap;

var _labelElement = new WeakMap;

var _options = new WeakMap;

var _handlers = new WeakMap;

var _subscribers = new WeakMap;

var _Radio_brand = new WeakSet;

class Radio {
    constructor(_radio, options) {
        _classPrivateMethodInitSpec(this, _Radio_brand);
        _classPrivateFieldInitSpec(this, _container, void 0);
        _classPrivateFieldInitSpec(this, _input, void 0);
        _classPrivateFieldInitSpec(this, _visualRadio, void 0);
        _classPrivateFieldInitSpec(this, _labelElement, null);
        _classPrivateFieldInitSpec(this, _options, void 0);
        _classPrivateFieldInitSpec(this, _handlers, new Map);
        _classPrivateFieldInitSpec(this, _subscribers, []);
        if (typeof _radio === "string") {
            var temp = document.getElementById(_radio);
            if (temp instanceof HTMLInputElement) {
                _radio = temp;
            }
        }
        if (!(_radio instanceof HTMLInputElement)) {
            throw new Error("Invalid input element");
        }
        _classPrivateFieldSet2(_input, this, _radio);
        _classPrivateFieldSet2(_options, this, Object.assign({
            id: "radio_".concat(Date.now(), "_").concat(Math.random().toString(36).slice(2, 11)),
            checked: false,
            disabled: false,
            indeterminate: false,
            label: "",
            name: "",
            value: "on"
        }, options));
        _assertClassBrand(_Radio_brand, this, _applyInputAttributes).call(this);
        _classPrivateFieldSet2(_container, this, document.createElement("div"));
        _classPrivateFieldSet2(_visualRadio, this, document.createElement("span"));
        _assertClassBrand(_Radio_brand, this, _createDOM).call(this);
        _assertClassBrand(_Radio_brand, this, _setupEventListeners).call(this);
        _assertClassBrand(_Radio_brand, this, _updateVisualState).call(this);
        if (!_classPrivateFieldGet2(_options, this).name) {
            throw new Error("Name attribute is required");
        }
        var sameNameInstances = _instances._.get(_classPrivateFieldGet2(_options, this).name);
        if (!sameNameInstances) {
            sameNameInstances = new Array;
            _instances._.set(_classPrivateFieldGet2(_options, this).name, sameNameInstances);
        }
        sameNameInstances.push(this);
    }
    subscribe(callback) {
        var self = this;
        _classPrivateFieldGet2(_subscribers, this).push(callback);
        return {
            unsubscribe: function unsubscribe() {
                _classPrivateFieldSet2(_subscribers, self, _classPrivateFieldGet2(_subscribers, self).filter(function(cb) {
                    return cb !== callback;
                }));
            }
        };
    }
    getElement() {
        return _classPrivateFieldGet2(_container, this);
    }
    check(bSilent) {
        if (_classPrivateFieldGet2(_options, this).disabled || _classPrivateFieldGet2(_options, this).checked) return;
        if (_classPrivateFieldGet2(_options, this).name) {
            var radios = _instances._.get(_classPrivateFieldGet2(_options, this).name);
            radios && radios.forEach(radio => {
                if (radio !== this && _classPrivateFieldGet2(_options, radio).checked) {
                    radio.uncheck();
                }
            });
        }
        _classPrivateFieldGet2(_options, this).checked = true;
        _assertClassBrand(_Radio_brand, this, _updateVisualState).call(this);
        if (bSilent) return;
        _assertClassBrand(_Radio_brand, this, _triggerChange).call(this);
    }
    uncheck(bSilent) {
        if (_classPrivateFieldGet2(_options, this).disabled || !_classPrivateFieldGet2(_options, this).checked) return;
        _classPrivateFieldGet2(_options, this).checked = false;
        _assertClassBrand(_Radio_brand, this, _updateVisualState).call(this);
        if (bSilent) return;
        _assertClassBrand(_Radio_brand, this, _triggerChange).call(this);
    }
    enable() {
        if (!_classPrivateFieldGet2(_options, this).disabled) return;
        _classPrivateFieldGet2(_options, this).disabled = false;
        _classPrivateFieldGet2(_input, this).disabled = false;
        _classPrivateFieldGet2(_container, this).setAttribute("aria-disabled", "false");
        if (_classPrivateFieldGet2(_options, this).checked) {
            _classPrivateFieldGet2(_container, this).tabIndex = 0;
        } else {
            _assertClassBrand(_Radio_brand, this, _updateRadioGroupTabIndex).call(this);
        }
        _classPrivateFieldGet2(_container, this).classList.remove("radio--disabled");
    }
    disable() {
        if (_classPrivateFieldGet2(_options, this).disabled) return;
        _classPrivateFieldGet2(_options, this).disabled = true;
        _classPrivateFieldGet2(_input, this).disabled = true;
        _classPrivateFieldGet2(_container, this).setAttribute("aria-disabled", "true");
        _classPrivateFieldGet2(_container, this).tabIndex = -1;
        _classPrivateFieldGet2(_container, this).classList.add("radio--disabled");
    }
    setLabel(label) {
        _classPrivateFieldGet2(_options, this).label = label;
        if (_classPrivateFieldGet2(_labelElement, this)) {
            _classPrivateFieldGet2(_labelElement, this).textContent = label;
        } else if (label) {
            _classPrivateFieldSet2(_labelElement, this, document.createElement("label"));
            _classPrivateFieldGet2(_labelElement, this).className = "radio-label";
            _classPrivateFieldGet2(_labelElement, this).htmlFor = String(_classPrivateFieldGet2(_options, this).id);
            _classPrivateFieldGet2(_labelElement, this).textContent = label;
            _classPrivateFieldGet2(_container, this).appendChild(_classPrivateFieldGet2(_labelElement, this));
        }
    }
    getState() {
        return {
            checked: !!_classPrivateFieldGet2(_options, this).checked,
            disabled: !!_classPrivateFieldGet2(_options, this).disabled,
            value: _classPrivateFieldGet2(_options, this).value || "",
            name: _classPrivateFieldGet2(_options, this).name || ""
        };
    }
    destroy() {
        _classPrivateFieldSet2(_subscribers, this, []);
        if (!_classPrivateFieldGet2(_options, this).name) return;
        var sameNameInstances = _instances._.get(_classPrivateFieldGet2(_options, this).name);
        if (sameNameInstances) {
            var index = sameNameInstances.indexOf(this);
            if (index >= 0) sameNameInstances.splice(index, 1);
        }
        _classPrivateFieldGet2(_handlers, this).forEach((handler, event) => {
            _classPrivateFieldGet2(_container, this).removeEventListener(event, handler);
        });
        _classPrivateFieldGet2(_handlers, this).clear();
        if (_classPrivateFieldGet2(_container, this) && _classPrivateFieldGet2(_container, this).parentNode) {
            _classPrivateFieldGet2(_container, this).parentNode.removeChild(_classPrivateFieldGet2(_container, this));
        }
        _classPrivateFieldSet2(_labelElement, this, null);
    }
}

function _applyInputAttributes() {
    _classPrivateFieldGet2(_input, this).type = "radio";
    var elId = _classPrivateFieldGet2(_input, this).getAttribute("id");
    var elName = _classPrivateFieldGet2(_input, this).getAttribute("name");
    var elValue = _classPrivateFieldGet2(_input, this).getAttribute("value");
    var elChecked = _classPrivateFieldGet2(_input, this).getAttribute("checked");
    var elDisabled = _classPrivateFieldGet2(_input, this).getAttribute("disabled");
    if (elId !== null) {
        _classPrivateFieldGet2(_options, this).id = elId;
    } else if (_classPrivateFieldGet2(_options, this).id) {
        _classPrivateFieldGet2(_input, this).setAttribute("id", _classPrivateFieldGet2(_options, this).id);
    }
    if (elName !== null) {
        _classPrivateFieldGet2(_options, this).name = elName;
    } else if (_classPrivateFieldGet2(_options, this).name) {
        _classPrivateFieldGet2(_input, this).setAttribute("name", _classPrivateFieldGet2(_options, this).name);
    }
    if (elValue !== null) {
        _classPrivateFieldGet2(_options, this).value = elValue;
    } else if (_classPrivateFieldGet2(_options, this).value) {
        _classPrivateFieldGet2(_input, this).setAttribute("value", _classPrivateFieldGet2(_options, this).value);
    }
    if (elChecked !== null) {
        _classPrivateFieldGet2(_options, this).checked = elChecked === "true";
    } else if (_classPrivateFieldGet2(_options, this).checked) {
        _classPrivateFieldGet2(_input, this).setAttribute("checked", "true");
    }
    if (elDisabled !== null) {
        _classPrivateFieldGet2(_options, this).disabled = elDisabled === "true";
    } else if (_classPrivateFieldGet2(_options, this).disabled) {
        _classPrivateFieldGet2(_input, this).setAttribute("disabled", "true");
    }
}

function _createDOM() {
    var parent = _classPrivateFieldGet2(_input, this).parentNode;
    var fragment = document.createDocumentFragment();
    fragment.appendChild(_classPrivateFieldGet2(_container, this));
    _classPrivateFieldGet2(_container, this).classList.add("radio-button-container");
    _classPrivateFieldGet2(_container, this).setAttribute("role", "radio");
    _classPrivateFieldGet2(_container, this).setAttribute("aria-checked", String(!!_classPrivateFieldGet2(_options, this).checked));
    _classPrivateFieldGet2(_container, this).setAttribute("aria-disabled", String(!!_classPrivateFieldGet2(_options, this).disabled));
    _classPrivateFieldGet2(_container, this).tabIndex = _classPrivateFieldGet2(_options, this).disabled ? -1 : 0;
    _classPrivateFieldGet2(_visualRadio, this).className = "radio-visual";
    _classPrivateFieldGet2(_visualRadio, this).setAttribute("aria-hidden", "true");
    if (_classPrivateFieldGet2(_options, this).label) {
        _classPrivateFieldSet2(_labelElement, this, document.createElement("label"));
        _classPrivateFieldGet2(_labelElement, this).className = "i18n radio-label";
        _classPrivateFieldGet2(_labelElement, this).htmlFor = String(_classPrivateFieldGet2(_options, this).id);
        _classPrivateFieldGet2(_labelElement, this).textContent = _classPrivateFieldGet2(_options, this).label;
    }
    if (_classPrivateFieldGet2(_options, this).disabled) {
        _classPrivateFieldGet2(_container, this).classList.add("radio--disabled");
    }
    if (parent) {
        parent.insertBefore(fragment, _classPrivateFieldGet2(_input, this));
    }
    _classPrivateFieldGet2(_container, this).appendChild(_classPrivateFieldGet2(_input, this));
    _classPrivateFieldGet2(_container, this).appendChild(_classPrivateFieldGet2(_visualRadio, this));
    if (_classPrivateFieldGet2(_labelElement, this)) {
        _classPrivateFieldGet2(_container, this).appendChild(_classPrivateFieldGet2(_labelElement, this));
    }
    _assertClassBrand(_Radio_brand, this, _updateRadioGroupTabIndex).call(this);
}

function _updateRadioGroupTabIndex() {
    if (_classPrivateFieldGet2(_options, this).checked) {
        _classPrivateFieldGet2(_container, this).tabIndex = _classPrivateFieldGet2(_options, this).disabled ? -1 : 0;
    } else if (_classPrivateFieldGet2(_options, this).name && _instances._.has(_classPrivateFieldGet2(_options, this).name)) {
        var radios = _instances._.get(_classPrivateFieldGet2(_options, this).name);
        var hasChecked = false;
        radios && radios.forEach(radio => {
            if (_classPrivateFieldGet2(_options, radio).checked && radio !== this) {
                hasChecked = true;
            }
        });
        if (!hasChecked && !_classPrivateFieldGet2(_options, this).checked && !_classPrivateFieldGet2(_options, this).disabled) {
            _classPrivateFieldGet2(_container, this).tabIndex = 0;
        } else {
            _classPrivateFieldGet2(_container, this).tabIndex = -1;
        }
    }
}

function _setupEventListeners() {
    var handleClick = e => {
        e.preventDefault();
        if (!_classPrivateFieldGet2(_options, this).disabled && !_classPrivateFieldGet2(_options, this).checked) {
            this.check();
            _classPrivateFieldGet2(_container, this).focus();
        }
    };
    var handleKeyDown = e => {
        if (_classPrivateFieldGet2(_options, this).disabled) return;
        switch (e.key) {
          case " ":
          case "Spacebar":
          case "Enter":
            e.preventDefault();
            if (!_classPrivateFieldGet2(_options, this).checked) {
                this.check();
            }
            break;
        }
    };
    var handleFocus = () => {
        _classPrivateFieldGet2(_container, this).classList.add("radio--focused");
    };
    var handleBlur = () => {
        _classPrivateFieldGet2(_container, this).classList.remove("radio--focused");
    };
    _classPrivateFieldGet2(_handlers, this).set("click", handleClick);
    _classPrivateFieldGet2(_handlers, this).set("keydown", handleKeyDown);
    _classPrivateFieldGet2(_handlers, this).set("focus", handleFocus);
    _classPrivateFieldGet2(_handlers, this).set("blur", handleBlur);
    _classPrivateFieldGet2(_container, this).addEventListener("click", handleClick);
    _classPrivateFieldGet2(_container, this).addEventListener("keydown", handleKeyDown);
    _classPrivateFieldGet2(_container, this).addEventListener("focus", handleFocus);
    _classPrivateFieldGet2(_container, this).addEventListener("blur", handleBlur);
}

function _updateVisualState() {
    _classPrivateFieldGet2(_container, this).setAttribute("aria-checked", String(!!_classPrivateFieldGet2(_options, this).checked));
    _classPrivateFieldGet2(_container, this).classList.toggle("radio--checked", _classPrivateFieldGet2(_options, this).checked);
    _classPrivateFieldGet2(_input, this).checked = !!_classPrivateFieldGet2(_options, this).checked;
    _assertClassBrand(_Radio_brand, this, _updateRadioGroupTabIndex).call(this);
}

function _triggerChange(e) {
    var detail = this.getState();
    var objEvent = {
        type: "radio:change",
        detail: detail
    };
    if (e) {
        objEvent.originalEvent = e;
    }
    _classPrivateFieldGet2(_subscribers, this).forEach(function(cb) {
        cb(objEvent);
    });
}

var _instances = {
    _: new Map
};

function Checkbox(checkbox, options) {
    if (typeof checkbox === "string") {
        var temp = document.getElementById(checkbox);
        if (temp instanceof HTMLInputElement) {
            checkbox = temp;
        }
    }
    if (checkbox instanceof HTMLInputElement === false) {
        throw new Error("Invalid input element");
    }
    this._options = Object.assign({
        id: "checkbox_".concat(Date.now(), "_").concat(Math.random().toString(36).slice(2, 11)),
        checked: false,
        disabled: false,
        indeterminate: false,
        label: "",
        name: "",
        value: "on"
    }, options);
    this._options.disabled = options.disabled || false;
    this._handlers = new Map;
    this._createDOM(checkbox);
    this._setupEventListeners();
    this._updateVisualState();
    this._subscribers = [];
}

Checkbox.prototype = {
    constructor: Checkbox,
    _container: null,
    _input: null,
    _visualCheckbox: null,
    _labelElement: null,
    _createDOM: function _createDOM(checkbox) {
        var parent = checkbox.parentNode;
        var fragment = document.createDocumentFragment();
        this._container = document.createElement("div");
        fragment.appendChild(this._container);
        this._container.classList.add("checkbox-container");
        this._container.setAttribute("role", "checkbox");
        this._container.setAttribute("aria-checked", this._options.checked ? "true" : "false");
        this._container.setAttribute("aria-disabled", this._options.disabled ? "true" : "false");
        this._container.tabIndex = this._options.disabled ? -1 : 0;
        this._input = checkbox;
        var elId = this._input.getAttribute("id");
        if (elId !== null) {
            this._options.id = elId;
        } else if (this._options.id) {
            this._input.setAttribute("id", this._options.id);
        }
        this._input.type = "checkbox";
        if (this._options.name) {
            this._input.name = this._options.name;
        }
        if (this._options.value) {
            this._input.value = this._options.value;
        }
        this._input.checked = !!this._options.checked;
        if (this._options.disabled) {
            this._input.disabled = true;
        }
        if (this._options.indeterminate) {
            this._input.indeterminate = true;
        }
        this._visualCheckbox = document.createElement("span");
        this._visualCheckbox.className = "checkbox-visual";
        this._visualCheckbox.setAttribute("aria-hidden", "true");
        var svgNS = "http://www.w3.org/2000/svg";
        var checkmarkSVG = document.createElementNS(svgNS, "svg");
        checkmarkSVG.setAttribute("viewBox", "0 0 10 8");
        checkmarkSVG.setAttribute("class", "checkbox-checkmark");
        var path = document.createElementNS(svgNS, "path");
        path.setAttribute("d", "M0.682129 3.40702L3.68213 6.20702L9.18218 0.707116");
        path.setAttribute("fill", "none");
        path.setAttribute("stroke", "currentColor");
        path.setAttribute("stroke-width", "2");
        checkmarkSVG.appendChild(path);
        this._visualCheckbox.appendChild(checkmarkSVG);
        var indeterminateLine = document.createElement("span");
        indeterminateLine.className = "checkbox-indeterminate";
        this._visualCheckbox.appendChild(indeterminateLine);
        if (this._options.label) {
            this._labelElement = document.createElement("label");
            this._labelElement.className = "checkbox-label i18n";
            if (this._options.id) this._labelElement.htmlFor = this._options.id;
            this._labelElement.textContent = this._options.label;
        }
        if (this._options.disabled) {
            this._container.classList.add("checkbox--disabled");
        }
        if (parent) {
            parent.insertBefore(fragment, checkbox);
        }
        this._container.appendChild(this._input);
        this._container.appendChild(this._visualCheckbox);
        if (this._labelElement) {
            this._container.appendChild(this._labelElement);
        }
    },
    _setupEventListeners: function _setupEventListeners() {
        var self = this;
        if (!this._container) return;
        var handleClick = function handleClick(e) {
            e.preventDefault();
            if (!self._options.disabled && self._container) {
                self.toggle();
                self._container.focus();
            }
        };
        var handleKeyDown = function handleKeyDown(e) {
            if (self._options.disabled) return;
            switch (e.key) {
              case " ":
              case "Spacebar":
              case "Enter":
                e.preventDefault();
                self.toggle();
                break;

              case "ArrowRight":
              case "ArrowDown":
                e.preventDefault();
                if (!self._options.checked && !self._options.indeterminate) {
                    self._options.checked ? self.setIndeterminate() : self.check();
                }
                break;

              case "ArrowLeft":
              case "ArrowUp":
                e.preventDefault();
                if (self._options.checked || self._options.indeterminate) {
                    self._options.indeterminate ? self.uncheck() : self.setIndeterminate();
                }
                break;
            }
        };
        var handleFocus = function handleFocus() {
            if (!self._container) return;
            self._container.classList.add("checkbox--focused");
        };
        var handleBlur = function handleBlur() {
            if (!self._container) return;
            self._container.classList.remove("checkbox--focused");
        };
        this._handlers.set("click", handleClick);
        this._handlers.set("keydown", handleKeyDown);
        this._handlers.set("focus", handleFocus);
        this._handlers.set("blur", handleBlur);
        this._container.addEventListener("click", handleClick);
        this._container.addEventListener("keydown", handleKeyDown);
        this._container.addEventListener("focus", handleFocus);
        this._container.addEventListener("blur", handleBlur);
    },
    _updateVisualState: function _updateVisualState() {
        if (!this._container || !this._input) return;
        this._container.setAttribute("aria-checked", this._options.indeterminate ? "mixed" : String(this._options.checked));
        this._container.classList.toggle("checkbox--checked", this._options.checked);
        this._container.classList.toggle("checkbox--indeterminate", this._options.indeterminate);
        this._input.checked = !!this._options.checked;
        this._input.indeterminate = !!this._options.indeterminate;
    },
    toggle: function toggle() {
        if (this._options.disabled) return !!this._options.checked;
        if (this._options.indeterminate) {
            this._options.indeterminate = false;
            this._options.checked = true;
        } else {
            this._options.checked = !this._options.checked;
        }
        this._updateVisualState();
        this._triggerChange();
        return this._options.checked;
    },
    check: function check(bSilent) {
        if (this._options.disabled || this._options.checked && !this._options.indeterminate) return;
        this._options.checked = true;
        this._options.indeterminate = false;
        this._updateVisualState();
        if (!bSilent) this._triggerChange();
    },
    uncheck: function uncheck(bSilent) {
        if (this._options.disabled || !this._options.checked && !this._options.indeterminate) return;
        this._options.checked = false;
        this._options.indeterminate = false;
        this._updateVisualState();
        if (!bSilent) this._triggerChange();
    },
    setIndeterminate: function setIndeterminate() {
        if (this._options.disabled || this._options.indeterminate) return;
        this._options.indeterminate = true;
        this._updateVisualState();
        this._triggerChange();
    },
    enable: function enable() {
        if (!this._options.disabled || !this._container || !this._input) return;
        this._options.disabled = false;
        this._input.disabled = false;
        this._container.setAttribute("aria-disabled", "false");
        this._container.tabIndex = 0;
        this._container.classList.remove("checkbox--disabled");
    },
    disable: function disable() {
        if (this._options.disabled || !this._container || !this._input) return;
        this._options.disabled = true;
        this._input.disabled = true;
        this._container.setAttribute("aria-disabled", "true");
        this._container.tabIndex = -1;
        this._container.classList.add("checkbox--disabled");
    },
    setLabel: function setLabel(label) {
        this._options.label = label;
        if (this._labelElement) {
            this._labelElement.textContent = label;
        } else if (label && this._container) {
            this._labelElement = document.createElement("label");
            this._labelElement.className = "checkbox-label";
            if (this._options.id) this._labelElement.htmlFor = this._options.id;
            this._labelElement.textContent = label;
            this._container.appendChild(this._labelElement);
        }
    },
    getState: function getState() {
        if (this._input) {
            return {
                checked: this._input.checked,
                disabled: this._input.disabled,
                value: this._input.value
            };
        }
        return {
            checked: false,
            disabled: false,
            value: ""
        };
    },
    subscribe: function subscribe(callback) {
        var self = this;
        this._subscribers.push(callback);
        return {
            unsubscribe: function unsubscribe() {
                self._subscribers = self._subscribers.filter(function(cb) {
                    return cb !== callback;
                });
            }
        };
    },
    _triggerChange: function _triggerChange(e) {
        var detail = this.getState();
        var objEvent = {
            type: "checkbox:change",
            detail: detail
        };
        if (e) {
            objEvent.originalEvent = e;
        }
        this._subscribers.forEach(function(cb) {
            cb(objEvent);
        });
    },
    destroy: function destroy() {
        this._subscribers = [];
        this._handlers.forEach((handler, event) => {
            this._container && this._container.removeEventListener(event, handler);
        });
        this._handlers.clear();
        if (this._container && this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }
        this._container = null;
        this._input = null;
        this._visualCheckbox = null;
        this._labelElement = null;
    }
};

function SelectBox(container, options) {
    var self = this;
    if (typeof container === "string") {
        var temp = document.getElementById(container);
        if (temp instanceof HTMLElement) {
            container = temp;
        }
    }
    if (container instanceof HTMLElement) {
        this._container = container;
    } else {
        throw new Error("Invalid container");
    }
    this._options = Object.assign(options, {
        placeholder: options.placeholder || "Select...",
        searchable: options.searchable || false,
        multiple: options.multiple || false,
        description: options.description || ""
    });
    this._selectedValues = new Set;
    this.isOpen = false;
    this._items = [];
    this._customItems = [];
    this._subscribers = [];
    this._boundHandles = {
        toggle: function toggle(e) {
            self._toggle(e);
        },
        search: function search(e) {
            self._handleSearch(e);
        },
        close: function close(e) {
            if (e.target instanceof HTMLElement && !self._container.contains(e.target) && !e.target.classList.contains("selectbox-option")) {
                self._closeDropdown();
            }
        },
        keydown: function keydown(e) {
            self._handleKeydown(e);
        },
        dropdownClick: function dropdownClick(e) {
            self._handleDropdownClick(e);
        }
    };
    this._optionsContainer = null;
    this.searchInput = null;
    this._select = document.createElement("div");
    this._header = document.createElement("div");
    this._selectedText = document.createElement("span");
    this._arrow = document.createElement("span");
    this._dropdown = document.createElement("div");
    this._createDOM();
    this._bindEvents();
    this._renderOptions();
}

SelectBox.prototype = {
    constructor: SelectBox,
    _createDOM: function _createDOM() {
        this._container.innerHTML = "";
        this._container.className += " selectbox-container";
        var fragment = document.createDocumentFragment();
        this._select.className += " selectbox";
        if (this._options.multiple) {
            this._select.className += " selectbox-multiple";
        }
        fragment.appendChild(this._select);
        this._header.className += " selectbox-header";
        this._select.appendChild(this._header);
        this._header.setAttribute("tabindex", "0");
        this._selectedText.className += " selectbox-selected-text";
        this._selectedText.textContent = this._options.placeholder;
        this._header.appendChild(this._selectedText);
        this._arrow.className += " selectbox-arrow";
        this._arrow.innerHTML = '<svg width="6" height="6" viewBox="0 0 6 6" ' + 'fill="none" xmlns="http://www.w3.org/2000/svg">' + '<path fill-rule="evenodd" clip-rule="evenodd"' + ' d="M3 0L0 2.9978L3 5.99561L6 2.9978L3 0ZM3 0.00053797L0.75 2.24889L3 4.49724L5.25 ' + '2.24889L3 0.00053797Z" fill="currentColor"/>' + "</svg>";
        this._header.appendChild(this._arrow);
        this._dropdown.className += " selectbox-dropdown";
        this._select.appendChild(this._dropdown);
        if (this._options.description) {
            var description = document.createElement("div");
            description.className += " i18n selectbox-description";
            description.textContent = this._options.description;
            this._dropdown.appendChild(description);
        }
        if (this._options.searchable) {
            var search = document.createElement("div");
            search.className += " selectbox-search";
            this._dropdown.appendChild(search);
            this.searchInput = document.createElement("input");
            this.searchInput.className += " selectbox-search-input";
            this.searchInput.type = "text";
            this.searchInput.placeholder = "Search...";
            search.appendChild(this.searchInput);
        }
        this._optionsContainer = document.createElement("div");
        this._optionsContainer.className += " selectbox-options";
        this._dropdown.appendChild(this._optionsContainer);
        this._container.appendChild(fragment);
    },
    _bindEvents: function _bindEvents() {
        this._header.addEventListener("click", this._boundHandles.toggle);
        if (this.searchInput) {
            this.searchInput.addEventListener("input", this._boundHandles.search);
        }
        this._dropdown.addEventListener("click", this._boundHandles.dropdownClick);
        this._dropdown.addEventListener("wheel", function(e) {
            e.stopPropagation();
        });
        this._header.addEventListener("keydown", this._boundHandles.keydown);
        this._dropdown.addEventListener("keydown", this._boundHandles.keydown);
    },
    _toggle: function _toggle(e) {
        e && e.stopPropagation();
        this.isOpen ? this._closeDropdown() : this.openDropdown();
    },
    openDropdown: function openDropdown() {
        if (!this.isOpen) {
            document.addEventListener("click", this._boundHandles.close);
        }
        this.isOpen = true;
        this._dropdown.style.display = "block";
        this._arrow.className += " selectbox-arrow-open";
        this._header.className += " selectbox-header-open";
        if (this.searchInput) {
            setTimeout(function(self) {
                return function() {
                    if (self.searchInput) {
                        self.searchInput.focus();
                    }
                };
            }(this), 100);
        }
        this._renderOptions();
    },
    _closeDropdown: function _closeDropdown() {
        if (this.isOpen && document && this._boundHandles) {
            document.removeEventListener("click", this._boundHandles.close);
        }
        this.isOpen = false;
        this._dropdown.style.display = "none";
        var arrowClasses = this._arrow.className.split(" ");
        var newArrowClasses = [];
        for (var i = 0; i < arrowClasses.length; i++) {
            if (arrowClasses[i] !== "selectbox-arrow-open") {
                newArrowClasses.push(arrowClasses[i]);
            }
        }
        this._arrow.className = newArrowClasses.join(" ");
        var headerClasses = this._header.className.split(" ");
        var newHeaderClasses = [];
        for (var i = 0; i < headerClasses.length; i++) {
            if (headerClasses[i] !== "selectbox-header-open") {
                newHeaderClasses.push(headerClasses[i]);
            }
        }
        this._header.className = newHeaderClasses.join(" ");
        if (this.searchInput) {
            this.searchInput.value = "";
        }
    },
    _handleSearch: function _handleSearch(e) {
        var target = e.target;
        if (!(target instanceof HTMLInputElement)) {
            return;
        }
        var searchTerm = target.value.toLowerCase();
        this._renderOptions(searchTerm);
    },
    _selectNextPrevItem: function _selectNextPrevItem(direction) {
        var searchTerm = this.searchInput ? this.searchInput.value.toLowerCase() : "";
        var newItem;
        var items = this._items.filter(function(item) {
            return item !== null;
        });
        if (searchTerm) {
            items = items.filter(function(item) {
                return item.text.toLowerCase().indexOf(searchTerm) !== -1;
            });
        }
        if (items.length === 0) {
            return;
        }
        if (direction === "up") {
            if (this._selectedValues.size === 0 && items.length > 0) {
                newItem = items[items.length - 1];
                this._selectedValues.add(newItem.value);
            } else {
                var selectedArray = Array.from(this._selectedValues);
                var currentIndex = -1;
                for (var i = 0; i < items.length; i++) {
                    if (items[i].value === selectedArray[0]) {
                        currentIndex = i;
                        break;
                    }
                }
                var prevIndex = (currentIndex - 1 + items.length) % items.length;
                this._selectedValues.clear();
                newItem = items[prevIndex];
                this._selectedValues.add(newItem.value);
            }
        } else {
            if (this._selectedValues.size === 0 && items.length > 0) {
                newItem = items[0];
                this._selectedValues.add(newItem.value);
            } else {
                var selectedArray = Array.from(this._selectedValues);
                var currentIndex = -1;
                for (var i = 0; i < items.length; i++) {
                    if (items[i].value === selectedArray[0]) {
                        currentIndex = i;
                        break;
                    }
                }
                var nextIndex = (currentIndex + 1) % items.length;
                if (nextIndex === items.length) {
                    nextIndex = 0;
                }
                this._selectedValues.clear();
                newItem = items[nextIndex];
                this._selectedValues.add(newItem.value);
            }
        }
        this._updateSelectedText();
        this._renderOptions(searchTerm, true);
        this._triggerChange(newItem.value, true);
    },
    _handleKeydown: function _handleKeydown(e) {
        var key = e.key || e.keyCode;
        switch (key) {
          case "Enter":
          case 13:
            e.preventDefault();
            this._toggle(e);
            break;

          case "Escape":
          case 27:
            this._closeDropdown();
            break;

          case "ArrowDown":
          case 40:
            e.preventDefault();
            this._selectNextPrevItem("down");
            break;

          case "ArrowUp":
          case 38:
            e.preventDefault();
            this._selectNextPrevItem("up");
            break;

          case "Tab":
          case 9:
            this._closeDropdown();
            break;
        }
    },
    _renderOptions: function _renderOptions(searchTerm, scrollIntoView) {
        searchTerm = searchTerm || "";
        if (!this._optionsContainer) return;
        this._optionsContainer.innerHTML = "";
        var selectedOption = null;
        var filteredItems = this._items;
        if (searchTerm) {
            filteredItems = filteredItems.filter(function(item) {
                return item !== null && item.text.toLowerCase().indexOf(searchTerm) !== -1;
            });
        }
        var fragment = document.createDocumentFragment();
        for (var i = 0; i < filteredItems.length; i++) {
            var item = filteredItems[i];
            if (!item) {
                var hr = document.createElement("hr");
                hr.className += " selectbox-option-divider";
                fragment.appendChild(hr);
                continue;
            }
            var option = document.createElement("div");
            option.className += " selectbox-option";
            if (this._selectedValues.has(item.value)) {
                option.className += " selectbox-option-selected checkbox--checked";
                selectedOption = option;
            }
            option.setAttribute("data-value", item.value);
            var label = document.createElement("label");
            label.className += " selectbox-option-text";
            label.textContent = item.text;
            if (this._options.multiple) {
                option.className += " selectbox-option-checkbox";
                var input = document.createElement("input");
                input.type = "checkbox";
                input.id = "checkbox-" + item.value;
                input.className += " selectbox-checkbox";
                input.checked = this._selectedValues.has(item.value);
                option.appendChild(input);
                var visualCheckbox = document.createElement("span");
                visualCheckbox.className = "checkbox-visual";
                visualCheckbox.setAttribute("aria-hidden", "true");
                var svgNS = "http://www.w3.org/2000/svg";
                var checkmarkSVG = document.createElementNS(svgNS, "svg");
                checkmarkSVG.setAttribute("viewBox", "0 0 10 8");
                checkmarkSVG.setAttribute("class", "checkbox-checkmark");
                var path = document.createElementNS(svgNS, "path");
                path.setAttribute("d", "M0.682129 3.40702L3.68213 6.20702L9.18218 0.707116");
                path.setAttribute("fill", "none");
                path.setAttribute("stroke", "currentColor");
                path.setAttribute("stroke-width", "2");
                checkmarkSVG.appendChild(path);
                visualCheckbox.appendChild(checkmarkSVG);
                option.appendChild(visualCheckbox);
            }
            option.appendChild(label);
            fragment.appendChild(option);
        }
        if (this._customItems.length) {
            var _hr = document.createElement("hr");
            _hr.className += " selectbox-option-divider";
            fragment.appendChild(_hr);
        }
        for (var i = 0; i < this._customItems.length; i++) {
            var _item = this._customItems[i];
            var _option = document.createElement("label");
            _option.className += " selectbox-custom-option";
            _option.setAttribute("data-value", _item.value);
            _option.setAttribute("for", _item.value);
            var span = document.createElement("span");
            span.className += " selectbox-option-text";
            span.textContent = _item.text;
            _option.appendChild(span);
            fragment.appendChild(_option);
        }
        this._optionsContainer.appendChild(fragment);
        if (scrollIntoView && this.isOpen && this._optionsContainer && selectedOption) {
            try {
                if (selectedOption.scrollIntoView) {
                    selectedOption.scrollIntoView({
                        block: "nearest"
                    });
                }
            } catch (err) {
                console.error(err);
            }
        }
    },
    _handleDropdownClick: function _handleDropdownClick(e) {
        var target = e.target || e.srcElement;
        var option = null;
        if (target && target instanceof HTMLElement) {
            var temp = null;
            var classList = target.className.split(" ");
            var hasOptionClass = false;
            for (var i = 0; i < classList.length; i++) {
                if (classList[i] === "selectbox-option") {
                    hasOptionClass = true;
                    break;
                } else if (classList[i] === "selectbox-custom-option") {
                    var val = target.getAttribute("data-value");
                    if (val) {
                        e.stopPropagation();
                        this._triggerCustomChange(val);
                        this._closeDropdown();
                        return;
                    }
                    break;
                }
            }
            if (hasOptionClass) {
                temp = target;
            } else if (target.parentNode && target.parentNode instanceof HTMLElement) {
                var parentClassList = target.parentNode.className.split(" ");
                var parentHasOptionClass = false;
                for (var i = 0; i < parentClassList.length; i++) {
                    if (parentClassList[i] === "selectbox-option") {
                        parentHasOptionClass = true;
                        break;
                    } else if (parentClassList[i] === "selectbox-custom-option") {
                        var _val = target.parentNode.getAttribute("data-value");
                        if (_val) {
                            e.stopPropagation();
                            this._triggerCustomChange(_val);
                            this._closeDropdown();
                            return;
                        }
                        break;
                    }
                }
                if (parentHasOptionClass) {
                    temp = target.parentNode;
                }
            }
            if (temp instanceof HTMLDivElement) {
                option = temp;
            } else {
                return;
            }
        } else {
            return;
        }
        var value = option.getAttribute("data-value");
        if (value === null) return;
        var enabled = true;
        if (this._options.multiple) {
            if (this._selectedValues.has(value)) {
                this.unselectItems(value, true);
                enabled = false;
            } else {
                this.selectItems(value, true);
            }
        } else {
            this.selectItems(value, true);
            this._closeDropdown();
        }
        this._updateSelectedText();
        this._triggerChange(value, enabled);
    },
    _updateSelectedText: function _updateSelectedText() {
        if (this._selectedValues.size === 0) {
            this._selectedText.textContent = this._options.placeholder;
            return;
        }
        if (this._options.multiple) {
            var selectedItems = [];
            for (var i = 0; i < this._items.length; i++) {
                var item = this._items[i];
                if (item && this._selectedValues.has(item.value)) {
                    selectedItems.push(item);
                }
            }
            if (selectedItems.length === 0) {
                this._selectedText.textContent = this._options.placeholder;
            } else if (selectedItems.length === 1) {
                this._selectedText.textContent = selectedItems[0].text;
            } else {
                this._selectedText.textContent = selectedItems.length + " items selected";
            }
        } else {
            var selectedItem = null;
            for (var i = 0; i < this._items.length; i++) {
                var item = this._items[i];
                if (item && this._selectedValues.has(item.value)) {
                    selectedItem = item;
                    break;
                }
            }
            this._selectedText.textContent = selectedItem ? selectedItem.text : this._options.placeholder;
        }
    },
    _triggerChange: function _triggerChange(currentValue, enabled) {
        var values = Array.from(this._selectedValues);
        var items = [];
        for (var i = 0; i < this._items.length; i++) {
            var item = this._items[i];
            if (item && this._selectedValues.has(item.value)) {
                items.push(item);
            }
        }
        var detail = {
            values: values,
            items: items,
            current: currentValue,
            enabled: enabled
        };
        this._subscribers.forEach(function(cb) {
            cb({
                type: "selectbox:change",
                detail: detail
            });
        });
    },
    _triggerCustomChange: function _triggerCustomChange(currentValue) {
        var detail = {
            values: [],
            current: currentValue,
            enabled: false
        };
        this._subscribers.forEach(function(cb) {
            cb({
                type: "selectbox:custom",
                detail: detail
            });
        });
    },
    subscribe: function subscribe(callback) {
        var self = this;
        this._subscribers.push(callback);
        return {
            unsubscribe: function unsubscribe() {
                self._subscribers = self._subscribers.filter(function(cb) {
                    return cb !== callback;
                });
            }
        };
    },
    addItem: function addItem(value, text, selected) {
        selected = selected || false;
        var bHasItem = this._items.some(item => item && item.value === value);
        if (bHasItem) {
            var item = this._items.find(item => item && item.value === value);
            if (item) item.selected = selected;
        } else {
            this._items.push({
                value: value,
                text: text,
                selected: selected
            });
        }
        if (selected) {
            if (this._options.multiple) {
                this._selectedValues.add(value);
            } else {
                this._selectedValues.clear();
                this._selectedValues.add(value);
            }
        }
        this._updateSelectedText();
    },
    addItems: function addItems(values, selectedValue) {
        var self = this;
        values.forEach(function(pair, index) {
            var bHasItem = self._items.some(item => item && item.value === pair[0]);
            if (bHasItem) return;
            var isSelected = selectedValue ? pair[0] === selectedValue : index === 0;
            if (isSelected) {
                if (self._options.multiple) {
                    self._selectedValues.add(pair[0]);
                } else {
                    self._selectedValues.clear();
                    self._selectedValues.add(pair[0]);
                }
            }
            self._items.push({
                value: pair[0],
                text: pair[1],
                selected: isSelected
            });
        }, this);
        if (this.isOpen) {
            this._renderOptions();
        }
        this._updateSelectedText();
    },
    addCustomItem: function addCustomItem(value, text) {
        this._customItems.push({
            value: value,
            text: text,
            selected: false
        });
    },
    addSeparator: function addSeparator() {
        this._items.push(null);
    },
    removeItem: function removeItem(value) {
        this._items = this._items.filter(function(item) {
            if (item === null || item.value !== value) {
                return true;
            }
            return false;
        });
        this._customItems = this._customItems.filter(function(item) {
            if (item === null || item.value !== value) {
                return true;
            }
            return false;
        });
        this._selectedValues.delete(value);
        this._updateSelectedText();
    },
    getSelectedValue: function getSelectedValue() {
        if (this._options.multiple) {
            console.error("Method getSelectedValue is only available for single-select boxes.");
            return null;
        } else {
            var values = Array.from(this._selectedValues);
            return values.length > 0 ? values[0] : null;
        }
    },
    getSelectedValues: function getSelectedValues() {
        if (this._options.multiple) {
            return Array.from(this._selectedValues);
        } else {
            var values = Array.from(this._selectedValues);
            return values.length > 0 ? values[0] : null;
        }
    },
    selectItems: function selectItems(values, bSilent) {
        var self = this;
        if (!this._options.multiple && Array.isArray(values)) {
            console.error("Method selectItem is only available for multi-select boxes.");
            return;
        }
        var value = "";
        if (this._options.multiple) {
            var checkMultiOption = function checkMultiOption(value) {
                if (self._optionsContainer) {
                    var option = self._optionsContainer.querySelector('[data-value="' + value + '"]');
                    if (option) {
                        var checkbox = option.querySelector('input[type="checkbox"]');
                        if (checkbox && checkbox instanceof HTMLInputElement) {
                            checkbox.checked = true;
                        }
                        option.classList.add("selectbox-option-selected");
                        option.classList.add("checkbox--checked");
                    }
                }
            };
            if (Array.isArray(values)) {
                for (var i = 0; i < values.length; i++) {
                    value = values[i];
                    if (!this._selectedValues.has(value)) {
                        this._selectedValues.add(value);
                        checkMultiOption(value);
                    }
                }
            } else {
                value = values;
                if (!this._selectedValues.has(value)) {
                    this._selectedValues.add(value);
                    checkMultiOption(value);
                }
            }
        } else if (!Array.isArray(values)) {
            value = values;
            this._selectedValues.clear();
            this._selectedValues.add(value);
            if (this._optionsContainer) {
                var selectedOptions = this._optionsContainer.querySelectorAll('.selectbox-option-selected[data-value="' + value + '"]');
                selectedOptions.forEach(function(option) {
                    option.classList.remove("selectbox-option-selected");
                    option.classList.remove("checkbox--checked");
                });
                var option = this._optionsContainer.querySelector('[data-value="' + value + '"]');
                if (option) {
                    option.classList.add("selectbox-option-selected");
                    option.classList.add("checkbox--checked");
                }
            }
            this._closeDropdown();
        }
        this._updateSelectedText();
        if (bSilent) {
            return;
        }
        this._triggerChange(value, true);
    },
    unselectItems: function unselectItems(values, bSilent) {
        var self = this;
        if (!this._options.multiple) {
            console.error("Method unselectItem is only available for multi-select boxes.");
            return;
        }
        var value = "";
        var uncheckMultiOption = function uncheckMultiOption(value) {
            if (self._optionsContainer) {
                var option = self._optionsContainer.querySelector('[data-value="' + value + '"]');
                if (option) {
                    var checkbox = option.querySelector('input[type="checkbox"]');
                    if (checkbox && checkbox instanceof HTMLInputElement) {
                        checkbox.checked = false;
                    }
                    option.classList.remove("selectbox-option-selected");
                    option.classList.remove("checkbox--checked");
                }
            }
        };
        if (Array.isArray(values)) {
            for (var i = 0; i < values.length; i++) {
                value = values[i];
                if (this._selectedValues.has(value)) {
                    this._selectedValues.delete(value);
                    uncheckMultiOption(value);
                }
            }
        } else {
            value = values;
            if (this._selectedValues.has(value)) {
                this._selectedValues.delete(value);
                uncheckMultiOption(value);
            }
        }
        this._updateSelectedText();
        if (bSilent) {
            return;
        }
        this._triggerChange(value, true);
    },
    disable: function disable() {
        this._select.classList.add("selectbox-disabled");
    },
    enable: function enable() {
        this._select.classList.remove("selectbox-disabled");
    },
    clear: function clear(bSelectFirst) {
        bSelectFirst = bSelectFirst || false;
        this._selectedValues.clear();
        if (bSelectFirst && this._items.length > 0) {
            var firstItem = this._items[0];
            if (firstItem) {
                this._selectedValues.add(firstItem.value);
            }
        }
        this._updateSelectedText();
        this._renderOptions();
    },
    destroy: function destroy() {
        this._subscribers = [];
        try {
            if (this._header && this._boundHandles) {
                this._header.removeEventListener("click", this._boundHandles.toggle);
            }
            if (this.searchInput && this._boundHandles) {
                this.searchInput.removeEventListener("input", this._boundHandles.search);
            }
            if (this._dropdown && this._boundHandles) {
                this._dropdown.removeEventListener("click", this._boundHandles.dropdownClick);
            }
            if (document && this._boundHandles) {
                document.removeEventListener("click", this._boundHandles.close);
            }
            if (this._header && this._boundHandles) {
                this._header.removeEventListener("keydown", this._boundHandles.keydown);
            }
            if (this._dropdown && this._boundHandles) {
                this._dropdown.removeEventListener("keydown", this._boundHandles.keydown);
            }
        } catch (error) {
            console.error(error);
        }
        this._container.innerHTML = "";
        var containerClasses = this._container.className.split(" ");
        var newClasses = [];
        for (var i = 0; i < containerClasses.length; i++) {
            if (containerClasses[i] !== "selectbox-container") {
                newClasses.push(containerClasses[i]);
            }
        }
        this._container.className = newClasses.join(" ");
    }
};

function translate(message) {
    return window.Asc.plugin.tr(message);
}

function CitationDocService(citPrefix, citSuffix, bibPrefix, bibSuffix) {
    this._citPrefixOld = "ZOTERO_CITATION";
    this._bibPrefixOld = "ZOTERO_BIBLIOGRAPHY";
    this._citPrefix = citPrefix;
    this._citSuffix = citSuffix;
    this._bibPrefix = bibPrefix;
    this._bibSuffix = bibSuffix;
    this._repeatTimeout;
    this._formatter = null;
}

CitationDocService.prototype._addAddinField = function(field) {
    return new Promise(function(resolve) {
        window.Asc.plugin.executeMethod("AddAddinField", [ field ], resolve);
    });
};

CitationDocService.prototype.addBibliography = function(text, value) {
    var self = this;
    var supSubPositions = this._removeSuperSubTagsWithPositions(text);
    var field = {
        Value: this._bibPrefix + value + this._bibSuffix,
        Content: supSubPositions.text
    };
    return this._addAddinField(field).then(function() {
        if (!supSubPositions.positions.length) return;
        return self._setSuperSubByPositions(supSubPositions.positions);
    });
};

CitationDocService.prototype.addCitation = function(text, value, notesStyle) {
    var self = this;
    var supSubPositions = this._removeSuperSubTagsWithPositions(text);
    var field = {
        Value: this._citPrefix + " " + this._citSuffix + value,
        Content: supSubPositions.text
    };
    if ("footnotes" === notesStyle) {
        window.Asc.plugin.callCommand(function() {
            var oDocument = Api.GetDocument();
            oDocument.AddFootnote();
        });
    } else if ("endnotes" === notesStyle) {
        window.Asc.plugin.callCommand(function() {
            var oDocument = Api.GetDocument();
            oDocument.AddEndnote();
        });
    }
    return this._addAddinField(field).then(function() {
        if (!supSubPositions.positions.length) return;
        return self._setSuperSubByPositions(supSubPositions.positions);
    });
};

CitationDocService.prototype._getAllAddinFields = function() {
    return new Promise(function(resolve, reject) {
        window.Asc.plugin.executeMethod("GetAllAddinFields", null, resolve);
    });
};

CitationDocService.prototype.getAddinZoteroFields = function() {
    var self = this;
    return new Promise(function(resolve, reject) {
        self._getAllAddinFields().then(function(arrFields) {
            try {
                if (arrFields.length) {
                    arrFields = arrFields.filter(function(field) {
                        return field.Value.indexOf(self._citPrefix) !== -1 || field.Value.indexOf(self._bibPrefix) !== -1 || field.Value.indexOf(self._citPrefixOld) !== -1 || field.Value.indexOf(self._bibPrefixOld) !== -1;
                    });
                }
            } catch (e) {
                reject(e);
            }
            resolve(arrFields);
        });
    });
};

CitationDocService.prototype._removeSuperSubTagsWithPositions = function(escapedHtmlText) {
    var positions = [];
    var currentIndex = 0;
    var result = "";
    var tempResult = escapedHtmlText;
    tempResult = tempResult.replace(/<sup\b[^>]*>([^<]*)<\/sup>/gi, function(match, content, offset) {
        var start = offset + currentIndex;
        var end = start + content.length;
        positions.push({
            type: "sup",
            content: content,
            start: start,
            end: end,
            originalMatch: match
        });
        currentIndex += content.length - match.length;
        return content;
    });
    currentIndex = 0;
    result = tempResult;
    tempResult = tempResult.replace(/<sub\b[^>]*>([^<]*)<\/sub>/gi, function(match, content, offset) {
        var start = offset + currentIndex;
        var end = start + content.length;
        positions.push({
            type: "sub",
            content: content,
            start: start,
            end: end,
            originalMatch: match
        });
        currentIndex += content.length - match.length;
        return content;
    });
    result = tempResult;
    return {
        text: result,
        positions: positions.sort(function(a, b) {
            return a.start - b.start;
        })
    };
};

CitationDocService.prototype.saveAsText = function() {
    return this.getAddinZoteroFields().then(function(arrFields) {
        var count = arrFields.length;
        if (!count) {
            window.Asc.plugin.executeCommand("close", "");
            return false;
        }
        return new Promise(function(resolve) {
            arrFields.forEach(function(field) {
                window.Asc.plugin.executeMethod("RemoveFieldWrapper", [ field.FieldId ], function() {
                    count--;
                    if (!count) {
                        resolve(true);
                        window.Asc.plugin.executeCommand("close", "");
                    }
                });
            });
        });
    });
};

CitationDocService.prototype._setSuperSubByPositions = function(positions) {
    return new Promise(function(resolve) {
        var isCalc = true;
        var isClose = false;
        Asc.scope.positions = positions;
        Asc.plugin.callCommand(function() {
            var doc = Api.GetDocument();
            var run = doc.GetCurrentRun();
            Asc.scope.positions.forEach(function(pos) {
                var range = run.GetRange(pos.start, pos.end);
                if ("sup" === pos.type) {
                    range.SetVertAlign("superscript");
                } else {
                    range.SetVertAlign("subscript");
                }
            });
        }, isClose, isCalc, resolve);
    });
};

CitationDocService.prototype.updateAddinFields = function(fields) {
    return new Promise(function(resolve) {
        window.Asc.plugin.executeMethod("UpdateAddinFields", [ fields ], resolve);
    });
};

function CitationItemData(id) {
    if (typeof id !== "string" && typeof id !== "number") {
        throw new Error("CitationItemData: id is required");
    }
    this._id = id;
    this._type = undefined;
    this._citationKey = undefined;
    this._categories = new Array;
    this._language = undefined;
    this._journalAbbreviation = undefined;
    this._shortTitle = undefined;
    this._author = new Array;
    this._chair = new Array;
    this._collectionEditor = new Array;
    this._compiler = new Array;
    this._composer = new Array;
    this._containerAuthor = new Array;
    this._contributor = new Array;
    this._curator = new Array;
    this._director = new Array;
    this._editor = new Array;
    this._editorialDirector = new Array;
    this._executiveProducer = new Array;
    this._guest = new Array;
    this._host = new Array;
    this._illustrator = new Array;
    this._narrator = new Array;
    this._organizer = new Array;
    this._originalAuthor = new Array;
    this._performer = new Array;
    this._producer = new Array;
    this._recipient = new Array;
    this._reviewedAuthor = new Array;
    this._scriptwriter = new Array;
    this._seriesCreator = new Array;
    this._translator = new Array;
    this._accessed = {};
    this._container = {};
    this._eventDate = {};
    this._issued = {};
    this._originalDate = {};
    this._submitted = {};
    this._abstract = undefined;
    this._annote = undefined;
    this._archive = undefined;
    this._archiveCollection = undefined;
    this._archiveLocation = undefined;
    this._archivePlace = undefined;
    this._authority = undefined;
    this._callNumber = undefined;
    this._chapterNumber = undefined;
    this._citationNumber = undefined;
    this._citationLabel = undefined;
    this._collectionNumber = undefined;
    this._collectionTitle = undefined;
    this._containerTitle = undefined;
    this._containerTitleShort = undefined;
    this._dimensions = undefined;
    this._DOI = undefined;
    this._edition = undefined;
    this._event = undefined;
    this._eventTitle = undefined;
    this._eventPlace = undefined;
    this._firstReferenceNoteNumber = undefined;
    this._genre = undefined;
    this._ISBN = undefined;
    this._ISSN = undefined;
    this._issue = undefined;
    this._jurisdiction = undefined;
    this._keyword = undefined;
    this._locator = undefined;
    this._medium = undefined;
    this._note = undefined;
    this._number = undefined;
    this._numberOfPages = undefined;
    this._numberOfVolumes = undefined;
    this._originalPublisher = undefined;
    this._originalPublisherPlace = undefined;
    this._originalTitle = undefined;
    this._page = undefined;
    this._part = undefined;
    this._partTitle = undefined;
    this._pageFirst = undefined;
    this._PMCID = undefined;
    this._PMID = undefined;
    this._printing = undefined;
    this._publisher = undefined;
    this._publisherPlace = undefined;
    this._references = undefined;
    this._reviewedGenre = undefined;
    this._reviewedTitle = undefined;
    this._scale = undefined;
    this._section = undefined;
    this._source = undefined;
    this._status = undefined;
    this._title = undefined;
    this._titleShort = undefined;
    this._URL = undefined;
    this._version = undefined;
    this._volume = undefined;
    this._volumeTitle = undefined;
    this._volumeTitleShort = undefined;
    this._yearSuffix = undefined;
    this._custom = {};
    this.schema = "https://raw.githubusercontent.com/citation-style-language/schema/master/schemas/input/csl-data.json#/items";
}

CitationItemData.prototype._addCustomProperty = function(key, value) {
    this._custom[key] = value;
    return this;
};

CitationItemData.prototype.getCustomProperty = function(key) {
    if (Object.hasOwnProperty.call(this._custom, key)) return this._custom[key];
    return null;
};

CitationItemData.prototype.fillFromObject = function(itemDataObject) {
    if (Object.hasOwnProperty.call(itemDataObject, "type")) {
        this._type = itemDataObject.type;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "categories")) {
        this._categories = itemDataObject.categories;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "citation-key")) {
        this._citationKey = itemDataObject["citation-key"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "language")) {
        this._language = itemDataObject.language;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "journalAbbreviation")) {
        this._journalAbbreviation = itemDataObject.journalAbbreviation;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "shortTitle")) {
        this._shortTitle = itemDataObject.shortTitle;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "author")) {
        this._author = itemDataObject.author;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "chair")) {
        this._chair = itemDataObject.chair;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "collection-editor")) {
        this._collectionEditor = itemDataObject["collection-editor"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "compiler")) {
        this._compiler = itemDataObject.compiler;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "composer")) {
        this._composer = itemDataObject.composer;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "container-author")) {
        this._containerAuthor = itemDataObject["container-author"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "contributor")) {
        this._contributor = itemDataObject.contributor;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "curator")) {
        this._curator = itemDataObject.curator;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "director")) {
        this._director = itemDataObject.director;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "editorial-director")) {
        this._editorialDirector = itemDataObject["editorial-director"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "editor")) {
        this._editor = itemDataObject.editor;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "executive-producer")) {
        this._executiveProducer = itemDataObject["executive-producer"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "guest")) {
        this._guest = itemDataObject.guest;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "host")) {
        this._host = itemDataObject.host;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "illustrator")) {
        this._illustrator = itemDataObject.illustrator;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "narrator")) {
        this._narrator = itemDataObject.narrator;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "organizer")) {
        this._organizer = itemDataObject.organizer;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "original-author")) {
        this._originalAuthor = itemDataObject["original-author"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "performer")) {
        this._performer = itemDataObject.performer;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "producer")) {
        this._producer = itemDataObject.producer;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "recipient")) {
        this._recipient = itemDataObject.recipient;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "reviewed-author")) {
        this._reviewedAuthor = itemDataObject["reviewed-author"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "script-writer")) {
        this._scriptWriter = itemDataObject["script-writer"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "series-creator")) {
        this._seriesCreator = itemDataObject["series-creator"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "translator")) {
        this._translator = itemDataObject.translator;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "accessed")) {
        this._accessed = itemDataObject.accessed;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "container")) {
        this._container = itemDataObject.container;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "event-date")) {
        this._eventDate = itemDataObject["event-date"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "issued")) {
        this._issued = itemDataObject.issued;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "original-date")) {
        this._originalDate = itemDataObject["original-date"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "submitted")) {
        this._submitted = itemDataObject.submitted;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "abstract")) {
        this._abstract = itemDataObject.abstract;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "annote")) {
        this._annote = itemDataObject.annote;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "archive")) {
        this._archive = itemDataObject.archive;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "archive_collection")) {
        this._archiveCollection = itemDataObject["archive_collection"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "archive_location")) {
        this._archiveLocation = itemDataObject["archive_location"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "archive-place")) {
        this._archivePlace = itemDataObject["archive-place"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "authority")) {
        this._authority = itemDataObject.authority;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "call-number")) {
        this._callNumber = itemDataObject["call-number"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "chapter-number")) {
        this._chapterNumber = itemDataObject["chapter-number"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "citation-number")) {
        this._citationNumber = itemDataObject["citation-number"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "citation-label")) {
        this._citationLabel = itemDataObject["citation-label"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "collection-number")) {
        this._collectionNumber = itemDataObject["collection-number"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "collection-title")) {
        this._collectionTitle = itemDataObject["collection-title"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "container-title")) {
        this._containerTitle = itemDataObject["container-title"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "container-title-short")) {
        this._containerTitleShort = itemDataObject["container-title-short"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "dimensions")) {
        this._dimensions = itemDataObject.dimensions;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "DOI")) {
        this._DOI = itemDataObject.DOI;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "edition")) {
        this._edition = itemDataObject.edition;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "event")) {
        this._event = itemDataObject.event;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "event-title")) {
        this._eventTitle = itemDataObject["event-title"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "event-place")) {
        this._eventPlace = itemDataObject["event-place"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "first-reference-note-number")) {
        this._firstReferenceNoteNumber = itemDataObject["first-reference-note-number"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "genre")) {
        this._genre = itemDataObject.genre;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "ISBN")) {
        this._ISBN = itemDataObject.ISBN;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "ISSN")) {
        this._ISSN = itemDataObject.ISSN;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "issue")) {
        this._issue = itemDataObject.issue;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "jurisdiction")) {
        this._jurisdiction = itemDataObject.jurisdiction;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "keyword")) {
        this._keyword = itemDataObject.keyword;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "locator")) {
        this._locator = itemDataObject.locator;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "medium")) {
        this._medium = itemDataObject.medium;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "note")) {
        this._note = itemDataObject.note;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "number")) {
        this._number = itemDataObject.number;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "number-of-pages")) {
        this._numberOfPages = itemDataObject["number-of-pages"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "number-of-volumes")) {
        this._numberOfVolumes = itemDataObject["number-of-volumes"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "original-publisher")) {
        this._originalPublisher = itemDataObject["original-publisher"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "original-publisher-place")) {
        this._originalPublisherPlace = itemDataObject["original-publisher-place"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "original-title")) {
        this._originalTitle = itemDataObject["original-title"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "page")) {
        this._page = itemDataObject.page;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "page-first")) {
        this._pageFirst = itemDataObject["page-first"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "part")) {
        this._part = itemDataObject.part;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "part-title")) {
        this._partTitle = itemDataObject["part-title"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "PMCID")) {
        this._PMCID = itemDataObject.PMCID;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "PMID")) {
        this._PMID = itemDataObject.PMID;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "printing")) {
        this._printing = itemDataObject.printing;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "publisher")) {
        this._publisher = itemDataObject.publisher;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "publisher-place")) {
        this._publisherPlace = itemDataObject["publisher-place"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "references")) {
        this._references = itemDataObject.references;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "reviewed-genre")) {
        this._reviewedGenre = itemDataObject["reviewed-genre"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "reviewed-title")) {
        this._reviewedTitle = itemDataObject["reviewed-title"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "scale")) {
        this._scale = itemDataObject.scale;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "section")) {
        this._section = itemDataObject.section;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "source")) {
        this._source = itemDataObject.source;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "status")) {
        this._status = itemDataObject.status;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "title")) {
        this._title = itemDataObject.title;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "title-short")) {
        this._titleShort = itemDataObject["title-short"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "URL")) {
        this._URL = itemDataObject.URL;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "version")) {
        this._version = itemDataObject.version;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "volume")) {
        this._volume = itemDataObject.volume;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "volume-title")) {
        this._volumeTitle = itemDataObject["volume-title"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "volume-title-short")) {
        this._volumeTitleShort = itemDataObject["volume-title-short"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "year-suffix")) {
        this._yearSuffix = itemDataObject["year-suffix"];
    }
    if (Object.hasOwnProperty.call(itemDataObject, "custom")) {
        this._custom = itemDataObject.custom;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "userID")) {
        this._addCustomProperty("userID", itemDataObject.userID);
    }
    if (Object.hasOwnProperty.call(itemDataObject, "groupID")) {
        this._addCustomProperty("groupID", itemDataObject.groupID);
    }
    if (Object.hasOwnProperty.call(itemDataObject, "creators")) {
        var self = this;
        itemDataObject.creators.forEach(function(creator) {
            var author = {};
            if (creator.firstName) {
                author.given = creator.firstName;
            }
            if (creator.lastName) {
                author.family = creator.lastName;
            }
            var bHasAuthor = self._author.some(function(a) {
                if (a.family !== author.family && (a.family || author.family)) {
                    return false;
                }
                if (a.given !== author.given && (a.given || author.given)) {
                    return false;
                }
                return true;
            });
            if (bHasAuthor) {
                return;
            }
            self._author.push(author);
        }, this);
    }
    if (Object.hasOwnProperty.call(itemDataObject, "libraryCatalog")) {
        this._source = itemDataObject.libraryCatalog;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "place")) {
        this._eventPlace = itemDataObject.place;
        this._publisherPlace = itemDataObject.place;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "numberOfVolumes")) {
        this._numberOfVolumes = itemDataObject.numberOfVolumes;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "callNumber")) {
        this._callNumber = itemDataObject.callNumber;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "seriesNumber")) {
        this._collectionNumber = itemDataObject.seriesNumber;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "series")) {
        this._collectionTitle = itemDataObject.series;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "bookTitle")) {
        this._containerTitle = itemDataObject.bookTitle;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "extra")) {
        this._note = itemDataObject.extra;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "rights")) {
        this._license = itemDataObject.rights;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "archiveLocation")) {
        this._archiveLocation = itemDataObject.archiveLocation;
    }
    if (Object.hasOwnProperty.call(itemDataObject, "abstractNote")) {
        this._abstract = itemDataObject.abstractNote;
    }
};

CitationItemData.prototype.getTitle = function() {
    return this._title;
};

CitationItemData.prototype.getType = function() {
    return this._type;
};

CitationItemData.prototype.setType = function(type) {
    this._type = type;
    return this;
};

CitationItemData.prototype.setCitationKey = function(key) {
    this._citationKey = key;
    return this;
};

CitationItemData.prototype.setCategories = function(categories) {
    this._categories = categories;
    return this;
};

CitationItemData.prototype.setLanguage = function(language) {
    this._language = language;
    return this;
};

CitationItemData.prototype.setJournalAbbreviation = function(journalAbbreviation) {
    this._journalAbbreviation = journalAbbreviation;
    return this;
};

CitationItemData.prototype.setShortTitle = function(shortTitle) {
    this._shortTitle = shortTitle;
    return this;
};

CitationItemData.prototype.setAuthor = function(author) {
    this._author = Array.isArray(author) ? author : [ author ];
    return this;
};

CitationItemData.prototype.setChair = function(chair) {
    this._chair = Array.isArray(chair) ? chair : [ chair ];
    return this;
};

CitationItemData.prototype.setCollectionEditor = function(collectionEditor) {
    this._collectionEditor = Array.isArray(collectionEditor) ? collectionEditor : [ collectionEditor ];
    return this;
};

CitationItemData.prototype.setCompiler = function(compiler) {
    this._compiler = Array.isArray(compiler) ? compiler : [ compiler ];
    return this;
};

CitationItemData.prototype.setComposer = function(composer) {
    this._composer = Array.isArray(composer) ? composer : [ composer ];
    return this;
};

CitationItemData.prototype.setContainerAuthor = function(containerAuthor) {
    this._containerAuthor = Array.isArray(containerAuthor) ? containerAuthor : [ containerAuthor ];
    return this;
};

CitationItemData.prototype.setContributor = function(contributor) {
    this._contributor = Array.isArray(contributor) ? contributor : [ contributor ];
    return this;
};

CitationItemData.prototype.setCurator = function(curator) {
    this._curator = Array.isArray(curator) ? curator : [ curator ];
    return this;
};

CitationItemData.prototype.setDirector = function(director) {
    this._director = Array.isArray(director) ? director : [ director ];
    return this;
};

CitationItemData.prototype.setEditor = function(editor) {
    this._editor = Array.isArray(editor) ? editor : [ editor ];
    return this;
};

CitationItemData.prototype.setEditorialDirector = function(editorialDirector) {
    this._editorialDirector = Array.isArray(editorialDirector) ? editorialDirector : [ editorialDirector ];
    return this;
};

CitationItemData.prototype.setExecutiveProducer = function(executiveProducer) {
    this._executiveProducer = Array.isArray(executiveProducer) ? executiveProducer : [ executiveProducer ];
    return this;
};

CitationItemData.prototype.setGuest = function(guest) {
    this._guest = Array.isArray(guest) ? guest : [ guest ];
    return this;
};

CitationItemData.prototype.setHost = function(host) {
    this._host = Array.isArray(host) ? host : [ host ];
    return this;
};

CitationItemData.prototype.setIllustrator = function(illustrator) {
    this._illustrator = Array.isArray(illustrator) ? illustrator : [ illustrator ];
    return this;
};

CitationItemData.prototype.setNarrator = function(narrator) {
    this._narrator = Array.isArray(narrator) ? narrator : [ narrator ];
    return this;
};

CitationItemData.prototype.setOrganizer = function(organizer) {
    this._organizer = Array.isArray(organizer) ? organizer : [ organizer ];
    return this;
};

CitationItemData.prototype.setOriginalAuthor = function(originalAuthor) {
    this._originalAuthor = Array.isArray(originalAuthor) ? originalAuthor : [ originalAuthor ];
    return this;
};

CitationItemData.prototype.setPerformer = function(performer) {
    this._performer = Array.isArray(performer) ? performer : [ performer ];
    return this;
};

CitationItemData.prototype.setProducer = function(producer) {
    this._producer = Array.isArray(producer) ? producer : [ producer ];
    return this;
};

CitationItemData.prototype.setRecipient = function(recipient) {
    this._recipient = Array.isArray(recipient) ? recipient : [ recipient ];
    return this;
};

CitationItemData.prototype.setReviewedAuthor = function(reviewedAuthor) {
    this._reviewedAuthor = Array.isArray(reviewedAuthor) ? reviewedAuthor : [ reviewedAuthor ];
    return this;
};

CitationItemData.prototype.setScriptwriter = function(scriptwriter) {
    this._scriptwriter = Array.isArray(scriptwriter) ? scriptwriter : [ scriptwriter ];
    return this;
};

CitationItemData.prototype.setSeriesCreator = function(seriesCreator) {
    this._seriesCreator = Array.isArray(seriesCreator) ? seriesCreator : [ seriesCreator ];
    return this;
};

CitationItemData.prototype.setTranslator = function(translator) {
    this._translator = Array.isArray(translator) ? translator : [ translator ];
    return this;
};

CitationItemData.prototype.setAccessed = function(accessed) {
    this._accessed = accessed || {};
    return this;
};

CitationItemData.prototype.setContainer = function(container) {
    this._container = container || {};
    return this;
};

CitationItemData.prototype.setEventDate = function(eventDate) {
    this._eventDate = eventDate || {};
    return this;
};

CitationItemData.prototype.setIssued = function(issued) {
    this._issued = issued || {};
    return this;
};

CitationItemData.prototype.setOriginalDate = function(originalDate) {
    this._originalDate = originalDate || {};
    return this;
};

CitationItemData.prototype.setSubmitted = function(submitted) {
    this._submitted = submitted || {};
    return this;
};

CitationItemData.prototype.setAbstract = function(abstract) {
    this._abstract = abstract;
    return this;
};

CitationItemData.prototype.setAnnote = function(annote) {
    this._annote = annote;
    return this;
};

CitationItemData.prototype.setArchive = function(archive) {
    this._archive = archive;
    return this;
};

CitationItemData.prototype.setArchiveCollection = function(archiveCollection) {
    this._archiveCollection = archiveCollection;
    return this;
};

CitationItemData.prototype.setArchiveLocation = function(archiveLocation) {
    this._archiveLocation = archiveLocation;
    return this;
};

CitationItemData.prototype.setArchivePlace = function(archivePlace) {
    this._archivePlace = archivePlace;
    return this;
};

CitationItemData.prototype.setAuthority = function(authority) {
    this._authority = authority;
    return this;
};

CitationItemData.prototype.setCallNumber = function(callNumber) {
    this._callNumber = callNumber;
    return this;
};

CitationItemData.prototype.setChapterNumber = function(chapterNumber) {
    this._chapterNumber = chapterNumber;
    return this;
};

CitationItemData.prototype.setCitationNumber = function(citationNumber) {
    this._citationNumber = citationNumber;
    return this;
};

CitationItemData.prototype.setCitationLabel = function(citationLabel) {
    this._citationLabel = citationLabel;
    return this;
};

CitationItemData.prototype.setCollectionNumber = function(collectionNumber) {
    this._collectionNumber = collectionNumber;
    return this;
};

CitationItemData.prototype.setCollectionTitle = function(collectionTitle) {
    this._collectionTitle = collectionTitle;
    return this;
};

CitationItemData.prototype.setContainerTitle = function(containerTitle) {
    this._containerTitle = containerTitle;
    return this;
};

CitationItemData.prototype.setContainerTitleShort = function(containerTitleShort) {
    this._containerTitleShort = containerTitleShort;
    return this;
};

CitationItemData.prototype.setDimensions = function(dimensions) {
    this._dimensions = dimensions;
    return this;
};

CitationItemData.prototype.setDOI = function(DOI) {
    this._DOI = DOI;
    return this;
};

CitationItemData.prototype.setEdition = function(edition) {
    this._edition = edition;
    return this;
};

CitationItemData.prototype.setEvent = function(event) {
    this._event = event;
    return this;
};

CitationItemData.prototype.setEventTitle = function(eventTitle) {
    this._eventTitle = eventTitle;
    return this;
};

CitationItemData.prototype.setEventPlace = function(eventPlace) {
    this._eventPlace = eventPlace;
    return this;
};

CitationItemData.prototype.setFirstReferenceNoteNumber = function(firstReferenceNoteNumber) {
    this._firstReferenceNoteNumber = firstReferenceNoteNumber;
    return this;
};

CitationItemData.prototype.setGenre = function(genre) {
    this._genre = genre;
    return this;
};

CitationItemData.prototype.setISBN = function(ISBN) {
    this._ISBN = ISBN;
    return this;
};

CitationItemData.prototype.setISSN = function(ISSN) {
    this._ISSN = ISSN;
    return this;
};

CitationItemData.prototype.setIssue = function(issue) {
    this._issue = issue;
    return this;
};

CitationItemData.prototype.setJurisdiction = function(jurisdiction) {
    this._jurisdiction = jurisdiction;
    return this;
};

CitationItemData.prototype.setKeyword = function(keyword) {
    this._keyword = keyword;
    return this;
};

CitationItemData.prototype.setLocator = function(locator) {
    this._locator = locator;
    return this;
};

CitationItemData.prototype.setMedium = function(medium) {
    this._medium = medium;
    return this;
};

CitationItemData.prototype.setNote = function(note) {
    this._note = note;
    return this;
};

CitationItemData.prototype.setNumber = function(number) {
    this._number = number;
    return this;
};

CitationItemData.prototype.setNumberOfPages = function(numberOfPages) {
    this._numberOfPages = numberOfPages;
    return this;
};

CitationItemData.prototype.setNumberOfVolumes = function(numberOfVolumes) {
    this._numberOfVolumes = numberOfVolumes;
    return this;
};

CitationItemData.prototype.setOriginalPublisher = function(originalPublisher) {
    this._originalPublisher = originalPublisher;
    return this;
};

CitationItemData.prototype.setOriginalPublisherPlace = function(originalPublisherPlace) {
    this._originalPublisherPlace = originalPublisherPlace;
    return this;
};

CitationItemData.prototype.setOriginalTitle = function(originalTitle) {
    this._originalTitle = originalTitle;
    return this;
};

CitationItemData.prototype.setPage = function(page) {
    this._page = page;
    return this;
};

CitationItemData.prototype.setPageFirst = function(pageFirst) {
    this._pageFirst = pageFirst;
    return this;
};

CitationItemData.prototype.setPart = function(part) {
    this._part = part;
    return this;
};

CitationItemData.prototype.setPartTitle = function(partTitle) {
    this._partTitle = partTitle;
    return this;
};

CitationItemData.prototype.setPMCID = function(PMCID) {
    this._PMCID = PMCID;
    return this;
};

CitationItemData.prototype.setPMID = function(PMID) {
    this._PMID = PMID;
    return this;
};

CitationItemData.prototype.setPrinting = function(printing) {
    this._printing = printing;
    return this;
};

CitationItemData.prototype.setPublisher = function(publisher) {
    this._publisher = publisher;
    return this;
};

CitationItemData.prototype.setPublisherPlace = function(publisherPlace) {
    this._publisherPlace = publisherPlace;
    return this;
};

CitationItemData.prototype.setReferences = function(references) {
    this._references = references;
    return this;
};

CitationItemData.prototype.setReviewedGenre = function(reviewedGenre) {
    this._reviewedGenre = reviewedGenre;
    return this;
};

CitationItemData.prototype.setReviewedTitle = function(reviewedTitle) {
    this._reviewedTitle = reviewedTitle;
    return this;
};

CitationItemData.prototype.setScale = function(scale) {
    this._scale = scale;
    return this;
};

CitationItemData.prototype.setSection = function(section) {
    this._section = section;
    return this;
};

CitationItemData.prototype.setSource = function(source) {
    this._source = source;
    return this;
};

CitationItemData.prototype.setStatus = function(status) {
    this._status = status;
    return this;
};

CitationItemData.prototype.setTitle = function(title) {
    this._title = title;
    return this;
};

CitationItemData.prototype.setTitleShort = function(titleShort) {
    this._titleShort = titleShort;
    return this;
};

CitationItemData.prototype.setURL = function(URL) {
    this._URL = URL;
    return this;
};

CitationItemData.prototype.setVersion = function(version) {
    this._version = version;
    return this;
};

CitationItemData.prototype.setVolume = function(volume) {
    this._volume = volume;
    return this;
};

CitationItemData.prototype.setVolumeTitle = function(volumeTitle) {
    this._volumeTitle = volumeTitle;
    return this;
};

CitationItemData.prototype.setVolumeTitleShort = function(volumeTitleShort) {
    this._volumeTitleShort = volumeTitleShort;
    return this;
};

CitationItemData.prototype.setYearSuffix = function(yearSuffix) {
    this._yearSuffix = yearSuffix;
    return this;
};

CitationItemData.prototype.setCustom = function(custom) {
    this._custom = Object.assign(this._custom, custom);
    return this;
};

CitationItemData.prototype.toJSON = function() {
    var result = {};
    result.id = this._id;
    if (this._type !== undefined && this._type !== "") result.type = this._type;
    if (this._citationKey !== undefined && this._citationKey !== "") result["citation-key"] = this._citationKey;
    if (this._categories.length > 0) result.categories = this._categories;
    if (this._language !== undefined && this._language !== "") result.language = this._language;
    if (this._journalAbbreviation !== undefined && this._journalAbbreviation !== "") result.journalAbbreviation = this._journalAbbreviation;
    if (this._shortTitle !== undefined && this._shortTitle !== "") {
        result.shortTitle = this._shortTitle;
        if (this._titleShort === undefined) result["title-short"] = this._shortTitle;
    }
    if (this._author.length > 0) result.author = this._author;
    if (this._chair.length > 0) result.chair = this._chair;
    if (this._collectionEditor.length > 0) result["collection-editor"] = this._collectionEditor;
    if (this._compiler.length > 0) result.compiler = this._compiler;
    if (this._composer.length > 0) result.composer = this._composer;
    if (this._containerAuthor.length > 0) result["container-author"] = this._containerAuthor;
    if (this._contributor.length > 0) result.contributor = this._contributor;
    if (this._curator.length > 0) result.curator = this._curator;
    if (this._director.length > 0) result.director = this._director;
    if (this._editor.length > 0) result.editor = this._editor;
    if (this._editorialDirector.length > 0) result["editorial-director"] = this._editorialDirector;
    if (this._executiveProducer.length > 0) result["executive-producer"] = this._executiveProducer;
    if (this._guest.length > 0) result.guest = this._guest;
    if (this._host.length > 0) result.host = this._host;
    if (this._illustrator.length > 0) result.illustrator = this._illustrator;
    if (this._narrator.length > 0) result.narrator = this._narrator;
    if (this._organizer.length > 0) result.organizer = this._organizer;
    if (this._originalAuthor.length > 0) result["original-author"] = this._originalAuthor;
    if (this._performer.length > 0) result.performer = this._performer;
    if (this._producer.length > 0) result.producer = this._producer;
    if (this._recipient.length > 0) result.recipient = this._recipient;
    if (this._reviewedAuthor.length > 0) result["reviewed-author"] = this._reviewedAuthor;
    if (this._scriptwriter.length > 0) result["script-writer"] = this._scriptwriter;
    if (this._seriesCreator.length > 0) result["series-creator"] = this._seriesCreator;
    if (this._translator.length > 0) result.translator = this._translator;
    if (Object.keys(this._accessed).length > 0) result.accessed = this._accessed;
    if (Object.keys(this._container).length > 0) result.container = this._container;
    if (Object.keys(this._eventDate).length > 0) result["event-date"] = this._eventDate;
    if (Object.keys(this._issued).length > 0) result.issued = this._issued;
    if (Object.keys(this._originalDate).length > 0) result["original-date"] = this._originalDate;
    if (Object.keys(this._submitted).length > 0) result.submitted = this._submitted;
    if (this._abstract !== undefined && this._abstract !== "") result.abstract = this._abstract;
    if (this._annote !== undefined && this._annote !== "") result.annote = this._annote;
    if (this._archive !== undefined && this._archive !== "") result.archive = this._archive;
    if (this._archiveCollection !== undefined && this._archiveCollection !== "") result["archive_collection"] = this._archiveCollection;
    if (this._archiveLocation !== undefined && this._archiveLocation !== "") result["archive_location"] = this._archiveLocation;
    if (this._archivePlace !== undefined && this._archivePlace !== "") result["archive-place"] = this._archivePlace;
    if (this._authority !== undefined && this._authority !== "") result.authority = this._authority;
    if (this._callNumber !== undefined && this._callNumber !== "") result["call-number"] = this._callNumber;
    if (this._chapterNumber !== undefined && this._chapterNumber !== "") result["chapter-number"] = this._chapterNumber;
    if (this._citationNumber !== undefined && this._citationNumber !== "") result["citation-number"] = this._citationNumber;
    if (this._citationLabel !== undefined && this._citationLabel !== "") result["citation-label"] = this._citationLabel;
    if (this._collectionNumber !== undefined && this._collectionNumber !== "") result["collection-number"] = this._collectionNumber;
    if (this._collectionTitle !== undefined && this._collectionTitle !== "") result["collection-title"] = this._collectionTitle;
    if (this._containerTitle !== undefined && this._containerTitle !== "") result["container-title"] = this._containerTitle;
    if (this._containerTitleShort !== undefined && this._containerTitleShort !== "") result["container-title-short"] = this._containerTitleShort;
    if (this._dimensions !== undefined && this._dimensions !== "") result.dimensions = this._dimensions;
    if (this._DOI !== undefined && this._DOI !== "") result.DOI = this._DOI;
    if (this._edition !== undefined && this._edition !== "") result.edition = this._edition;
    if (this._event !== undefined && this._event !== "") result.event = this._event;
    if (this._eventTitle !== undefined && this._eventTitle !== "") result["event-title"] = this._eventTitle;
    if (this._eventPlace !== undefined && this._eventPlace !== "") result["event-place"] = this._eventPlace;
    if (this._firstReferenceNoteNumber !== undefined && this._firstReferenceNoteNumber !== "") result["first-reference-note-number"] = this._firstReferenceNoteNumber;
    if (this._genre !== undefined && this._genre !== "") result.genre = this._genre;
    if (this._ISBN !== undefined && this._ISBN !== "") result.ISBN = this._ISBN;
    if (this._ISSN !== undefined && this._ISSN !== "") result.ISSN = this._ISSN;
    if (this._issue !== undefined && this._issue !== "") result.issue = this._issue;
    if (this._jurisdiction !== undefined && this._jurisdiction !== "") result.jurisdiction = this._jurisdiction;
    if (this._keyword !== undefined && this._keyword !== "") result.keyword = this._keyword;
    if (this._locator !== undefined && this._locator !== "") result.locator = this._locator;
    if (this._medium !== undefined && this._medium !== "") result.medium = this._medium;
    if (this._note !== undefined && this._note !== "") result.note = this._note;
    if (this._number !== undefined && this._number !== "") result.number = this._number;
    if (this._numberOfPages !== undefined && this._numberOfPages !== "") result["number-of-pages"] = this._numberOfPages;
    if (this._numberOfVolumes !== undefined && this._numberOfVolumes !== "") result["number-of-volumes"] = this._numberOfVolumes;
    if (this._originalPublisher !== undefined && this._originalPublisher !== "") result["original-publisher"] = this._originalPublisher;
    if (this._originalPublisherPlace !== undefined && this._originalPublisherPlace !== "") result["original-publisher-place"] = this._originalPublisherPlace;
    if (this._originalTitle !== undefined && this._originalTitle !== "") result["original-title"] = this._originalTitle;
    if (this._page !== undefined && this._page !== "") result.page = this._page;
    if (this._pageFirst !== undefined && this._pageFirst !== "") result["page-first"] = this._pageFirst;
    if (this._part !== undefined && this._part !== "") result.part = this._part;
    if (this._partTitle !== undefined && this._partTitle !== "") result["part-title"] = this._partTitle;
    if (this._PMCID !== undefined && this._PMCID !== "") result.PMCID = this._PMCID;
    if (this._PMID !== undefined && this._PMID !== "") result.PMID = this._PMID;
    if (this._printing !== undefined && this._printing !== "") result.printing = this._printing;
    if (this._publisher !== undefined && this._publisher !== "") result.publisher = this._publisher;
    if (this._publisherPlace !== undefined && this._publisherPlace !== "") result["publisher-place"] = this._publisherPlace;
    if (this._references !== undefined && this._references !== "") result.references = this._references;
    if (this._reviewedGenre !== undefined && this._reviewedGenre !== "") result["reviewed-genre"] = this._reviewedGenre;
    if (this._reviewedTitle !== undefined && this._reviewedTitle !== "") result["reviewed-title"] = this._reviewedTitle;
    if (this._scale !== undefined && this._scale !== "") result.scale = this._scale;
    if (this._section !== undefined && this._section !== "") result.section = this._section;
    if (this._source !== undefined && this._source !== "") result.source = this._source;
    if (this._status !== undefined && this._status !== "") result.status = this._status;
    if (this._title !== undefined && this._title !== "") result.title = this._title;
    if (this._titleShort !== undefined && this._titleShort !== "") result["title-short"] = this._titleShort;
    if (this._URL !== undefined && this._URL !== "") result.URL = this._URL;
    if (this._version !== undefined && this._version !== "") result.version = this._version;
    if (this._volume !== undefined && this._volume !== "") result.volume = this._volume;
    if (this._volumeTitle !== undefined && this._volumeTitle !== "") result["volume-title"] = this._volumeTitle;
    if (this._volumeTitleShort !== undefined && this._volumeTitleShort !== "") result["volume-title-short"] = this._volumeTitleShort;
    if (this._yearSuffix !== undefined && this._yearSuffix !== "") result["year-suffix"] = this._yearSuffix;
    if (Object.keys(this._custom).length !== 0) result.custom = this._custom;
    if (this._license !== undefined && this._license !== "") result.license = this._license;
    return result;
};

function CitationItem(id) {
    if (typeof id !== "string" && typeof id !== "number") {
        throw new Error("CitationItem: id is required");
    }
    this.id = id;
    this._itemData = new CitationItemData(id);
    this._prefix = undefined;
    this._suffix = undefined;
    this._locator = undefined;
    this._label = undefined;
    this._suppressAuthor = undefined;
    this._authorOnly = undefined;
    this._uris = new Array;
}

CitationItem.prototype.fillFromObject = function(itemObject) {
    var self = this;
    if (Object.hasOwnProperty.call(itemObject, "version") && Object.hasOwnProperty.call(itemObject, "library")) {
        this._itemData.fillFromObject(itemObject.data);
        if (Object.hasOwnProperty.call(itemObject, "links")) {
            if (Object.hasOwnProperty.call(itemObject.links, "self")) {
                this.addUri(itemObject.links.self.href);
            }
            if (Object.hasOwnProperty.call(itemObject.links, "alternate")) {
                this.addUri(itemObject.links.alternate.href);
            }
        }
    } else if (Object.hasOwnProperty.call(itemObject, "itemData")) {
        this._itemData.fillFromObject(itemObject.itemData);
    } else {
        this._itemData.fillFromObject(itemObject);
    }
    if (Object.hasOwnProperty.call(itemObject, "prefix")) this._prefix = itemObject.prefix;
    if (Object.hasOwnProperty.call(itemObject, "suffix")) this._suffix = itemObject.suffix;
    if (Object.hasOwnProperty.call(itemObject, "locator")) this._locator = itemObject.locator;
    if (Object.hasOwnProperty.call(itemObject, "label")) this._label = itemObject.label;
    if (Object.hasOwnProperty.call(itemObject, "suppress-author")) this._suppressAuthor = itemObject["suppress-author"];
    if (Object.hasOwnProperty.call(itemObject, "author-only")) this._authorOnly = itemObject["author-only"];
    if (Object.hasOwnProperty.call(itemObject, "uris")) {
        itemObject.uris.forEach(function(uri) {
            self.addUri(uri);
        }, this);
    }
};

CitationItem.prototype.getInfoForCitationCluster = function() {
    var info = {
        id: this.id,
        "suppress-author": this._suppressAuthor
    };
    if (this._prefix) {
        info.prefix = this._prefix;
    }
    if (this._suffix) {
        info.suffix = this._suffix;
    }
    if (this._locator) {
        info.locator = this._locator;
    }
    if (this._label) {
        info.label = this._label;
    }
    return info;
};

CitationItem.prototype.getItemData = function() {
    return this._itemData;
};

CitationItem.prototype.getProperty = function(key) {
    if (this._itemData.getCustomProperty(key) !== null) {
        return this._itemData.getCustomProperty(key);
    }
    return null;
};

CitationItem.prototype.setPrefix = function(prefix) {
    this._prefix = prefix;
    return this;
};

CitationItem.prototype.setSuffix = function(suffix) {
    this._suffix = suffix;
    return this;
};

CitationItem.prototype.setLocator = function(locator) {
    this._locator = locator;
    return this;
};

CitationItem.prototype.setLabel = function(label) {
    if (label) {
        var validLabels = [ "act", "appendix", "article-locator", "book", "canon", "chapter", "column", "elocation", "equation", "figure", "folio", "issue", "line", "note", "opus", "page", "paragraph", "part", "rule", "scene", "section", "sub-verbo", "supplement", "table", "timestamp", "title-locator", "verse", "version", "volume" ];
        if (validLabels.indexOf(label) === -1) {
            throw new Error('CitationItem.setLocator: Invalid label "' + label + '"');
        }
        this._label = label;
    }
    return this;
};

CitationItem.prototype.setSuppressAuthor = function(value) {
    this._suppressAuthor = value;
    return this;
};

CitationItem.prototype.setAuthorOnly = function(value) {
    this._authorOnly = value;
    return this;
};

CitationItem.prototype.addUri = function(uri) {
    if (this._uris.indexOf(uri) !== -1) {
        return this;
    }
    this._uris.push(uri);
    return this;
};

CitationItem.prototype.toJSON = function() {
    var result = {};
    result.id = this.id;
    if (this._itemData) {
        result.itemData = this._itemData.toJSON ? this._itemData.toJSON() : this._itemData;
    }
    if (this._prefix !== undefined) result.prefix = this._prefix;
    if (this._suffix !== undefined) result.suffix = this._suffix;
    if (this._locator !== undefined) result.locator = this._locator;
    if (this._label !== undefined) result.label = this._label;
    if (this._suppressAuthor !== undefined) result["suppress-author"] = this._suppressAuthor;
    if (this._authorOnly !== undefined) result["author-only"] = this._authorOnly;
    if (this._uris.length) result.uris = this._uris;
    return result;
};

CitationItem.prototype.toFlatJSON = function(index) {
    var oldItem = {
        id: this.id,
        index: index
    };
    if (this._suppressAuthor !== undefined) {
        oldItem["suppress-author"] = this._suppressAuthor;
    }
    var itemDataObject = this._itemData.toJSON();
    Object.assign(oldItem, itemDataObject);
    if (typeof this._itemData.getCustomProperty("userID") !== "undefined" && this._itemData.getCustomProperty("userID") !== null) {
        oldItem.userID = String(this._itemData.getCustomProperty("userID"));
    }
    if (typeof this._itemData.getCustomProperty("groupID") !== "undefined" && this._itemData.getCustomProperty("groupID") !== null) {
        oldItem.groupID = String(this._itemData.getCustomProperty("groupID"));
    }
    return oldItem;
};

function CSLCitation(itemsStartIndex, citationID) {
    if (!citationID) {
        citationID = this._generateId();
    }
    if (typeof itemsStartIndex !== "number") {
        throw new Error("itemsStartIndex is required");
    }
    this.citationID = citationID;
    this._itemsStartIndex = itemsStartIndex;
    this._citationItems = new Array;
    this._properties = {};
    this._schema = "https://raw.githubusercontent.com/citation-style-language/schema/master/schemas/input/csl-citation.json";
}

CSLCitation.prototype.fillFromObject = function(citationObject) {
    if (Object.hasOwnProperty.call(citationObject, "properties") || Object.hasOwnProperty.call(citationObject, "schema")) {
        return this._fillFromCitationObject(citationObject);
    } else if (Object.hasOwnProperty.call(citationObject, "citationItems")) {
        return this._fillFromFlatCitationObject(citationObject);
    } else if (Object.hasOwnProperty.call(citationObject, "version") && Object.hasOwnProperty.call(citationObject, "library")) {
        return this._fillFromJson(citationObject);
    }
    return this._fillFromCslJson(citationObject);
};

CSLCitation.prototype._fillFromCitationObject = function(citationObject) {
    var self = this;
    if (Object.hasOwnProperty.call(citationObject, "schema")) ;
    if (Object.hasOwnProperty.call(citationObject, "properties")) {
        this._setProperties(citationObject.properties);
    }
    if (!Object.hasOwnProperty.call(citationObject, "citationItems")) {
        console.error("citationItems is empty");
        return 0;
    }
    var existingIds = this._citationItems.map(function(item) {
        return item.id;
    });
    citationObject.citationItems.forEach(function(item) {
        var id = item.id;
        var citationItem;
        if (existingIds.indexOf(id) >= 0) {
            citationItem = self._citationItems[existingIds.indexOf(id)];
        } else {
            citationItem = new CitationItem(id);
            existingIds.push(id);
        }
        if (typeof id === "number") {
            id = self._extractIdFromWord365Citation(item);
        }
        citationItem.fillFromObject(item);
        self._addCitationItem(citationItem);
    }, this);
    return existingIds.length;
};

CSLCitation.prototype._fillFromFlatCitationObject = function(citationObject) {
    var self = this;
    if (citationObject.citationItems.length === 0) {
        console.error("CSLCitation.citationItems: citationItems is empty");
        return 0;
    } else if (citationObject.citationItems.length > 1) {
        console.warn("CSLCitation.citationItems: citationItems has more than one item");
    }
    citationObject.citationItems.forEach(function(itemObject) {
        self._fillFromCslJson(itemObject);
    }, this);
    return 1;
};

CSLCitation.prototype._fillFromCslJson = function(itemObject) {
    this._itemsStartIndex;
    var id = itemObject.id;
    var citationItem;
    var existingIds = this._citationItems.map(function(item) {
        return item.id;
    });
    if (existingIds.indexOf(id) >= 0) {
        citationItem = this._citationItems[existingIds.indexOf(id)];
    } else {
        citationItem = new CitationItem(id);
    }
    citationItem.fillFromObject(itemObject);
    this._addCitationItem(citationItem);
    return 1;
};

CSLCitation.prototype._fillFromJson = function(itemObject) {
    this._itemsStartIndex;
    if (!Object.hasOwnProperty.call(itemObject, "data")) {
        console.error("Invalid citation object");
        return 0;
    }
    var existingIds = this._citationItems.map(function(item) {
        return item.id;
    });
    var id = itemObject.data.key;
    var citationItem;
    if (existingIds.indexOf(id) >= 0) {
        citationItem = this._citationItems[existingIds.indexOf(id)];
    } else {
        citationItem = new CitationItem(id);
    }
    citationItem.fillFromObject(itemObject);
    this._addCitationItem(citationItem);
    return 1;
};

CSLCitation.prototype.getCitationItems = function() {
    return this._citationItems;
};

CSLCitation.prototype.getInfoForCitationCluster = function() {
    return this._citationItems.map(function(item) {
        return item.getInfoForCitationCluster();
    }, this);
};

CSLCitation.prototype.getPlainCitation = function() {
    if (Object.hasOwnProperty.call(this._properties, "plainCitation")) {
        return this._properties.plainCitation;
    }
    return "";
};

CSLCitation.prototype._addCitationItem = function(item) {
    var existingIds = this._citationItems.map(function(item) {
        return item.id;
    });
    if (existingIds.indexOf(item.id) >= 0) {
        this._citationItems[existingIds.indexOf(item.id)] = item;
        return this;
    }
    this._citationItems.push(item);
    return this;
};

CSLCitation.prototype.addPlainCitation = function(plainCitation) {
    this._setProperties({
        plainCitation: plainCitation
    });
    return this;
};

CSLCitation.prototype._setProperties = function(properties) {
    var self = this;
    Object.keys(properties).forEach(function(key) {
        if (Object.hasOwnProperty.call(properties, key)) {
            self._properties[key] = properties[key];
        }
    }, this);
    return this;
};

CSLCitation.prototype._setSchema = function(schema) {
    this._schema = schema;
    return this;
};

CSLCitation.prototype._extractIdFromWord365Citation = function(item) {
    if (Object.hasOwnProperty.call(item, "uris") && item.uris.length) {
        var index = item.uris[0].lastIndexOf("/");
        return item.uris[0].slice(index + 1);
    }
    return item.id;
};

CSLCitation.prototype._generateId = function() {
    return Math.random().toString(36).substring(2, 15);
};

CSLCitation.prototype.validate = function() {
    var errors = [];
    if (!this._schema) errors.push("Schema is required");
    if (!this.citationID) errors.push("citationID is required");
    if (this._citationItems && Array.isArray(this._citationItems)) {
        for (var i = 0; i < this._citationItems.length; i++) {
            if (!this._citationItems[i].id) {
                errors.push("Citation item at index " + i + " must have an id");
            }
        }
    }
    return errors.length === 0 ? true : errors;
};

CSLCitation.prototype.toJSON = function() {
    var result = {
        citationID: this.citationID,
        schema: this._schema
    };
    if (this._properties && Object.keys(this._properties).length > 0) {
        result.properties = this._properties;
    }
    if (this._citationItems && this._citationItems.length > 0) {
        result.citationItems = this._citationItems.map(function(item) {
            return item.toJSON();
        });
    }
    return result;
};

var CSLCitationStorage = {
    _items: [],
    _ids: [],
    size: 0,
    get: function get(id) {
        id = id.toString();
        var index = this._ids.indexOf(id);
        if (index >= 0) return this._items[index];
        return null;
    },
    getIndex: function getIndex(id) {
        id = id.toString();
        return this._ids.indexOf(id);
    },
    clear: function clear() {
        this._items = [];
        this._ids = [];
        this.size = 0;
        return this;
    },
    delete: function _delete(id) {
        id = id.toString();
        var index = this._ids.indexOf(id);
        if (index >= 0) {
            this._items.splice(index, 1);
            this._ids.splice(index, 1);
            this.size--;
        }
        return this;
    },
    forEach: function forEach(callback) {
        for (var i = 0; i < this.size; i++) {
            callback(this._items[i], this._ids[i], this);
        }
    },
    has: function has(id) {
        id = id.toString();
        return this._ids.indexOf(id) >= 0;
    },
    set: function set(id, item) {
        id = id.toString();
        var index = this._ids.indexOf(id);
        if (index >= 0) {
            this._items[index] = item;
            return this;
        }
        this._items.push(item);
        this._ids.push(id);
        this.size++;
        return this;
    }
};

var CSL = {
    PROCESSOR_VERSION: "1.4.61",
    error: function error(str) {
        if ("undefined" === typeof Error) {
            throw new Error("citeproc-js error: " + str);
        } else {
            throw "citeproc-js error: " + str;
        }
    },
    debug: function debug(str) {
        if ("undefined" === typeof console) {
            dump("CSL: " + str + "\n");
        } else {
            console.log("citeproc-js warning: " + str);
        }
    },
    toLocaleUpperCase(str) {
        var arr = this.tmp.lang_array;
        try {
            str = str.toLocaleUpperCase(arr);
        } catch (e) {
            str = str.toUpperCase();
        }
        return str;
    },
    toLocaleLowerCase(str) {
        var arr = this.tmp.lang_array;
        try {
            str = str.toLocaleLowerCase(arr);
        } catch (e) {
            str = str.toLowerCase();
        }
        return str;
    },
    LOCATOR_LABELS_REGEXP: new RegExp("^((vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\\.)\\s+(.*)"),
    STATUTE_SUBDIV_PLAIN_REGEX: /(?:(?:^| )(?:vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\. *)/,
    STATUTE_SUBDIV_PLAIN_REGEX_FRONT: /(?:^\s*[.,;]*\s*(?:vrs|sv|subpara|op|subch|add|amend|annot|app|art|bibliog|bk|ch|cl|col|cmt|dec|dept|div|ex|fig|fld|fol|n|hypo|illus|intro|l|no|p|pp|para|pt|pmbl|princ|pub|r|rn|sched|sec|ser|subdiv|subsec|supp|tbl|tit|vol)\. *)/,
    STATUTE_SUBDIV_STRINGS: {
        "vrs.": "verse",
        "sv.": "sub-verbo",
        "subpara.": "subparagraph",
        "op.": "opus",
        "subch.": "subchapter",
        "add.": "addendum",
        "amend.": "amendment",
        "annot.": "annotation",
        "app.": "appendix",
        "art.": "article",
        "bibliog.": "bibliography",
        "bk.": "book",
        "ch.": "chapter",
        "cl.": "clause",
        "col.": "column",
        "cmt.": "comment",
        "dec.": "decision",
        "dept.": "department",
        "ex.": "example",
        "fig.": "figure",
        "fld.": "field",
        "fol.": "folio",
        "n.": "note",
        "hypo.": "hypothetical",
        "illus.": "illustration",
        "intro.": "introduction",
        "l.": "line",
        "no.": "issue",
        "p.": "page",
        "pp.": "page",
        "para.": "paragraph",
        "pt.": "part",
        "pmbl.": "preamble",
        "princ.": "principle",
        "pub.": "publication",
        "r.": "rule",
        "rn.": "randnummer",
        "sched.": "schedule",
        "sec.": "section",
        "ser.": "series,",
        "subdiv.": "subdivision",
        "subsec.": "subsection",
        "supp.": "supplement",
        "tbl.": "table",
        "tit.": "title",
        "vol.": "volume"
    },
    STATUTE_SUBDIV_STRINGS_REVERSE: {
        verse: "vrs.",
        "sub-verbo": "sv.",
        "sub verbo": "sv.",
        subparagraph: "subpara.",
        opus: "op.",
        subchapter: "subch.",
        addendum: "add.",
        amendment: "amend.",
        annotation: "annot.",
        appendix: "app.",
        article: "art.",
        bibliography: "bibliog.",
        book: "bk.",
        chapter: "ch.",
        clause: "cl.",
        column: "col.",
        comment: "cmt.",
        decision: "dec.",
        department: "dept.",
        example: "ex.",
        figure: "fig.",
        field: "fld.",
        folio: "fol.",
        note: "n.",
        hypothetical: "hypo.",
        illustration: "illus.",
        introduction: "intro.",
        line: "l.",
        issue: "no.",
        page: "p.",
        paragraph: "para.",
        part: "pt.",
        preamble: "pmbl.",
        principle: "princ.",
        publication: "pub.",
        rule: "r.",
        randnummer: "rn.",
        schedule: "sched.",
        section: "sec.",
        "series,": "ser.",
        subdivision: "subdiv.",
        subsection: "subsec.",
        supplement: "supp.",
        table: "tbl.",
        title: "tit.",
        volume: "vol."
    },
    LOCATOR_LABELS_MAP: {
        vrs: "verse",
        sv: "sub-verbo",
        subpara: "subparagraph",
        op: "opus",
        subch: "subchapter",
        add: "addendum",
        amend: "amendment",
        annot: "annotation",
        app: "appendix",
        art: "article",
        bibliog: "bibliography",
        bk: "book",
        ch: "chapter",
        cl: "clause",
        col: "column",
        cmt: "comment",
        dec: "decision",
        dept: "department",
        ex: "example",
        fig: "figure",
        fld: "field",
        fol: "folio",
        n: "note",
        hypo: "hypothetical",
        illus: "illustration",
        intro: "introduction",
        l: "line",
        no: "issue",
        p: "page",
        pp: "page",
        para: "paragraph",
        pt: "part",
        pmbl: "preamble",
        princ: "principle",
        pub: "publication",
        r: "rule",
        rn: "randnummer",
        sched: "schedule",
        sec: "section",
        ser: "series,",
        subdiv: "subdivision",
        subsec: "subsection",
        supp: "supplement",
        tbl: "table",
        tit: "title",
        vol: "volume"
    },
    MODULE_MACROS: {
        "juris-pretitle": true,
        "juris-title": true,
        "juris-pretitle-short": true,
        "juris-title-short": true,
        "juris-main": true,
        "juris-main-short": true,
        "juris-tail": true,
        "juris-tail-short": true,
        "juris-locator": true
    },
    MODULE_TYPES: {
        legal_case: true,
        legislation: true,
        bill: true,
        hearing: true,
        gazette: true,
        report: true,
        regulation: true,
        standard: true,
        patent: true,
        locator: true
    },
    checkNestedBrace: function checkNestedBrace(state) {
        if (state.opt.xclass === "note") {
            this.depth = 0;
            this.update = function(str) {
                var str = str ? str : "";
                var lst = str.split(/([\(\)])/);
                for (var i = 1, ilen = lst.length; i < ilen; i += 2) {
                    if (lst[i] === "(") {
                        if (1 === this.depth % 2) {
                            lst[i] = "[";
                        }
                        this.depth += 1;
                    } else if (lst[i] === ")") {
                        if (0 === this.depth % 2) {
                            lst[i] = "]";
                        }
                        this.depth -= 1;
                    }
                }
                var ret = lst.join("");
                return ret;
            };
        } else {
            this.update = function(str) {
                return str;
            };
        }
    },
    MULTI_FIELDS: [ "event", "publisher", "publisher-place", "event-place", "title", "container-title", "collection-title", "event-title", "original-title", "part-title", "reviewed-title", "volume-title", "authority", "genre", "title-short", "medium", "country", "jurisdiction", "archive", "archive-place" ],
    LangPrefsMap: {
        title: "titles",
        "title-short": "titles",
        event: "titles",
        genre: "titles",
        medium: "titles",
        "container-title": "journals",
        "collection-title": "titles",
        archive: "journals",
        publisher: "publishers",
        authority: "publishers",
        "publisher-place": "places",
        "event-place": "places",
        "archive-place": "places",
        jurisdiction: "places",
        number: "places",
        edition: "places",
        issue: "places",
        volume: "places"
    },
    AbbreviationSegments: function AbbreviationSegments() {
        this["container-title"] = {};
        this["collection-title"] = {};
        this["institution-entire"] = {};
        this["institution-part"] = {};
        this.nickname = {};
        this.number = {};
        this.title = {};
        this.place = {};
        this.hereinafter = {};
        this.classic = {};
        this["container-phrase"] = {};
        this["title-phrase"] = {};
    },
    getAbbrevsDomain: function getAbbrevsDomain(state, country, lang) {
        var domain = null;
        if (state.opt.availableAbbrevDomains && country && country !== "default") {
            var globalDomainPreference = state.locale[state.opt.lang].opts["jurisdiction-preference"];
            var itemDomainPreference = null;
            if (state.locale[lang]) {
                itemDomainPreference = state.locale[lang].opts["jurisdiction-preference"];
            }
            if (itemDomainPreference) {
                for (var j = itemDomainPreference.length - 1; j > -1; j--) {
                    if (state.opt.availableAbbrevDomains[country].indexOf(itemDomainPreference[j]) > -1) {
                        domain = itemDomainPreference[j];
                        break;
                    }
                }
            }
            if (!domain && globalDomainPreference) {
                for (var j = globalDomainPreference.length - 1; j > -1; j--) {
                    if (state.opt.availableAbbrevDomains[country].indexOf(globalDomainPreference[j]) > -1) {
                        domain = globalDomainPreference[j];
                        break;
                    }
                }
            }
        }
        return domain;
    },
    FIELD_CATEGORY_REMAP: {
        title: "title",
        "container-title": "container-title",
        "collection-title": "collection-title",
        country: "place",
        number: "number",
        place: "place",
        archive: "container-title",
        "title-short": "title",
        genre: "title",
        event: "title",
        medium: "title",
        "archive-place": "place",
        "publisher-place": "place",
        "event-place": "place",
        jurisdiction: "place",
        "language-name": "place",
        "language-name-original": "place",
        "call-number": "number",
        "chapter-number": "number",
        "collection-number": "number",
        edition: "number",
        page: "number",
        issue: "number",
        locator: "number",
        "locator-extra": "number",
        "number-of-pages": "number",
        "number-of-volumes": "number",
        volume: "number",
        "citation-number": "number",
        publisher: "institution-part"
    },
    parseLocator: function parseLocator(item) {
        if (this.opt.development_extensions.locator_date_and_revision) {
            if (item.locator) {
                item.locator = "" + item.locator;
                var idx = item.locator.indexOf("|");
                if (idx > -1) {
                    var raw_locator = item.locator;
                    item.locator = raw_locator.slice(0, idx);
                    raw_locator = raw_locator.slice(idx + 1);
                    var m = raw_locator.match(/^([0-9]{4}-[0-9]{2}-[0-9]{2}).*/);
                    if (m) {
                        item["locator-date"] = this.fun.dateparser.parseDateToObject(m[1]);
                        raw_locator = raw_locator.slice(m[1].length);
                    }
                    item["locator-extra"] = raw_locator.replace(/^\s+/, "").replace(/\s+$/, "");
                }
            }
        }
        if (item.locator) {
            item.locator = ("" + item.locator).replace(/\s+$/, "");
        }
        return item;
    },
    normalizeLocaleStr: function normalizeLocaleStr(str) {
        if (!str) {
            return;
        }
        var lst = str.split("-");
        lst[0] = lst[0].toLowerCase();
        if (lst[1]) {
            lst[1] = lst[1].toUpperCase();
        }
        return lst.join("-");
    },
    parseNoteFieldHacks: function parseNoteFieldHacks(Item, validFieldsForType, allowDateOverride) {
        if ("string" !== typeof Item.note) {
            return;
        }
        var elems = [];
        var lines = Item.note.split("\n");
        for (var i = 0, ilen = lines.length; i < ilen; i++) {
            var line = lines[i];
            var elems = [];
            var m = line.match(CSL.NOTE_FIELDS_REGEXP);
            if (m) {
                var splt = line.split(CSL.NOTE_FIELDS_REGEXP);
                for (var j = 0, jlen = splt.length - 1; j < jlen; j++) {
                    elems.push(splt[j]);
                    elems.push(m[j]);
                }
                elems.push(splt[splt.length - 1]);
                for (var j = 1, jlen = elems.length; j < jlen; j += 2) {
                    if (elems[j - 1].trim() && (i > 0 || j > 1) && !elems[j - 1].match(CSL.NOTE_FIELD_REGEXP)) {
                        break;
                    } else {
                        elems[j] = "\n" + elems[j].slice(2, -1).trim() + "\n";
                    }
                }
                lines[i] = elems.join("");
            }
        }
        lines = lines.join("\n").split("\n");
        var offset = 0;
        var names = {};
        for (var i = 0, ilen = lines.length; i < ilen; i++) {
            var line = lines[i];
            var mm = line.match(CSL.NOTE_FIELD_REGEXP);
            if (!line.trim()) {
                continue;
            } else if (!mm) {
                if (i === 0) {
                    continue;
                } else {
                    offset = i;
                    break;
                }
            }
            var key = mm[1];
            var val = mm[2].replace(/^\s+/, "").replace(/\s+$/, "");
            if (key === "type") {
                Item.type = val;
                lines[i] = "";
            } else if (CSL.DATE_VARIABLES.indexOf(key.replace(/^alt-/, "")) > -1) {
                if (!Item[key] || allowDateOverride) {
                    Item[key] = CSL.DateParser.parseDateToArray(val);
                    if (!validFieldsForType || validFieldsForType[key] && this.isDateString(val)) {
                        lines[i] = "";
                    }
                }
            } else if (!Item[key]) {
                if (CSL.NAME_VARIABLES.indexOf(key.replace(/^alt-/, "")) > -1) {
                    if (!names[key]) {
                        names[key] = [];
                    }
                    var lst = val.split(/\s*\|\|\s*/);
                    if (lst.length === 1) {
                        names[key].push({
                            literal: lst[0]
                        });
                    } else if (lst.length === 2) {
                        var name = {
                            family: lst[0],
                            given: lst[1]
                        };
                        CSL.parseParticles(name);
                        names[key].push(name);
                    }
                } else {
                    Item[key] = val;
                }
                if (!validFieldsForType || validFieldsForType[key]) {
                    lines[i] = "";
                }
            }
        }
        for (var key in names) {
            Item[key] = names[key];
        }
        if (validFieldsForType) {
            if (lines[offset].trim()) {
                lines[offset] = "\n" + lines[offset];
            }
            for (var i = offset - 1; i > -1; i--) {
                if (!lines[i].trim()) {
                    lines = lines.slice(0, i).concat(lines.slice(i + 1));
                }
            }
        }
        Item.note = lines.join("\n").trim();
    },
    checkPrefixSpaceAppend: function checkPrefixSpaceAppend(state, prefix) {
        if (!prefix) {
            prefix = "";
        }
        var sp = "";
        var test_prefix = prefix.replace(/<[^>]+>/g, "").replace(/["'\u201d\u2019\u00bb\u202f\u00a0 ]+$/g, "");
        var test_char = test_prefix.slice(-1);
        if (test_prefix.match(CSL.ENDSWITH_ROMANESQUE_REGEXP)) {
            sp = " ";
        } else if (CSL.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(test_char) > -1) {
            sp = " ";
        } else if (test_char.match(/[\)\],0-9]/)) {
            sp = " ";
        }
        var prefix = (prefix + sp).replace(/\s+/g, " ");
        return prefix;
    },
    checkIgnorePredecessor: function checkIgnorePredecessor(state, prefix) {
        var test_prefix = prefix.replace(/<[^>]+>/g, "").replace(/["'\u201d\u2019\u00bb\u202f\u00a0 ]+$/g, "");
        var test_char = test_prefix.slice(-1);
        if (CSL.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(test_char) > -1 && prefix.trim().indexOf(" ") > -1) {
            state.tmp.term_predecessor = false;
            return true;
        }
        return false;
    },
    checkSuffixSpacePrepend: function checkSuffixSpacePrepend(state, suffix) {
        if (!suffix) {
            return "";
        }
        if (suffix.match(CSL.STARTSWITH_ROMANESQUE_REGEXP) || [ "[", "(" ].indexOf(suffix.slice(0, 1)) > -1) {
            suffix = " " + suffix;
        }
        return suffix;
    },
    GENDERS: [ "masculine", "feminine" ],
    ERROR_NO_RENDERED_FORM: 1,
    PREVIEW: "Just for laughs.",
    ASSUME_ALL_ITEMS_REGISTERED: 2,
    START: 0,
    END: 1,
    SINGLETON: 2,
    SEEN: 6,
    SUCCESSOR: 3,
    SUCCESSOR_OF_SUCCESSOR: 4,
    SUPPRESS: 5,
    SINGULAR: 0,
    PLURAL: 1,
    LITERAL: true,
    BEFORE: 1,
    AFTER: 2,
    DESCENDING: 1,
    ASCENDING: 2,
    PRIMARY: 1,
    SECONDARY: 2,
    POSITION_FIRST: 0,
    POSITION_SUBSEQUENT: 1,
    POSITION_IBID: 2,
    POSITION_IBID_WITH_LOCATOR: 3,
    POSITION_CONTAINER_SUBSEQUENT: 4,
    POSITION_MAP: {
        0: 0,
        4: 1,
        1: 2,
        2: 3,
        3: 4
    },
    POSITION_TEST_VARS: [ "position", "first-reference-note-number", "near-note" ],
    AREAS: [ "citation", "citation_sort", "bibliography", "bibliography_sort", "intext" ],
    CITE_FIELDS: [ "first-reference-note-number", "first-container-reference-note-number", "locator", "locator-extra" ],
    SWAPPING_PUNCTUATION: [ ".", "!", "?", ":", "," ],
    TERMINAL_PUNCTUATION: [ ":", ".", ";", "!", "?", " " ],
    NONE: 0,
    NUMERIC: 1,
    POSITION: 2,
    TRIGRAPH: 3,
    DATE_PARTS: [ "year", "month", "day" ],
    DATE_PARTS_ALL: [ "year", "month", "day", "season" ],
    DATE_PARTS_INTERNAL: [ "year", "month", "day", "year_end", "month_end", "day_end" ],
    NAME_PARTS: [ "non-dropping-particle", "family", "given", "dropping-particle", "suffix", "literal" ],
    DISAMBIGUATE_OPTIONS: [ "disambiguate-add-names", "disambiguate-add-givenname", "disambiguate-add-year-suffix" ],
    GIVENNAME_DISAMBIGUATION_RULES: [ "all-names", "all-names-with-initials", "primary-name", "primary-name-with-initials", "by-cite" ],
    NAME_ATTRIBUTES: [ "and", "delimiter-precedes-last", "delimiter-precedes-et-al", "initialize-with", "initialize", "name-as-sort-order", "sort-separator", "et-al-min", "et-al-use-first", "et-al-subsequent-min", "et-al-subsequent-use-first", "form", "prefix", "suffix", "delimiter" ],
    LOOSE: 0,
    STRICT: 1,
    TOLERANT: 2,
    PREFIX_PUNCTUATION: /[.;:]\s*$/,
    SUFFIX_PUNCTUATION: /^\s*[.;:,\(\)]/,
    NUMBER_REGEXP: /(?:^\d+|\d+$)/,
    NAME_INITIAL_REGEXP: /^([A-Z\u0e01-\u0e5b\u00c0-\u017f\u0400-\u042f\u0590-\u05d4\u05d6-\u05ff\u0600-\u06ff\u0370\u0372\u0376\u0386\u0388-\u03ab\u03e2\u03e4\u03e6\u03e8\u03ea\u03ec\u03ee\u03f4\u03f7\u03fd-\u03ff])([a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0400-\u052f\u0600-\u06ff\u0370-\u03ff\u1f00-\u1fff]*|)(\.)*/,
    ROMANESQUE_REGEXP: /[-0-9a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/,
    ROMANESQUE_NOT_REGEXP: /[^a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/g,
    STARTSWITH_ROMANESQUE_REGEXP: /^[&a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]/,
    ENDSWITH_ROMANESQUE_REGEXP: /[.;:&a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]$/,
    ALL_ROMANESQUE_REGEXP: /^[a-zA-Z\u0e01-\u0e5b\u00c0-\u017f\u0370-\u03ff\u0400-\u052f\u0590-\u05d4\u05d6-\u05ff\u1f00-\u1fff\u0600-\u06ff\u200c\u200d\u200e\u0218\u0219\u021a\u021b\u202a-\u202e]+$/,
    VIETNAMESE_SPECIALS: /[\u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]/,
    VIETNAMESE_NAMES: /^(?:(?:[.AaBbCcDdEeGgHhIiKkLlMmNnOoPpQqRrSsTtUuVvXxYy \u00c0-\u00c3\u00c8-\u00ca\u00cc\u00cd\u00d2-\u00d5\u00d9\u00da\u00dd\u00e0-\u00e3\u00e8-\u00ea\u00ec\u00ed\u00f2-\u00f5\u00f9\u00fa\u00fd\u0101\u0103\u0110\u0111\u0128\u0129\u0168\u0169\u01a0\u01a1\u01af\u01b0\u1ea0-\u1ef9]{2,6})(\s+|$))+$/,
    NOTE_FIELDS_REGEXP: /\{:(?:[\-_a-z]+|[A-Z]+):[^\}]+\}/g,
    NOTE_FIELD_REGEXP: /^([\-_a-z]+|[A-Z]+):\s*([^\}]+)$/,
    PARTICLE_GIVEN_REGEXP: /^([^ ]+(?:\u02bb |\u2019 | |\' ) *)(.+)$/,
    PARTICLE_FAMILY_REGEXP: /^([^ ]+(?:\-|\u02bb|\u2019| |\') *)(.+)$/,
    DISPLAY_CLASSES: [ "block", "left-margin", "right-inline", "indent" ],
    NAME_VARIABLES: [ "author", "chair", "collection-editor", "compiler", "composer", "container-author", "contributor", "curator", "director", "editor", "editor-translator", "editorial-director", "executive-producer", "guest", "host", "illustrator", "interviewer", "narrator", "organizer", "original-author", "performer", "producer", "recipient", "reviewed-author", "script-writer", "series-creator", "translator", "commenter" ],
    CREATORS: [ "author", "chair", "collection-editor", "compiler", "composer", "container-author", "contributor", "curator", "director", "editor", "editor-translator", "editorial-director", "executive-producer", "guest", "host", "illustrator", "interviewer", "narrator", "organizer", "original-author", "performer", "producer", "recipient", "reviewed-author", "script-writer", "series-creator", "translator", "commenter" ],
    NUMERIC_VARIABLES: [ "call-number", "chapter-number", "collection-number", "division", "edition", "page", "issue", "locator", "locator-extra", "number", "number-of-pages", "number-of-volumes", "part-number", "printing-number", "section", "supplement-number", "version", "volume", "supplement", "citation-number" ],
    DATE_VARIABLES: [ "locator-date", "issued", "event-date", "accessed", "original-date", "publication-date", "available-date", "submitted", "alt-issued", "alt-event" ],
    VARIABLES_WITH_SHORT_FORM: [ "title", "container-title" ],
    TITLE_FIELD_SPLITS: function TITLE_FIELD_SPLITS(seg) {
        var keys = [ "title", "short", "main", "sub", "subjoin" ];
        var ret = {};
        for (var i = 0, ilen = keys.length; i < ilen; i++) {
            ret[keys[i]] = seg + "title" + (keys[i] === "title" ? "" : "-" + keys[i]);
        }
        return ret;
    },
    demoteNoiseWords: function demoteNoiseWords(state, fld, drop_or_demote) {
        var SKIP_WORDS = state.locale[state.opt.lang].opts["leading-noise-words"];
        if (fld && drop_or_demote) {
            fld = fld.split(/\s+/);
            fld.reverse();
            var toEnd = [];
            for (var j = fld.length - 1; j > -1; j += -1) {
                if (SKIP_WORDS.indexOf(fld[j].toLowerCase()) > -1) {
                    toEnd.push(fld.pop());
                } else {
                    break;
                }
            }
            fld.reverse();
            var start = fld.join(" ");
            var end = toEnd.join(" ");
            if ("drop" === drop_or_demote || !end) {
                fld = start;
            } else if ("demote" === drop_or_demote) {
                fld = [ start, end ].join(", ");
            }
        }
        return fld;
    },
    extractTitleAndSubtitle: function extractTitleAndSubtitle(Item, narrowSpaceLocale) {
        var narrowSpace = narrowSpaceLocale ? " " : "";
        var segments = [ "" ];
        if (this.opt.development_extensions.split_container_title) {
            segments.push("container-");
        }
        for (var i = 0, ilen = segments.length; i < ilen; i++) {
            var seg = segments[i];
            var title = CSL.TITLE_FIELD_SPLITS(seg);
            var langs = [ false ];
            if (Item.multi) {
                for (var lang in Item.multi._keys[title.short]) {
                    langs.push(lang);
                }
            }
            for (var j = 0, jlen = langs.length; j < jlen; j++) {
                var lang = langs[j];
                var vals = {};
                if (lang) {
                    if (Item.multi._keys[title.title]) {
                        vals[title.title] = Item.multi._keys[title.title][lang];
                    }
                    if (Item.multi._keys[title["short"]]) {
                        vals[title["short"]] = Item.multi._keys[title["short"]][lang];
                    }
                } else {
                    vals[title.title] = Item[title.title];
                    vals[title["short"]] = Item[title["short"]];
                }
                vals[title.main] = vals[title.title];
                vals[title.sub] = false;
                var shortTitle = vals[title["short"]];
                if (vals[title.title]) {
                    if (shortTitle && shortTitle.toLowerCase() === vals[title.title].toLowerCase()) {
                        vals[title.main] = vals[title.title];
                        vals[title.subjoin] = "";
                        vals[title.sub] = "";
                    } else if (shortTitle) {
                        var tail = vals[title.title].slice(shortTitle.replace(/[\?\!]+$/, "").length);
                        var top = vals[title.title].replace(tail.replace(/^[\?\!]+/, ""), "").trim();
                        var m = CSL.TITLE_SPLIT_REGEXP.matchfirst.exec(tail);
                        if (m && top.toLowerCase() === shortTitle.toLowerCase()) {
                            vals[title.main] = top;
                            vals[title.subjoin] = m[1].replace(/[\?\!]+(\s*)$/, "$1");
                            vals[title.sub] = tail.replace(CSL.TITLE_SPLIT_REGEXP.matchfirst, "");
                            if (this.opt.development_extensions.force_short_title_casing_alignment) {
                                vals[title["short"]] = vals[title.main];
                            }
                        } else {
                            var splitTitle = CSL.TITLE_SPLIT(vals[title.title]);
                            if (splitTitle.length == 3) {
                                vals[title.main] = splitTitle[0];
                                vals[title.subjoin] = splitTitle[1];
                                vals[title.sub] = splitTitle[2];
                            } else {
                                vals[title.main] = vals[title.title];
                                vals[title.subjoin] = "";
                                vals[title.sub] = "";
                            }
                        }
                    } else {
                        var splitTitle = CSL.TITLE_SPLIT(vals[title.title]);
                        if (splitTitle.length == 3) {
                            vals[title.main] = splitTitle[0];
                            vals[title.subjoin] = splitTitle[1];
                            vals[title.sub] = splitTitle[2];
                            if (this.opt.development_extensions.implicit_short_title && Item.type !== "legal_case") {
                                if (!Item[title.short] && !vals[title.main].match(/^[\-\.[0-9]+$/)) {
                                    var punct = vals[title.subjoin].trim();
                                    if ([ "?", "!" ].indexOf(punct) === -1) {
                                        punct = "";
                                    }
                                    vals[title.short] = vals[title.main] + punct;
                                }
                            }
                        } else {
                            vals[title.main] = vals[title.title];
                            vals[title.subjoin] = "";
                            vals[title.sub] = "";
                        }
                    }
                    if (vals[title.subjoin]) {
                        if (vals[title.subjoin].match(/([\?\!])/)) {
                            var m = vals[title.subjoin].match(/(\s*)$/);
                            vals[title.main] = vals[title.main] + narrowSpace + vals[title.subjoin].trim();
                            vals[title.subjoin] = m[1];
                        }
                    }
                }
                if (vals[title.subjoin]) {
                    if (vals[title.subjoin].indexOf(":") > -1) {
                        vals[title.subjoin] = narrowSpace + ": ";
                    }
                    if (vals[title.subjoin].indexOf("-") > -1 || vals[title.subjoin].indexOf("—") > -1) {
                        vals[title.subjoin] = "—";
                    }
                }
                if (lang) {
                    for (var key in vals) {
                        if (!Item.multi._keys[key]) {
                            Item.multi._keys[key] = {};
                        }
                        Item.multi._keys[key][lang] = vals[key];
                    }
                } else {
                    for (var key in vals) {
                        Item[key] = vals[key];
                    }
                }
            }
        }
    },
    titlecaseSentenceOrNormal: function titlecaseSentenceOrNormal(state, Item, seg, lang, sentenceCase) {
        var title = CSL.TITLE_FIELD_SPLITS(seg);
        var vals = {};
        if (lang && Item.multi) {
            if (Item.multi._keys[title.title]) {
                vals[title.title] = Item.multi._keys[title.title][lang];
            }
            if (Item.multi._keys[title.main]) {
                vals[title.main] = Item.multi._keys[title.main][lang];
            }
            if (Item.multi._keys[title.sub]) {
                vals[title.sub] = Item.multi._keys[title.sub][lang];
            }
            if (Item.multi._keys[title.subjoin]) {
                vals[title.subjoin] = Item.multi._keys[title.subjoin][lang];
            }
        } else {
            vals[title.title] = Item[title.title];
            vals[title.main] = Item[title.main];
            vals[title.sub] = Item[title.sub];
            vals[title.subjoin] = Item[title.subjoin];
        }
        if (vals[title.main] && vals[title.sub]) {
            var mainTitle = vals[title.main];
            var subJoin = vals[title.subjoin];
            var subTitle = vals[title.sub];
            if (sentenceCase) {
                mainTitle = CSL.Output.Formatters.sentence(state, mainTitle);
                subTitle = CSL.Output.Formatters.sentence(state, subTitle);
            } else if (state.opt.development_extensions.uppercase_subtitles) {
                subTitle = CSL.Output.Formatters["capitalize-first"](state, subTitle);
            }
            return [ mainTitle, subJoin, subTitle ].join("");
        } else if (vals[title.title]) {
            if (sentenceCase) {
                return CSL.Output.Formatters.sentence(state, vals[title.title]);
            } else if (state.opt.development_extensions.uppercase_subtitles) {
                var splits = CSL.TITLE_SPLIT(vals[title.title]);
                for (var i = 0, ilen = splits.length; i < ilen; i += 2) {
                    splits[i] = CSL.Output.Formatters["capitalize-first"](state, splits[i]);
                }
                for (var i = 1, ilen = splits.length - 1; i < ilen; i += 2) {
                    var m = splits[i].match(/([:\?\!] )/);
                    if (m) {
                        var narrowSpace = state.opt["default-locale"][0].slice(0, 2).toLowerCase() === "fr" ? " " : "";
                        splits[i] = narrowSpace + m[1];
                    }
                    if (splits[i].indexOf("-") > -1 || splits[i].indexOf("—") > -1) {
                        splits[i] = "—";
                    }
                }
                vals[title.title] = splits.join("");
                return vals[title.title];
            } else {
                return vals[title.title];
            }
        } else {
            return "";
        }
    },
    getSafeEscape: function getSafeEscape(state) {
        if ([ "bibliography", "citation" ].indexOf(state.tmp.area) > -1) {
            var callbacks = [];
            if (state.opt.development_extensions.thin_non_breaking_space_html_hack && state.opt.mode === "html") {
                callbacks.push(function(txt) {
                    return txt.replace(/\u202f/g, '<span style="white-space:nowrap">&thinsp;</span>');
                });
            }
            if (callbacks.length) {
                return function(txt) {
                    for (var i = 0, ilen = callbacks.length; i < ilen; i += 1) {
                        txt = callbacks[i](txt);
                    }
                    return CSL.Output.Formats[state.opt.mode].text_escape(txt);
                };
            } else {
                return CSL.Output.Formats[state.opt.mode].text_escape;
            }
        } else {
            return function(txt) {
                return txt;
            };
        }
    },
    SKIP_WORDS: [ "about", "above", "across", "afore", "after", "against", "al", "along", "alongside", "amid", "amidst", "among", "amongst", "anenst", "apropos", "apud", "around", "as", "aside", "astride", "at", "athwart", "atop", "barring", "before", "behind", "below", "beneath", "beside", "besides", "between", "beyond", "but", "by", "circa", "despite", "down", "during", "et", "except", "for", "forenenst", "from", "given", "in", "inside", "into", "lest", "like", "modulo", "near", "next", "notwithstanding", "of", "off", "on", "onto", "out", "over", "per", "plus", "pro", "qua", "sans", "since", "than", "through", " thru", "throughout", "thruout", "till", "to", "toward", "towards", "under", "underneath", "until", "unto", "up", "upon", "versus", "vs.", "v.", "vs", "v", "via", "vis-à-vis", "with", "within", "without", "according to", "ahead of", "apart from", "as for", "as of", "as per", "as regards", "aside from", "back to", "because of", "close to", "due to", "except for", "far from", "inside of", "instead of", "near to", "next to", "on to", "out from", "out of", "outside of", "prior to", "pursuant to", "rather than", "regardless of", "such as", "that of", "up to", "where as", "or", "yet", "so", "for", "and", "nor", "a", "an", "the", "de", "d'", "von", "van", "c", "ca" ],
    FORMAT_KEY_SEQUENCE: [ "@strip-periods", "@font-style", "@font-variant", "@font-weight", "@text-decoration", "@vertical-align", "@quotes" ],
    INSTITUTION_KEYS: [ "font-style", "font-variant", "font-weight", "text-decoration", "text-case" ],
    SUFFIX_CHARS: "a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z",
    ROMAN_NUMERALS: [ [ "", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix" ], [ "", "x", "xx", "xxx", "xl", "l", "lx", "lxx", "lxxx", "xc" ], [ "", "c", "cc", "ccc", "cd", "d", "dc", "dcc", "dccc", "cm" ], [ "", "m", "mm", "mmm", "mmmm", "mmmmm" ] ],
    LANGS: {
        "af-ZA": "Afrikaans",
        ar: "Arabic",
        "bg-BG": "Bulgarian",
        "ca-AD": "Catalan",
        "cs-CZ": "Czech",
        "da-DK": "Danish",
        "de-AT": "Austrian",
        "de-CH": "German (CH)",
        "de-DE": "German (DE)",
        "el-GR": "Greek",
        "en-GB": "English (GB)",
        "en-US": "English (US)",
        "es-ES": "Spanish",
        "et-EE": "Estonian",
        eu: "European",
        "fa-IR": "Persian",
        "fi-FI": "Finnish",
        "fr-CA": "French (CA)",
        "fr-FR": "French (FR)",
        "he-IL": "Hebrew",
        "hr-HR": "Croatian",
        "hu-HU": "Hungarian",
        "is-IS": "Icelandic",
        "it-IT": "Italian",
        "ja-JP": "Japanese",
        "km-KH": "Khmer",
        "ko-KR": "Korean",
        "lt-LT": "Lithuanian",
        "lv-LV": "Latvian",
        "mn-MN": "Mongolian",
        "nb-NO": "Norwegian (Bokmål)",
        "nl-NL": "Dutch",
        "nn-NO": "Norwegian (Nynorsk)",
        "pl-PL": "Polish",
        "pt-BR": "Portuguese (BR)",
        "pt-PT": "Portuguese (PT)",
        "ro-RO": "Romanian",
        "ru-RU": "Russian",
        "sk-SK": "Slovak",
        "sl-SI": "Slovenian",
        "sr-RS": "Serbian",
        "sv-SE": "Swedish",
        "th-TH": "Thai",
        "tr-TR": "Turkish",
        "uk-UA": "Ukrainian",
        "vi-VN": "Vietnamese",
        "zh-CN": "Chinese (CN)",
        "zh-TW": "Chinese (TW)"
    },
    LANG_BASES: {
        af: "af_ZA",
        ar: "ar",
        bg: "bg_BG",
        ca: "ca_AD",
        cs: "cs_CZ",
        da: "da_DK",
        de: "de_DE",
        el: "el_GR",
        en: "en_US",
        es: "es_ES",
        et: "et_EE",
        eu: "eu",
        fa: "fa_IR",
        fi: "fi_FI",
        fr: "fr_FR",
        he: "he_IL",
        hr: "hr-HR",
        hu: "hu_HU",
        is: "is_IS",
        it: "it_IT",
        ja: "ja_JP",
        km: "km_KH",
        ko: "ko_KR",
        lt: "lt_LT",
        lv: "lv-LV",
        mn: "mn_MN",
        nb: "nb_NO",
        nl: "nl_NL",
        nn: "nn-NO",
        pl: "pl_PL",
        pt: "pt_PT",
        ro: "ro_RO",
        ru: "ru_RU",
        sk: "sk_SK",
        sl: "sl_SI",
        sr: "sr_RS",
        sv: "sv_SE",
        th: "th_TH",
        tr: "tr_TR",
        uk: "uk_UA",
        vi: "vi_VN",
        zh: "zh_CN"
    },
    SUPERSCRIPTS: {
        "ª": "a",
        "²": "2",
        "³": "3",
        "¹": "1",
        "º": "o",
        "ʰ": "h",
        "ʱ": "ɦ",
        "ʲ": "j",
        "ʳ": "r",
        "ʴ": "ɹ",
        "ʵ": "ɻ",
        "ʶ": "ʁ",
        "ʷ": "w",
        "ʸ": "y",
        "ˠ": "ɣ",
        "ˡ": "l",
        "ˢ": "s",
        "ˣ": "x",
        "ˤ": "ʕ",
        "ᴬ": "A",
        "ᴭ": "Æ",
        "ᴮ": "B",
        "ᴰ": "D",
        "ᴱ": "E",
        "ᴲ": "Ǝ",
        "ᴳ": "G",
        "ᴴ": "H",
        "ᴵ": "I",
        "ᴶ": "J",
        "ᴷ": "K",
        "ᴸ": "L",
        "ᴹ": "M",
        "ᴺ": "N",
        "ᴼ": "O",
        "ᴽ": "Ȣ",
        "ᴾ": "P",
        "ᴿ": "R",
        "ᵀ": "T",
        "ᵁ": "U",
        "ᵂ": "W",
        "ᵃ": "a",
        "ᵄ": "ɐ",
        "ᵅ": "ɑ",
        "ᵆ": "ᴂ",
        "ᵇ": "b",
        "ᵈ": "d",
        "ᵉ": "e",
        "ᵊ": "ə",
        "ᵋ": "ɛ",
        "ᵌ": "ɜ",
        "ᵍ": "g",
        "ᵏ": "k",
        "ᵐ": "m",
        "ᵑ": "ŋ",
        "ᵒ": "o",
        "ᵓ": "ɔ",
        "ᵔ": "ᴖ",
        "ᵕ": "ᴗ",
        "ᵖ": "p",
        "ᵗ": "t",
        "ᵘ": "u",
        "ᵙ": "ᴝ",
        "ᵚ": "ɯ",
        "ᵛ": "v",
        "ᵜ": "ᴥ",
        "ᵝ": "β",
        "ᵞ": "γ",
        "ᵟ": "δ",
        "ᵠ": "φ",
        "ᵡ": "χ",
        "⁰": "0",
        "ⁱ": "i",
        "⁴": "4",
        "⁵": "5",
        "⁶": "6",
        "⁷": "7",
        "⁸": "8",
        "⁹": "9",
        "⁺": "+",
        "⁻": "−",
        "⁼": "=",
        "⁽": "(",
        "⁾": ")",
        "ⁿ": "n",
        "℠": "SM",
        "™": "TM",
        "㆒": "一",
        "㆓": "二",
        "㆔": "三",
        "㆕": "四",
        "㆖": "上",
        "㆗": "中",
        "㆘": "下",
        "㆙": "甲",
        "㆚": "乙",
        "㆛": "丙",
        "㆜": "丁",
        "㆝": "天",
        "㆞": "地",
        "㆟": "人",
        "ˀ": "ʔ",
        "ˁ": "ʕ",
        "ۥ": "و",
        "ۦ": "ي"
    },
    SUPERSCRIPTS_REGEXP: new RegExp("[ª²³¹ºʰʱʲʳʴʵʶʷʸˠˡˢˣˤᴬᴭᴮᴰᴱᴲᴳᴴᴵᴶᴷᴸᴹᴺᴼᴽᴾᴿᵀᵁᵂᵃᵄᵅᵆᵇᵈᵉᵊᵋᵌᵍᵏᵐᵑᵒᵓᵔᵕᵖᵗᵘᵙᵚᵛᵜᵝᵞᵟᵠᵡ⁰ⁱ⁴⁵⁶⁷⁸⁹⁺⁻⁼⁽⁾ⁿ℠™㆒㆓㆔㆕㆖㆗㆘㆙㆚㆛㆜㆝㆞㆟ˀˁۥۦ]", "g"),
    UPDATE_GROUP_CONTEXT_CONDITION: function UPDATE_GROUP_CONTEXT_CONDITION(state, str, valueTerm, token, value) {
        if (!state.opt.use_context_condition) return;
        var flags = state.tmp.group_context.tip;
        if (flags.condition) {
            if (!flags.condition.termtxt) {
                flags.condition.termtxt = str;
                flags.condition.valueTerm = valueTerm;
            }
            if (!flags.value_seen && flags.condition.test === "comma-safe-numbers-only") {
                if (value) {
                    flags.value_seen = true;
                    if (!value.match(/^[0-9]/)) {
                        state.tmp.just_did_number = false;
                    }
                }
            }
        } else {
            if (token && token.decorations.filter(o => o[0] === "@vertical-align").length > 0) {
                state.tmp.just_did_number = false;
            } else if (token && token.strings.suffix) {
                state.tmp.just_did_number = false;
            } else if (str) {
                if (str.match(/[0-9]$/)) {
                    state.tmp.just_did_number = true;
                } else {
                    state.tmp.just_did_number = false;
                }
            }
        }
    },
    EVALUATE_GROUP_CONDITION: function EVALUATE_GROUP_CONDITION(state, flags) {
        if (!state.opt.use_context_condition) return;
        var testres;
        var numbersOnly = flags.condition.test === "comma-safe-numbers-only";
        if (flags.condition.test === "empty-label") {
            testres = !flags.condition.termtxt;
        } else if (flags.condition.test === "empty-label-no-decor") {
            testres = !flags.condition.termtxt || flags.condition.termtxt.indexOf("%s") > -1;
        } else if ([ "comma-safe", "comma-safe-numbers-only" ].indexOf(flags.condition.test) > -1) {
            var locale_term = flags.condition.termtxt;
            var termStartAlpha = false;
            if (flags.condition.termtxt) {
                termStartAlpha = flags.condition.termtxt.slice(0, 1).match(CSL.ALL_ROMANESQUE_REGEXP);
            }
            var num = state.tmp.just_did_number;
            if (num) {
                if (flags.condition.valueTerm) {
                    testres = numbersOnly ? false : true;
                } else if (!locale_term) {
                    testres = true;
                } else if (termStartAlpha) {
                    testres = numbersOnly ? false : true;
                } else if ([ "always", "after-number" ].indexOf(state.opt.require_comma_on_symbol) > -1) {
                    testres = true;
                } else {
                    testres = false;
                }
            } else {
                if (flags.condition.valueTerm) {
                    testres = false;
                } else if (!locale_term) {
                    testres = false;
                } else if (termStartAlpha) {
                    testres = numbersOnly ? false : true;
                } else if (state.opt.require_comma_on_symbol === "always") {
                    testres = true;
                } else {
                    testres = false;
                }
            }
        }
        if (testres) {
            var force_suppress = false;
        } else {
            var force_suppress = true;
        }
        if (flags.condition.not) {
            force_suppress = !force_suppress;
        }
        return force_suppress;
    },
    SYS_OPTIONS: [ "prioritize_disambiguate_condition", "csl_reverse_lookup_support", "main_title_from_short_title", "uppercase_subtitles", "force_short_title_casing_alignment", "implicit_short_title", "split_container_title" ],
    TITLE_SPLIT_REGEXP: function() {
        var splits = [ "\\.\\s+", "\\!\\s+", "\\?\\s+", "\\s*::*\\s+", "\\s*—\\s*", "\\s+\\-\\s+", "\\s*\\-\\-\\-*\\s*" ];
        return {
            match: new RegExp("(" + splits.join("|") + ")", "g"),
            matchfirst: new RegExp("^(" + splits.join("|") + ")"),
            split: new RegExp("(?:" + splits.join("|") + ")")
        };
    }(),
    TITLE_SPLIT: function TITLE_SPLIT(str) {
        if (!str) {
            return str;
        }
        var m = str.match(CSL.TITLE_SPLIT_REGEXP.match);
        var lst = str.split(CSL.TITLE_SPLIT_REGEXP.split);
        for (var i = lst.length - 2; i > -1; i--) {
            lst[i] = lst[i].trim();
            if (lst[i] && lst[i].slice(-1).toLowerCase() !== lst[i].slice(-1)) {
                lst[i] = lst[i] + m[i] + lst[i + 1];
                lst = lst.slice(0, i + 1).concat(lst.slice(i + 2));
            } else {
                lst = lst.slice(0, i + 1).concat([ m[i] ]).concat(lst.slice(i + 1));
            }
        }
        return lst;
    },
    GET_COURT_CLASS: function GET_COURT_CLASS(state, Item, sortKey) {
        var cls = "";
        var authority = null;
        var country = Item.jurisdiction ? Item.jurisdiction.split(":")[0] : null;
        var classType = "court_condition_classes";
        if (sortKey) {
            classType = "court_key_classes";
        }
        if (country && Item.authority) {
            if ("string" === typeof Item.authority) {
                authority = Item.authority;
            } else {
                if (Item.authority[0] && Item.authority[0].literal) {
                    authority = Item.authority[0].literal;
                }
            }
        }
        if (authority) {
            if (this.lang && state.locale[this.lang].opts[classType] && state.locale[this.lang].opts[classType][country] && state.locale[this.lang].opts[classType][country][authority]) {
                cls = state.locale[this.lang].opts[classType][country][authority];
            } else if (state.locale[state.opt["default-locale"][0]].opts[classType] && state.locale[state.opt["default-locale"][0]].opts[classType][country] && state.locale[state.opt["default-locale"][0]].opts[classType][country][authority]) {
                cls = state.locale[state.opt["default-locale"][0]].opts[classType][country][authority];
            }
        }
        return cls;
    },
    SET_COURT_CLASSES: function SET_COURT_CLASSES(state, lang, myxml, dataObj) {
        var nodes = myxml.getNodesByName(dataObj, "court-class");
        for (var pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
            var courtclass = nodes[pos];
            var attributes = myxml.attributes(courtclass);
            var cls = attributes["@name"];
            var country = attributes["@country"];
            var courts = attributes["@courts"];
            var classType = "court_key_classes";
            if (state.registry) {
                classType = "court_condition_classes";
            }
            if (cls && country && courts) {
                courts = courts.trim().split(/\s+/);
                if (!state.locale[lang].opts[classType]) {
                    state.locale[lang].opts[classType] = {};
                }
                if (!state.locale[lang].opts[classType][country]) {
                    state.locale[lang].opts[classType][country] = {};
                }
                for (var i = 0, ilen = courts.length; i < ilen; i++) {
                    state.locale[lang].opts[classType][country][courts[i]] = cls;
                }
            }
        }
    },
    INIT_JURISDICTION_MACROS: function INIT_JURISDICTION_MACROS(state, Item, item, macroName) {
        if (Item["best-jurisdiction"]) {
            return true;
        }
        if (!state.sys.retrieveStyleModule || !CSL.MODULE_MACROS[macroName] || !Item.jurisdiction) {
            return false;
        }
        var jurisdictionList = state.getJurisdictionList(Item.jurisdiction);
        if (!state.opt.jurisdictions_seen[jurisdictionList[0]]) {
            var res = state.retrieveAllStyleModules(jurisdictionList);
            for (var jurisdiction in res) {
                var fallback = state.loadStyleModule(jurisdiction, res[jurisdiction]);
                if (fallback) {
                    if (!res[fallback]) {
                        Object.assign(res, state.retrieveAllStyleModules([ fallback ]));
                        state.loadStyleModule(fallback, res[fallback], true);
                    }
                }
            }
        }
        var jurisdictionList = state.getJurisdictionList(Item.jurisdiction);
        if (state.opt.parallel.enable) {
            if (!state.parallel) {
                state.parallel = new CSL.Parallel(state);
            }
        }
        for (var i = 0, ilen = jurisdictionList.length; i < ilen; i++) {
            var jurisdiction = jurisdictionList[i];
            if (item) {
                if (state.juris[jurisdiction] && !item["best-jurisdiction"] && state.juris[jurisdiction].types.locator) {
                    Item["best-jurisdiction"] = jurisdiction;
                }
            }
            if (state.juris[jurisdiction] && state.juris[jurisdiction].types[Item.type]) {
                Item["best-jurisdiction"] = jurisdiction;
                return true;
            }
        }
        return false;
    }
};

CSL.XmlJSON = function(dataObj) {
    this.dataObj = dataObj;
    this.institution = {
        name: "institution",
        attrs: {
            "institution-parts": "long",
            delimiter: ", "
        },
        children: [ {
            name: "institution-part",
            attrs: {
                name: "long"
            },
            children: []
        } ]
    };
};

CSL.XmlJSON.prototype.clean = function(json) {
    return json;
};

CSL.XmlJSON.prototype.getStyleId = function(myjson, styleName) {
    var tagName = "id";
    if (styleName) {
        tagName = "title";
    }
    var ret = "";
    var children = myjson.children;
    for (var i = 0, ilen = children.length; i < ilen; i++) {
        if (children[i].name === "info") {
            var grandkids = children[i].children;
            for (var j = 0, jlen = grandkids.length; j < jlen; j++) {
                if (grandkids[j].name === tagName) {
                    ret = grandkids[j].children[0];
                }
            }
        }
    }
    return ret;
};

CSL.XmlJSON.prototype.children = function(myjson) {
    if (myjson && myjson.children.length) {
        return myjson.children.slice();
    } else {
        return false;
    }
};

CSL.XmlJSON.prototype.nodename = function(myjson) {
    return myjson ? myjson.name : null;
};

CSL.XmlJSON.prototype.attributes = function(myjson) {
    var ret = {};
    for (var attrname in myjson.attrs) {
        ret["@" + attrname] = myjson.attrs[attrname];
    }
    return ret;
};

CSL.XmlJSON.prototype.content = function(myjson) {
    var ret = "";
    if (!myjson || !myjson.children) {
        return ret;
    }
    for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
        if ("string" === typeof myjson.children[i]) {
            ret += myjson.children[i];
        }
    }
    return ret;
};

CSL.XmlJSON.prototype.namespace = {};

CSL.XmlJSON.prototype.numberofnodes = function(myjson) {
    if (myjson && "number" == typeof myjson.length) {
        return myjson.length;
    } else {
        return 0;
    }
};

CSL.XmlJSON.prototype.getAttributeValue = function(myjson, name, namespace) {
    var ret = "";
    if (namespace) {
        name = namespace + ":" + name;
    }
    if (myjson) {
        if (myjson.attrs) {
            if (myjson.attrs[name]) {
                ret = myjson.attrs[name];
            } else {
                ret = "";
            }
        }
    }
    return ret;
};

CSL.XmlJSON.prototype.getNodeValue = function(myjson, name) {
    var ret = "";
    if (name) {
        for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
            if (myjson.children[i].name === name) {
                if (myjson.children[i].children.length) {
                    ret = myjson.children[i];
                } else {
                    ret = "";
                }
            }
        }
    } else if (myjson) {
        ret = myjson;
    }
    if (ret && ret.children && ret.children.length == 1 && "string" === typeof ret.children[0]) {
        ret = ret.children[0];
    }
    return ret;
};

CSL.XmlJSON.prototype.setAttributeOnNodeIdentifiedByNameAttribute = function(myjson, nodename, partname, attrname, val) {
    if (attrname.slice(0, 1) === "@") {
        attrname = attrname.slice(1);
    }
    for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
        if (myjson.children[i].name === nodename && myjson.children[i].attrs.name === partname) {
            myjson.children[i].attrs[attrname] = val;
        }
    }
};

CSL.XmlJSON.prototype.deleteNodeByNameAttribute = function(myjson, val) {
    var i, ilen;
    for (i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
        if (!myjson.children[i] || "string" === typeof myjson.children[i]) {
            continue;
        }
        if (myjson.children[i].attrs.name == val) {
            myjson.children = myjson.children.slice(0, i).concat(myjson.children.slice(i + 1));
        }
    }
};

CSL.XmlJSON.prototype.deleteAttribute = function(myjson, attrname) {
    if ("undefined" !== typeof myjson.attrs[attrname]) {
        myjson.attrs.pop(attrname);
    }
};

CSL.XmlJSON.prototype.setAttribute = function(myjson, attr, val) {
    myjson.attrs[attr] = val;
    return false;
};

CSL.XmlJSON.prototype.nodeCopy = function(myjson, clone) {
    if (!clone) {
        var clone = {};
    }
    if ("object" === typeof clone && "undefined" === typeof clone.length) {
        for (var key in myjson) {
            if ("string" === typeof myjson[key]) {
                clone[key] = myjson[key];
            } else if ("object" === typeof myjson[key]) {
                if ("undefined" === typeof myjson[key].length) {
                    clone[key] = this.nodeCopy(myjson[key], {});
                } else {
                    clone[key] = this.nodeCopy(myjson[key], []);
                }
            }
        }
    } else {
        for (var i = 0, ilen = myjson.length; i < ilen; i += 1) {
            if ("string" === typeof myjson[i]) {
                clone[i] = myjson[i];
            } else {
                clone[i] = this.nodeCopy(myjson[i], {});
            }
        }
    }
    return clone;
};

CSL.XmlJSON.prototype.getNodesByName = function(myjson, name, nameattrval, ret) {
    if (!ret) {
        var ret = [];
    }
    if (!myjson || !myjson.children) {
        return ret;
    }
    if (name === myjson.name) {
        if (nameattrval) {
            if (nameattrval === myjson.attrs.name) {
                ret.push(myjson);
            }
        } else {
            ret.push(myjson);
        }
    }
    for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
        if ("object" !== typeof myjson.children[i]) {
            continue;
        }
        this.getNodesByName(myjson.children[i], name, nameattrval, ret);
    }
    return ret;
};

CSL.XmlJSON.prototype.nodeNameIs = function(myjson, name) {
    if (typeof myjson === "undefined") {
        return false;
    }
    if (name == myjson.name) {
        return true;
    }
    return false;
};

CSL.XmlJSON.prototype.makeXml = function(myjson) {
    if ("string" === typeof myjson) {
        if (myjson.slice(0, 1) === "<") {
            myjson = this.jsonStringWalker.walkToObject(myjson);
        } else {
            myjson = JSON.parse(myjson);
        }
    }
    return myjson;
};

CSL.XmlJSON.prototype.insertChildNodeAfter = function(parent, node, pos, datejson) {
    for (var i = 0, ilen = parent.children.length; i < ilen; i += 1) {
        if (node === parent.children[i]) {
            parent.children = parent.children.slice(0, i).concat([ datejson ]).concat(parent.children.slice(i + 1));
            break;
        }
    }
    return parent;
};

CSL.XmlJSON.prototype.insertPublisherAndPlace = function(myjson) {
    if (myjson.name === "group") {
        var useme = true;
        var mustHaves = [ "publisher", "publisher-place" ];
        for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
            var haveVarname = mustHaves.indexOf(myjson.children[i].attrs.variable);
            var isText = myjson.children[i].name === "text";
            if (isText && haveVarname > -1 && !myjson.children[i].attrs.prefix && !myjson.children[i].attrs.suffix) {
                mustHaves = mustHaves.slice(0, haveVarname).concat(mustHaves.slice(haveVarname + 1));
            } else {
                useme = false;
                break;
            }
        }
        if (useme && !mustHaves.length) {
            myjson.attrs["has-publisher-and-publisher-place"] = true;
        }
    }
    for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
        if ("object" === typeof myjson.children[i]) {
            this.insertPublisherAndPlace(myjson.children[i]);
        }
    }
};

CSL.XmlJSON.prototype.isChildOfSubstitute = function(parents) {
    if (parents.length > 0) {
        var myparents = parents.slice();
        var parent = myparents.pop();
        if (parent === "substitute") {
            return true;
        } else {
            return this.isChildOfSubstitute(myparents);
        }
    }
    return false;
};

CSL.XmlJSON.prototype.addMissingNameNodes = function(myjson, parents) {
    if (!parents) {
        parents = [];
    }
    if (myjson.name === "names") {
        if (!this.isChildOfSubstitute(parents)) {
            var addName = true;
            for (var i = 0, ilen = myjson.children.length; i < ilen; i++) {
                if (myjson.children[i].name === "name") {
                    addName = false;
                    break;
                }
            }
            if (addName) {
                myjson.children = [ {
                    name: "name",
                    attrs: {},
                    children: []
                } ].concat(myjson.children);
            }
        }
    }
    parents.push(myjson.name);
    for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
        if ("object" === typeof myjson.children[i]) {
            this.addMissingNameNodes(myjson.children[i], parents);
        }
    }
    parents.pop();
};

CSL.XmlJSON.prototype.addInstitutionNodes = function(myjson) {
    var institution;
    if (myjson.name === "names") {
        var attributes = {};
        var insertPos = -1;
        for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
            if (myjson.children[i].name == "name") {
                for (var key in myjson.children[i].attrs) {
                    attributes[key] = myjson.children[i].attrs[key];
                }
                attributes.delimiter = myjson.children[i].attrs.delimiter;
                attributes.and = myjson.children[i].attrs.and;
                insertPos = i;
                for (var k = 0, klen = myjson.children[i].children.length; k < klen; k += 1) {
                    if (myjson.children[i].children[k].attrs.name !== "family") {
                        continue;
                    }
                    for (var key in myjson.children[i].children[k].attrs) {
                        attributes[key] = myjson.children[i].children[k].attrs[key];
                    }
                }
            }
            if (myjson.children[i].name == "institution") {
                insertPos = -1;
                break;
            }
        }
        if (insertPos > -1) {
            var institution = this.nodeCopy(this.institution);
            for (var i = 0, ilen = CSL.INSTITUTION_KEYS.length; i < ilen; i += 1) {
                var attrname = CSL.INSTITUTION_KEYS[i];
                if ("undefined" !== typeof attributes[attrname]) {
                    institution.children[0].attrs[attrname] = attributes[attrname];
                }
                if (attributes.delimiter) {
                    institution.attrs.delimiter = attributes.delimiter;
                }
                if (attributes.and) {
                    institution.attrs.and = attributes.and;
                }
            }
            myjson.children = myjson.children.slice(0, insertPos + 1).concat([ institution ]).concat(myjson.children.slice(insertPos + 1));
        }
    }
    for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
        if ("string" === typeof myjson.children[i]) {
            continue;
        }
        this.addInstitutionNodes(myjson.children[i]);
    }
};

CSL.XmlJSON.prototype.flagDateMacros = function(myjson) {
    for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
        if (myjson.children[i].name === "macro") {
            if (this.inspectDateMacros(myjson.children[i])) {
                myjson.children[i].attrs["macro-has-date"] = "true";
            }
        }
    }
};

CSL.XmlJSON.prototype.inspectDateMacros = function(myjson) {
    if (!myjson || !myjson.children) {
        return false;
    }
    if (myjson.name === "date") {
        return true;
    } else {
        for (var i = 0, ilen = myjson.children.length; i < ilen; i += 1) {
            if (this.inspectDateMacros(myjson.children[i])) {
                return true;
            }
        }
    }
    return false;
};

CSL.stripXmlProcessingInstruction = function(xml) {
    if (!xml) {
        return xml;
    }
    xml = xml.replace(/^<\?[^?]+\?>/, "");
    xml = xml.replace(/<!--[^>]+-->/g, "");
    xml = xml.replace(/^\s+/g, "");
    xml = xml.replace(/\s+$/g, "");
    return xml;
};

CSL.parseXml = function(str) {
    var _obj = {
        children: []
    };
    var _stack = [ _obj.children ];
    function _listifyString(str) {
        str = str.split(/(?:\r\n|\n|\r)/).join(" ").replace(/>[	 ]+</g, "><").replace(/<\!--.*?-->/g, "");
        var lst = str.split("><");
        var stylePos = null;
        for (var i = 0, ilen = lst.length; i < ilen; i++) {
            if (i > 0) {
                lst[i] = "<" + lst[i];
            }
            if (i < lst.length - 1) {
                lst[i] = lst[i] + ">";
            }
            if ("number" != typeof stylePos) {
                if (lst[i].slice(0, 7) === "<style " || lst[i].slice(0, 8) == "<locale ") {
                    stylePos = i;
                }
            }
        }
        lst = lst.slice(stylePos);
        for (var i = lst.length - 2; i > -1; i--) {
            if (lst[i].slice(1).indexOf("<") === -1) {
                var stub = lst[i].slice(0, 5);
                if (lst[i].slice(-2) !== "/>") {
                    if (stub === "<term") {
                        if (lst[i + 1].slice(0, 6) === "</term") {
                            lst[i] = lst[i] + lst[i + 1];
                            lst = lst.slice(0, i + 1).concat(lst.slice(i + 2));
                        }
                    } else if ([ "<sing", "<mult" ].indexOf(stub) > -1) {
                        if (lst[i].slice(-2) !== "/>" && lst[i + 1].slice(0, 1) === "<") {
                            lst[i] = lst[i] + lst[i + 1];
                            lst = lst.slice(0, i + 1).concat(lst.slice(i + 2));
                        }
                    }
                }
            }
        }
        return lst;
    }
    function _decodeHtmlEntities(str) {
        return str.split("&amp;").join("&").split("&quot;").join('"').split("&gt;").join(">").split("&lt;").join("<").replace(/&#([0-9]{1,6});/gi, function(match, numStr) {
            var num = parseInt(numStr, 10);
            return String.fromCharCode(num);
        }).replace(/&#x([a-f0-9]{1,6});/gi, function(match, numStr) {
            var num = parseInt(numStr, 16);
            return String.fromCharCode(num);
        });
    }
    function _getAttributes(elem) {
        var m = elem.match(/([^\'\"=	 ]+)=(?:\"[^\"]*\"|\'[^\']*\')/g);
        if (m) {
            for (var i = 0, ilen = m.length; i < ilen; i++) {
                m[i] = m[i].replace(/=.*/, "");
            }
        }
        return m;
    }
    function _getAttribute(elem, attr) {
        var rex = RegExp("^.*[\t ]+" + attr + "=(\"(?:[^\"]*)\"|'(?:[^']*)').*$");
        var m = elem.match(rex);
        return m ? m[1].slice(1, -1) : null;
    }
    function _getTagName(elem) {
        var rex = RegExp("^<([^\t />]+)");
        var m = elem.match(rex);
        return m ? m[1] : null;
    }
    function _castObjectFromOpeningTag(elem) {
        var obj = {};
        obj.name = _getTagName(elem);
        obj.attrs = {};
        var attributes = _getAttributes(elem);
        if (attributes) {
            for (var i = 0, ilen = attributes.length; i < ilen; i++) {
                var attr = {
                    name: attributes[i],
                    value: _getAttribute(elem, attributes[i])
                };
                obj.attrs[attr.name] = _decodeHtmlEntities(attr.value);
            }
        }
        obj.children = [];
        return obj;
    }
    function _extractTextFromCompositeElement(elem) {
        var m = elem.match(/^.*>([^<]*)<.*$/);
        return _decodeHtmlEntities(m[1]);
    }
    function _appendToChildren(obj) {
        _stack.slice(-1)[0].push(obj);
    }
    function _extendStackWithNewChildren(obj) {
        _stack.push(obj.children);
    }
    function processElement(elem) {
        var obj;
        if (elem.slice(1).indexOf("<") > -1) {
            var tag = elem.slice(0, elem.indexOf(">") + 1);
            obj = _castObjectFromOpeningTag(tag);
            obj.children = [ _extractTextFromCompositeElement(elem) ];
            _appendToChildren(obj);
        } else if (elem.slice(-2) === "/>") {
            obj = _castObjectFromOpeningTag(elem);
            if (_getTagName(elem) === "term") {
                obj.children.push("");
            }
            _appendToChildren(obj);
        } else if (elem.slice(0, 2) === "</") {
            _stack.pop();
        } else {
            obj = _castObjectFromOpeningTag(elem);
            _appendToChildren(obj);
            _extendStackWithNewChildren(obj);
        }
    }
    var lst = _listifyString(str);
    for (var i = 0, ilen = lst.length; i < ilen; i++) {
        var elem = lst[i];
        processElement(elem);
    }
    return _obj.children[0];
};

CSL.XmlDOM = function(dataObj) {
    this.dataObj = dataObj;
    if ("undefined" == typeof DOMParser) {
        DOMParser = function DOMParser() {};
        DOMParser.prototype.parseFromString = function(str, contentType) {
            if ("undefined" != typeof ActiveXObject) {
                var xmldata = new ActiveXObject("MSXML.DomDocument");
                xmldata.async = false;
                xmldata.loadXML(str);
                return xmldata;
            } else if ("undefined" != typeof XMLHttpRequest) {
                var xmldata = new XMLHttpRequest;
                if (!contentType) {
                    contentType = "text/xml";
                }
                xmldata.open("GET", "data:" + contentType + ";charset=utf-8," + encodeURIComponent(str), false);
                if (xmldata.overrideMimeType) {
                    xmldata.overrideMimeType(contentType);
                }
                xmldata.send(null);
                return xmldata.responseXML;
            } else if ("undefined" != typeof marknote) {
                var parser = new marknote.Parser;
                return parser.parse(str);
            }
        };
        this.hasAttributes = function(node) {
            var ret;
            if (node.attributes && node.attributes.length) {
                ret = true;
            } else {
                ret = false;
            }
            return ret;
        };
    } else {
        this.hasAttributes = function(node) {
            var ret;
            if (node.attributes && node.attributes.length) {
                ret = true;
            } else {
                ret = false;
            }
            return ret;
        };
    }
    this.importNode = function(doc, srcElement) {
        var ret;
        if ("undefined" == typeof doc.importNode) {
            ret = this._importNode(doc, srcElement, true);
        } else {
            ret = doc.importNode(srcElement, true);
        }
        return ret;
    };
    this._importNode = function(doc, node, allChildren) {
        switch (node.nodeType) {
          case 1:
            var newNode = doc.createElement(node.nodeName);
            if (node.attributes && node.attributes.length > 0) for (var i = 0, il = node.attributes.length; i < il; ) newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i++].nodeName));
            if (allChildren && node.childNodes && node.childNodes.length > 0) for (var i = 0, il = node.childNodes.length; i < il; ) newNode.appendChild(this._importNode(doc, node.childNodes[i++], allChildren));
            return newNode;
        }
    };
    this.parser = new DOMParser;
    var str = '<docco><institution institution-parts="long" delimiter=", " substitute-use-first="1" use-last="1"><institution-part name="long"/></institution></docco>';
    var inst_doc = this.parser.parseFromString(str, "text/xml");
    var inst_node = inst_doc.getElementsByTagName("institution");
    this.institution = inst_node.item(0);
    var inst_part_node = inst_doc.getElementsByTagName("institution-part");
    this.institutionpart = inst_part_node.item(0);
    this.ns = "http://purl.org/net/xbiblio/csl";
};

CSL.XmlDOM.prototype.clean = function(xml) {
    xml = xml.replace(/<\?[^?]+\?>/g, "");
    xml = xml.replace(/<![^>]+>/g, "");
    xml = xml.replace(/^\s+/, "");
    xml = xml.replace(/\s+$/, "");
    xml = xml.replace(/^\n*/, "");
    return xml;
};

CSL.XmlDOM.prototype.getStyleId = function(myxml, styleName) {
    var text = "";
    var tagName = "id";
    if (styleName) {
        tagName = "title";
    }
    var node = myxml.getElementsByTagName(tagName);
    if (node && node.length) {
        node = node.item(0);
    }
    if (node) {
        text = node.textContent;
    }
    if (!text) {
        text = node.innerText;
    }
    if (!text) {
        text = node.innerHTML;
    }
    return text;
};

CSL.XmlDOM.prototype.children = function(myxml) {
    var children, pos, len, ret;
    if (myxml) {
        ret = [];
        children = myxml.childNodes;
        for (pos = 0, len = children.length; pos < len; pos += 1) {
            if (children[pos].nodeName != "#text") {
                ret.push(children[pos]);
            }
        }
        return ret;
    } else {
        return [];
    }
};

CSL.XmlDOM.prototype.nodename = function(myxml) {
    var ret = myxml.nodeName;
    return ret;
};

CSL.XmlDOM.prototype.attributes = function(myxml) {
    var ret, attrs, attr, pos, len;
    ret = new Object;
    if (myxml && this.hasAttributes(myxml)) {
        attrs = myxml.attributes;
        for (pos = 0, len = attrs.length; pos < len; pos += 1) {
            attr = attrs[pos];
            ret["@" + attr.name] = attr.value;
        }
    }
    return ret;
};

CSL.XmlDOM.prototype.content = function(myxml) {
    var ret;
    if ("undefined" != typeof myxml.textContent) {
        ret = myxml.textContent;
    } else if ("undefined" != typeof myxml.innerText) {
        ret = myxml.innerText;
    } else {
        ret = myxml.txt;
    }
    return ret;
};

CSL.XmlDOM.prototype.namespace = {
    xml: "http://www.w3.org/XML/1998/namespace"
};

CSL.XmlDOM.prototype.numberofnodes = function(myxml) {
    if (myxml) {
        return myxml.length;
    } else {
        return 0;
    }
};

CSL.XmlDOM.prototype.getAttributeName = function(attr) {
    var ret = attr.name;
    return ret;
};

CSL.XmlDOM.prototype.getAttributeValue = function(myxml, name, namespace) {
    var ret = "";
    if (namespace) {
        name = namespace + ":" + name;
    }
    if (myxml && this.hasAttributes(myxml) && myxml.getAttribute(name)) {
        ret = myxml.getAttribute(name);
    }
    return ret;
};

CSL.XmlDOM.prototype.getNodeValue = function(myxml, name) {
    var ret = null;
    if (name) {
        var vals = myxml.getElementsByTagName(name);
        if (vals.length > 0) {
            if ("undefined" != typeof vals[0].textContent) {
                ret = vals[0].textContent;
            } else if ("undefined" != typeof vals[0].innerText) {
                ret = vals[0].innerText;
            } else {
                ret = vals[0].text;
            }
        }
    }
    if (ret === null && myxml && myxml.childNodes && (myxml.childNodes.length == 0 || myxml.childNodes.length == 1 && myxml.firstChild.nodeName == "#text")) {
        if ("undefined" != typeof myxml.textContent) {
            ret = myxml.textContent;
        } else if ("undefined" != typeof myxml.innerText) {
            ret = myxml.innerText;
        } else {
            ret = myxml.text;
        }
    }
    if (ret === null) {
        ret = myxml;
    }
    return ret;
};

CSL.XmlDOM.prototype.setAttributeOnNodeIdentifiedByNameAttribute = function(myxml, nodename, partname, attrname, val) {
    var pos, len, nodes, node;
    if (attrname.slice(0, 1) === "@") {
        attrname = attrname.slice(1);
    }
    nodes = myxml.getElementsByTagName(nodename);
    for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        node = nodes[pos];
        if (node.getAttribute("name") != partname) {
            continue;
        }
        node.setAttribute(attrname, val);
    }
};

CSL.XmlDOM.prototype.deleteNodeByNameAttribute = function(myxml, val) {
    var pos, len, node, nodes;
    nodes = myxml.childNodes;
    for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        node = nodes[pos];
        if (!node || node.nodeType == node.TEXT_NODE) {
            continue;
        }
        if (this.hasAttributes(node) && node.getAttribute("name") == val) {
            myxml.removeChild(nodes[pos]);
        }
    }
};

CSL.XmlDOM.prototype.deleteAttribute = function(myxml, attr) {
    myxml.removeAttribute(attr);
};

CSL.XmlDOM.prototype.setAttribute = function(myxml, attr, val) {
    if (!myxml.ownerDocument) {
        myxml = myxml.firstChild;
    }
    if ([ "function", "unknown" ].indexOf(typeof myxml.setAttribute) > -1) {
        myxml.setAttribute(attr, val);
    }
    return false;
};

CSL.XmlDOM.prototype.nodeCopy = function(myxml) {
    var cloned_node = myxml.cloneNode(true);
    return cloned_node;
};

CSL.XmlDOM.prototype.getNodesByName = function(myxml, name, nameattrval) {
    var ret, nodes, node, pos, len;
    ret = [];
    nodes = myxml.getElementsByTagName(name);
    for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        node = nodes.item(pos);
        if (nameattrval && !(this.hasAttributes(node) && node.getAttribute("name") == nameattrval)) {
            continue;
        }
        ret.push(node);
    }
    return ret;
};

CSL.XmlDOM.prototype.nodeNameIs = function(myxml, name) {
    if (name == myxml.nodeName) {
        return true;
    }
    return false;
};

CSL.XmlDOM.prototype.makeXml = function(myxml) {
    if (!myxml) {
        myxml = "<docco><bogus/></docco>";
    }
    myxml = myxml.replace(/\s*<\?[^>]*\?>\s*\n*/g, "");
    var nodetree = this.parser.parseFromString(myxml, "application/xml");
    return nodetree.firstChild;
};

CSL.XmlDOM.prototype.insertChildNodeAfter = function(parent, node, pos, datexml) {
    var myxml;
    myxml = this.importNode(node.ownerDocument, datexml);
    parent.replaceChild(myxml, node);
    return parent;
};

CSL.XmlDOM.prototype.insertPublisherAndPlace = function(myxml) {
    var group = myxml.getElementsByTagName("group");
    for (var i = 0, ilen = group.length; i < ilen; i += 1) {
        var node = group.item(i);
        var skippers = [];
        for (var j = 0, jlen = node.childNodes.length; j < jlen; j += 1) {
            if (node.childNodes.item(j).nodeType !== 1) {
                skippers.push(j);
            }
        }
        if (node.childNodes.length - skippers.length === 2) {
            var twovars = [];
            for (var j = 0, jlen = 2; j < jlen; j += 1) {
                if (skippers.indexOf(j) > -1) {
                    continue;
                }
                var child = node.childNodes.item(j);
                var subskippers = [];
                for (var k = 0, klen = child.childNodes.length; k < klen; k += 1) {
                    if (child.childNodes.item(k).nodeType !== 1) {
                        subskippers.push(k);
                    }
                }
                if (child.childNodes.length - subskippers.length === 0) {
                    twovars.push(child.getAttribute("variable"));
                    if (child.getAttribute("suffix") || child.getAttribute("prefix")) {
                        twovars = [];
                        break;
                    }
                }
            }
            if (twovars.indexOf("publisher") > -1 && twovars.indexOf("publisher-place") > -1) {
                node.setAttribute("has-publisher-and-publisher-place", true);
            }
        }
    }
};

CSL.XmlDOM.prototype.isChildOfSubstitute = function(node) {
    if (node.parentNode) {
        if (node.parentNode.tagName.toLowerCase() === "substitute") {
            return true;
        } else {
            return this.isChildOfSubstitute(node.parentNode);
        }
    }
    return false;
};

CSL.XmlDOM.prototype.addMissingNameNodes = function(myxml) {
    var nameslist = myxml.getElementsByTagName("names");
    for (var i = 0, ilen = nameslist.length; i < ilen; i += 1) {
        var names = nameslist.item(i);
        var namelist = names.getElementsByTagName("name");
        if ((!namelist || namelist.length === 0) && !this.isChildOfSubstitute(names)) {
            var doc = names.ownerDocument;
            var name = doc.createElement("name");
            names.appendChild(name);
        }
    }
};

CSL.XmlDOM.prototype.addInstitutionNodes = function(myxml) {
    var names, thenames, institution, theinstitution, theinstitutionpart, name, thename, pos, len;
    names = myxml.getElementsByTagName("names");
    for (pos = 0, len = names.length; pos < len; pos += 1) {
        thenames = names.item(pos);
        name = thenames.getElementsByTagName("name");
        if (name.length == 0) {
            continue;
        }
        institution = thenames.getElementsByTagName("institution");
        if (institution.length == 0) {
            theinstitution = this.importNode(myxml.ownerDocument, this.institution);
            theinstitutionpart = theinstitution.getElementsByTagName("institution-part").item(0);
            thename = name.item(0);
            thenames.insertBefore(theinstitution, thename.nextSibling);
            for (var j = 0, jlen = CSL.INSTITUTION_KEYS.length; j < jlen; j += 1) {
                var attrname = CSL.INSTITUTION_KEYS[j];
                var attrval = thename.getAttribute(attrname);
                if (attrval) {
                    theinstitutionpart.setAttribute(attrname, attrval);
                }
            }
            var nameparts = thename.getElementsByTagName("name-part");
            for (var j = 0, jlen = nameparts.length; j < jlen; j += 1) {
                if ("family" === nameparts[j].getAttribute("name")) {
                    for (var k = 0, klen = CSL.INSTITUTION_KEYS.length; k < klen; k += 1) {
                        var attrname = CSL.INSTITUTION_KEYS[k];
                        var attrval = nameparts[j].getAttribute(attrname);
                        if (attrval) {
                            theinstitutionpart.setAttribute(attrname, attrval);
                        }
                    }
                }
            }
        }
    }
};

CSL.XmlDOM.prototype.flagDateMacros = function(myxml) {
    var pos, len, thenode, thedate;
    var nodes = myxml.getElementsByTagName("macro");
    for (pos = 0, len = nodes.length; pos < len; pos += 1) {
        thenode = nodes.item(pos);
        thedate = thenode.getElementsByTagName("date");
        if (thedate.length) {
            thenode.setAttribute("macro-has-date", "true");
        }
    }
};

CSL.setupXml = function(xmlObject) {
    var dataObj = {};
    var parser = null;
    if ("undefined" !== typeof xmlObject) {
        if ("string" === typeof xmlObject) {
            xmlObject = xmlObject.replace("^\ufeff", "").replace(/^\s+/, "");
            if (xmlObject.slice(0, 1) === "<") {
                dataObj = CSL.parseXml(xmlObject);
            } else {
                dataObj = JSON.parse(xmlObject);
            }
            parser = new CSL.XmlJSON(dataObj);
        } else if ("undefined" !== typeof xmlObject.getAttribute) {
            parser = new CSL.XmlDOM(xmlObject);
        } else if ("undefined" !== typeof xmlObject.toXMLString) {
            parser = new CSL.XmlE4X(xmlObject);
        } else {
            parser = new CSL.XmlJSON(xmlObject);
        }
    } else {
        CSL.error("unable to parse XML input");
    }
    if (!parser) {
        CSL.error("citeproc-js error: unable to parse CSL style or locale object");
    }
    return parser;
};

CSL.getSortCompare = function(default_locale) {
    if (CSL.stringCompare) {
        return CSL.stringCompare;
    }
    var me = this;
    var strcmp;
    var strcmp_opts = {
        sensitivity: "base",
        ignorePunctuation: true,
        numeric: true
    };
    if (!default_locale) {
        default_locale = "en-US";
    }
    strcmp = function strcmp(a, b) {
        return CSL.toLocaleLowerCase.call(me, a).localeCompare(CSL.toLocaleLowerCase.call(me, b), default_locale, strcmp_opts);
    };
    var stripPunct = function stripPunct(str) {
        return str.replace(/^[\[\]\'\"]*/g, "");
    };
    var getBracketPreSort = function getBracketPreSort() {
        if (!strcmp("[x", "x")) {
            return false;
        } else {
            return function(a, b) {
                return strcmp(stripPunct(a), stripPunct(b));
            };
        }
    };
    var bracketPreSort = getBracketPreSort();
    var sortCompare = function sortCompare(a, b) {
        if (bracketPreSort) {
            return bracketPreSort(a, b);
        } else {
            return strcmp(a, b);
        }
    };
    return sortCompare;
};

CSL.ambigConfigDiff = function(a, b) {
    var pos, len, ppos, llen;
    if (a.names.length !== b.names.length) {
        return 1;
    } else {
        for (pos = 0, len = a.names.length; pos < len; pos += 1) {
            if (a.names[pos] !== b.names[pos]) {
                return 1;
            } else {
                for (ppos = 0, llen = a.givens[pos]; ppos < llen; ppos += 1) {
                    if (a.givens[pos][ppos] !== b.givens[pos][ppos]) {
                        return 1;
                    }
                }
            }
        }
    }
    if (a.disambiguate != b.disambiguate) {
        return 1;
    }
    if (a.year_suffix !== b.year_suffix) {
        return 1;
    }
    return 0;
};

CSL.cloneAmbigConfig = function(config, oldconfig) {
    var i, ilen, j, jlen, param;
    var ret = {};
    ret.names = [];
    ret.givens = [];
    ret.year_suffix = false;
    ret.disambiguate = false;
    for (i = 0, ilen = config.names.length; i < ilen; i += 1) {
        param = config.names[i];
        ret.names[i] = param;
    }
    for (i = 0, ilen = config.givens.length; i < ilen; i += 1) {
        param = [];
        for (j = 0, jlen = config.givens[i].length; j < jlen; j += 1) {
            param.push(config.givens[i][j]);
        }
        ret.givens.push(param);
    }
    if (oldconfig) {
        ret.year_suffix = oldconfig.year_suffix;
        ret.disambiguate = oldconfig.disambiguate;
    } else {
        ret.year_suffix = config.year_suffix;
        ret.disambiguate = config.disambiguate;
    }
    return ret;
};

CSL.getAmbigConfig = function() {
    var config, ret;
    config = this.tmp.disambig_request;
    if (!config) {
        config = this.tmp.disambig_settings;
    }
    var ret = CSL.cloneAmbigConfig(config);
    return ret;
};

CSL.getMaxVals = function() {
    return this.tmp.names_max.mystack.slice();
};

CSL.getMinVal = function() {
    return this.tmp["et-al-min"];
};

CSL.tokenExec = function(token, Item, item) {
    var next, maybenext, exec, debug;
    debug = false;
    next = token.next;
    maybenext = false;
    var record = function record(result) {
        if (result) {
            this.tmp.jump.replace("succeed");
            return token.succeed;
        } else {
            this.tmp.jump.replace("fail");
            return token.fail;
        }
    };
    if (token.test) {
        next = record.call(this, token.test(Item, item));
    }
    for (var i = 0, ilen = token.execs.length; i < ilen; i++) {
        exec = token.execs[i];
        maybenext = exec.call(token, this, Item, item);
        if (maybenext) {
            next = maybenext;
        }
    }
    if (debug) {
        CSL.debug(token.name + " (" + token.tokentype + ") ---\x3e done");
    }
    return next;
};

CSL.expandMacro = function(macro_key_token, target) {
    var mkey, macro_nodes, end_of_macro, func;
    mkey = macro_key_token.postponed_macro;
    var sort_direction = macro_key_token.strings.sort_direction;
    macro_key_token = new CSL.Token("group", CSL.START);
    var hasDate = false;
    var macroid = false;
    macro_nodes = this.cslXml.getNodesByName(this.cslXml.dataObj, "macro", mkey);
    if (macro_nodes.length) {
        macroid = this.cslXml.getAttributeValue(macro_nodes[0], "cslid");
        hasDate = this.cslXml.getAttributeValue(macro_nodes[0], "macro-has-date");
    }
    if (hasDate) {
        mkey = mkey + "@" + this.build.current_default_locale;
        func = function func(state) {
            if (state.tmp.extension) {
                state.tmp["doing-macro-with-date"] = true;
            }
        };
        macro_key_token.execs.push(func);
    }
    if (this.build.macro_stack.indexOf(mkey) > -1) {
        CSL.error('CSL processor error: call to macro "' + mkey + '" would cause an infinite loop');
    } else {
        this.build.macro_stack.push(mkey);
    }
    macro_key_token.cslid = macroid;
    if (CSL.MODULE_MACROS[mkey]) {
        macro_key_token.juris = mkey;
        this.opt.update_mode = CSL.POSITION;
    }
    CSL.Node.group.build.call(macro_key_token, this, target, true);
    if (!this.cslXml.getNodeValue(macro_nodes)) {
        CSL.error('CSL style error: undefined macro "' + mkey + '"');
    }
    var mytarget = CSL.getMacroTarget.call(this, mkey);
    if (mytarget) {
        CSL.buildMacro.call(this, mytarget, macro_nodes);
        CSL.configureMacro.call(this, mytarget);
    }
    if (!this.build.extension) {
        var func = function(macro_name) {
            return function(state, Item, item) {
                var next = 0;
                while (next < state.macros[macro_name].length) {
                    next = CSL.tokenExec.call(state, state.macros[macro_name][next], Item, item);
                }
            };
        }(mkey);
        var text_node = new CSL.Token("text", CSL.SINGLETON);
        text_node.execs.push(func);
        target.push(text_node);
    }
    end_of_macro = new CSL.Token("group", CSL.END);
    end_of_macro.strings.sort_direction = sort_direction;
    if (hasDate) {
        func = function func(state) {
            if (state.tmp.extension) {
                state.tmp["doing-macro-with-date"] = false;
            }
        };
        end_of_macro.execs.push(func);
    }
    if (macro_key_token.juris) {
        end_of_macro.juris = mkey;
    }
    CSL.Node.group.build.call(end_of_macro, this, target, true);
    this.build.macro_stack.pop();
};

CSL.getMacroTarget = function(mkey) {
    var mytarget = false;
    if (this.build.extension) {
        mytarget = this[this.build.root + this.build.extension].tokens;
    } else if (!this.macros[mkey]) {
        mytarget = [];
        this.macros[mkey] = mytarget;
    }
    return mytarget;
};

CSL.buildMacro = function(mytarget, macro_nodes) {
    var builder = CSL.makeBuilder(this, mytarget);
    var mynode;
    if ("undefined" === typeof macro_nodes.length) {
        mynode = macro_nodes;
    } else {
        mynode = macro_nodes[0];
    }
    builder(mynode);
};

CSL.configureMacro = function(mytarget) {
    if (!this.build.extension) {
        this.configureTokenList(mytarget);
    }
};

CSL.XmlToToken = function(state, tokentype, explicitTarget, var_stack) {
    var name, txt, attributes, decorations, token, key, target;
    name = state.cslXml.nodename(this);
    if (state.build.skip && state.build.skip !== name) {
        return;
    }
    if (!name) {
        txt = state.cslXml.content(this);
        if (txt) {
            state.build.text = txt;
        }
        return;
    }
    if (!CSL.Node[state.cslXml.nodename(this)]) {
        CSL.error('Undefined node name "' + name + '".');
    }
    attributes = state.cslXml.attributes(this);
    decorations = CSL.setDecorations.call(this, state, attributes);
    token = new CSL.Token(name, tokentype);
    if (tokentype !== CSL.END || name === "if" || name === "else-if" || name === "layout") {
        for (var key in attributes) {
            if (attributes.hasOwnProperty(key)) {
                if (tokentype === CSL.END && key !== "@language" && key !== "@locale") {
                    continue;
                }
                if (attributes.hasOwnProperty(key)) {
                    if (CSL.Attributes[key]) {
                        try {
                            CSL.Attributes[key].call(token, state, "" + attributes[key]);
                        } catch (e) {
                            CSL.error(key + " attribute: " + e);
                        }
                    } else {
                        CSL.debug('warning: undefined attribute "' + key + '" in style');
                    }
                }
            }
        }
        token.decorations = decorations;
        if (CSL.DATE_VARIABLES.indexOf(attributes["@variable"]) > -1) {
            var_stack.push(token.variables);
        }
    } else if (tokentype === CSL.END && attributes["@variable"]) {
        token.hasVariable = true;
        if (CSL.DATE_VARIABLES.indexOf(attributes["@variable"]) > -1) {
            token.variables = var_stack.pop();
        }
    }
    if (explicitTarget) {
        target = explicitTarget;
    } else {
        target = state[state.build.area].tokens;
    }
    CSL.Node[name].build.call(token, state, target, true);
};

CSL.DateParser = function() {
    var epochPairs = [ [ "明治", 1867 ], [ "大正", 1911 ], [ "昭和", 1925 ], [ "平成", 1988 ] ];
    for (var i = 0, ilen = epochPairs.length; i < ilen; i++) {
        epochPairs[i][0];
        var val = epochPairs[i][1];
    }
    var epochMatchStrings = [];
    var epochMap = {};
    for (var i = 0, ilen = epochPairs.length; i < ilen; i++) {
        var pair = epochPairs[i];
        var val = pair[0];
        epochMatchStrings.push(val);
        epochMap[pair[0]] = pair[1];
    }
    var epochMatchString = epochMatchStrings.join("|");
    var epochSplitter = new RegExp("(?:" + epochMatchString + ")(?:[0-9]+)");
    var epochMatcher = new RegExp("(?:" + epochMatchString + ")(?:[0-9]+)", "g");
    var kanjiMonthDay = /(\u6708|\u5E74)/g;
    var kanjiYear = /\u65E5/g;
    var kanjiRange = /\u301c/g;
    var yearLast = "(?:[?0-9]{1,2}%%NUMD%%){0,2}[?0-9]{4}(?![0-9])";
    var yearFirst = "[?0-9]{4}(?:%%NUMD%%[?0-9]{1,2}){0,2}(?![0-9])";
    var numberVal = "[?0-9]{1,3}";
    var rangeSeparator = "[%%DATED%%]";
    var fuzzyChar = "[?~]";
    var chars = "[^-/~?0-9]+";
    var rexString = "(" + yearFirst + "|" + yearLast + "|" + numberVal + "|" + rangeSeparator + "|" + fuzzyChar + "|" + chars + ")";
    var rexDash = new RegExp(rexString.replace(/%%NUMD%%/g, "-").replace(/%%DATED%%/g, "-"));
    var rexDashSlash = new RegExp(rexString.replace(/%%NUMD%%/g, "-").replace(/%%DATED%%/g, "/"));
    var rexSlashDash = new RegExp(rexString.replace(/%%NUMD%%/g, "/").replace(/%%DATED%%/g, "-"));
    var monthString = "january february march april may june july august september october november december spring summer fall winter spring summer";
    this.monthStrings = monthString.split(" ");
    this.setOrderDayMonth = function() {
        this.monthGuess = 1;
        this.dayGuess = 0;
    };
    this.setOrderMonthDay = function() {
        this.monthGuess = 0;
        this.dayGuess = 1;
    };
    this.resetDateParserMonths = function() {
        this.monthSets = [];
        for (var i = 0, ilen = this.monthStrings.length; i < ilen; i++) {
            this.monthSets.push([ this.monthStrings[i] ]);
        }
        this.monthAbbrevs = [];
        for (var i = 0, ilen = this.monthSets.length; i < ilen; i++) {
            this.monthAbbrevs.push([]);
            for (var j = 0, jlen = this.monthSets[i].length; j < jlen; j++) {
                this.monthAbbrevs[i].push(this.monthSets[i][0].slice(0, 3));
            }
        }
        this.monthRexes = [];
        for (var i = 0, ilen = this.monthAbbrevs.length; i < ilen; i++) {
            this.monthRexes.push(new RegExp("(?:" + this.monthAbbrevs[i].join("|") + ")"));
        }
    };
    this.addDateParserMonths = function(lst) {
        if ("string" === typeof lst) {
            lst = lst.split(/\s+/);
        }
        if (lst.length !== 12 && lst.length !== 16) {
            CSL.debug("month [+season] list of " + lst.length + ", expected 12 or 16. Ignoring.");
            return;
        }
        for (var i = 0, ilen = lst.length; i < ilen; i++) {
            var abbrevLength = null;
            var skip = false;
            var insert = 3;
            var extendedSets = {};
            for (var j = 0, jlen = this.monthAbbrevs.length; j < jlen; j++) {
                extendedSets[j] = {};
                if (j === i) {
                    for (var k = 0, klen = this.monthAbbrevs[i].length; k < klen; k++) {
                        if (this.monthAbbrevs[i][k] === lst[i].slice(0, this.monthAbbrevs[i][k].length)) {
                            skip = true;
                            break;
                        }
                    }
                } else {
                    for (var k = 0, klen = this.monthAbbrevs[j].length; k < klen; k++) {
                        abbrevLength = this.monthAbbrevs[j][k].length;
                        if (this.monthAbbrevs[j][k] === lst[i].slice(0, abbrevLength)) {
                            while (this.monthSets[j][k].slice(0, abbrevLength) === lst[i].slice(0, abbrevLength)) {
                                if (abbrevLength > lst[i].length || abbrevLength > this.monthSets[j][k].length) {
                                    CSL.debug("unable to disambiguate month string in date parser: " + lst[i]);
                                    break;
                                } else {
                                    abbrevLength += 1;
                                }
                            }
                            insert = abbrevLength;
                            extendedSets[j][k] = abbrevLength;
                        }
                    }
                }
                for (var jKey in extendedSets) {
                    for (var kKey in extendedSets[jKey]) {
                        abbrevLength = extendedSets[jKey][kKey];
                        jKey = parseInt(jKey, 10);
                        kKey = parseInt(kKey, 10);
                        this.monthAbbrevs[jKey][kKey] = this.monthSets[jKey][kKey].slice(0, abbrevLength);
                    }
                }
            }
            if (!skip) {
                this.monthSets[i].push(lst[i]);
                this.monthAbbrevs[i].push(lst[i].slice(0, insert));
            }
        }
        this.monthRexes = [];
        this.monthRexStrs = [];
        for (var i = 0, ilen = this.monthAbbrevs.length; i < ilen; i++) {
            this.monthRexes.push(new RegExp("^(?:" + this.monthAbbrevs[i].join("|") + ")"));
            this.monthRexStrs.push("^(?:" + this.monthAbbrevs[i].join("|") + ")");
        }
        if (this.monthAbbrevs.length === 18) {
            for (var i = 12, ilen = 14; i < ilen; i++) {
                this.monthRexes[i + 4] = new RegExp("^(?:" + this.monthAbbrevs[i].join("|") + ")");
                this.monthRexStrs[i + 4] = "^(?:" + this.monthAbbrevs[i].join("|") + ")";
            }
        }
    };
    this.convertDateObjectToArray = function(thedate) {
        thedate["date-parts"] = [];
        thedate["date-parts"].push([]);
        var slicelen = 0;
        var part;
        for (var i = 0, ilen = 3; i < ilen; i++) {
            part = [ "year", "month", "day" ][i];
            if (!thedate[part]) {
                break;
            }
            slicelen += 1;
            thedate["date-parts"][0].push(thedate[part]);
            delete thedate[part];
        }
        thedate["date-parts"].push([]);
        for (var i = 0, ilen = slicelen; i < ilen; i++) {
            part = [ "year_end", "month_end", "day_end" ][i];
            if (!thedate[part]) {
                break;
            }
            thedate["date-parts"][1].push(thedate[part]);
            delete thedate[part];
        }
        if (thedate["date-parts"][0].length !== thedate["date-parts"][1].length) {
            thedate["date-parts"].pop();
        }
        return thedate;
    };
    this.convertDateObjectToString = function(thedate) {
        var ret = [];
        for (var i = 0, ilen = 3; i < ilen; i += 1) {
            if (thedate[CSL.DATE_PARTS_ALL[i]]) {
                ret.push(thedate[CSL.DATE_PARTS_ALL[i]]);
            } else {
                break;
            }
        }
        return ret.join("-");
    };
    this._parseNumericDate = function(ret, delim, suff, txt) {
        if (!suff) {
            suff = "";
        }
        var lst = txt.split(delim);
        for (var i = 0, ilen = lst.length; i < ilen; i++) {
            if (lst[i].length === 4) {
                ret["year" + suff] = lst[i].replace(/^0*/, "");
                if (!i) {
                    lst = lst.slice(1);
                } else {
                    lst = lst.slice(0, i);
                }
                break;
            }
        }
        for (var i = 0, ilen = lst.length; i < ilen; i++) {
            lst[i] = parseInt(lst[i], 10);
        }
        if (lst.length === 1 || lst.length === 2 && !lst[1]) {
            var month = lst[0];
            if (month) {
                ret["month" + suff] = "" + lst[0];
            }
        } else if (lst.length === 2) {
            if (lst[this.monthGuess] > 12) {
                var month = lst[this.dayGuess];
                var day = lst[this.monthGuess];
                if (month) {
                    ret["month" + suff] = "" + month;
                    if (day) {
                        ret["day" + suff] = "" + day;
                    }
                }
            } else {
                var month = lst[this.monthGuess];
                var day = lst[this.dayGuess];
                if (month) {
                    ret["month" + suff] = "" + month;
                    if (day) {
                        ret["day" + suff] = "" + day;
                    }
                }
            }
        }
    };
    this.parseDateToObject = function(txt) {
        var orig = txt;
        var slashPos = -1;
        var dashPos = -1;
        var yearIsNegative = false;
        var lst;
        if (txt) {
            txt = txt.replace(/^(.*[0-9])T[0-9].*/, "$1");
            if (txt.slice(0, 1) === "-") {
                yearIsNegative = true;
                txt = txt.slice(1);
            }
            if (txt.match(/^[0-9]{1,3}$/)) {
                while (txt.length < 4) {
                    txt = "0" + txt;
                }
            }
            txt = "" + txt;
            txt = txt.replace(/\s*[0-9]{2}:[0-9]{2}(?::[0-9]+)/, "");
            var m = txt.match(kanjiMonthDay);
            if (m) {
                txt = txt.replace(/\s+/g, "");
                txt = txt.replace(kanjiYear, "");
                txt = txt.replace(kanjiMonthDay, "-");
                txt = txt.replace(kanjiRange, "/");
                txt = txt.replace(/\-\//g, "/");
                txt = txt.replace(/-$/g, "");
                var slst = txt.split(epochSplitter);
                lst = [];
                var mm = txt.match(epochMatcher);
                if (mm) {
                    var mmx = [];
                    for (var i = 0, ilen = mm.length; i < ilen; i++) {
                        mmx = mmx.concat(mm[i].match(/([^0-9]+)([0-9]+)/).slice(1));
                    }
                    for (var i = 0, ilen = slst.length; i < ilen; i++) {
                        lst.push(slst[i]);
                        if (i !== ilen - 1) {
                            var mmpos = i * 2;
                            lst.push(mmx[mmpos]);
                            lst.push(mmx[mmpos + 1]);
                        }
                    }
                } else {
                    lst = slst;
                }
                for (var i = 1, ilen = lst.length; i < ilen; i += 3) {
                    lst[i + 1] = epochMap[lst[i]] + parseInt(lst[i + 1], 10);
                    lst[i] = "";
                }
                txt = lst.join("");
                txt = txt.replace(/\s*-\s*$/, "").replace(/\s*-\s*\//, "/");
                txt = txt.replace(/\.\s*$/, "");
                txt = txt.replace(/\.(?! )/, "");
                slashPos = txt.indexOf("/");
                dashPos = txt.indexOf("-");
            }
        }
        txt = txt.replace(/([A-Za-z])\./g, "$1");
        var number = "";
        var note = "";
        var thedate = {};
        var rangeDelim;
        var dateDelim;
        if (txt.slice(0, 1) === '"' && txt.slice(-1) === '"') {
            thedate.literal = txt.slice(1, -1);
            return thedate;
        }
        if (slashPos > -1 && dashPos > -1) {
            var slashCount = txt.split("/");
            if (slashCount.length > 3) {
                rangeDelim = "-";
                txt = txt.replace(/\_/g, "-");
                dateDelim = "/";
                lst = txt.split(rexSlashDash);
            } else {
                rangeDelim = "/";
                txt = txt.replace(/\_/g, "/");
                dateDelim = "-";
                lst = txt.split(rexDashSlash);
            }
        } else {
            txt = txt.replace(/\//g, "-");
            txt = txt.replace(/\_/g, "-");
            rangeDelim = "-";
            dateDelim = "-";
            lst = txt.split(rexDash);
        }
        var ret = [];
        for (var i = 0, ilen = lst.length; i < ilen; i++) {
            var m = lst[i].match(/^\s*([\-\/]|[^\-\/\~\?0-9]+|[\-~?0-9]+)\s*$/);
            if (m) {
                ret.push(m[1]);
            }
        }
        var delimPos = ret.indexOf(rangeDelim);
        var delims = [];
        var isRange = false;
        if (delimPos > -1) {
            delims.push([ 0, delimPos ]);
            delims.push([ delimPos + 1, ret.length ]);
            isRange = true;
        } else {
            delims.push([ 0, ret.length ]);
        }
        var suff = "";
        for (var i = 0, ilen = delims.length; i < ilen; i++) {
            var delim = delims[i];
            var date = ret.slice(delim[0], delim[1]);
            outer: for (var j = 0, jlen = date.length; j < jlen; j++) {
                var element = date[j];
                if (element.indexOf(dateDelim) > -1) {
                    this._parseNumericDate(thedate, dateDelim, suff, element);
                    continue;
                }
                if (element.match(/[0-9]{4}/)) {
                    thedate["year" + suff] = element.replace(/^0*/, "");
                    continue;
                }
                if (element === "~" || element === "?" || element === "c" || element.match(/^cir/)) {
                    thedate.circa = true;
                }
                for (var k = 0, klen = this.monthRexes.length; k < klen; k++) {
                    if (element.toLocaleLowerCase().match(this.monthRexes[k])) {
                        thedate["month" + suff] = "" + (parseInt(k, 10) + 1);
                        continue outer;
                    }
                }
                if (element.match(/^[0-9]+$/)) {
                    number = element;
                }
                if (element.toLocaleLowerCase().match(/^bc/) && number) {
                    thedate["year" + suff] = "" + number * -1;
                    number = "";
                    continue;
                }
                if (element.toLocaleLowerCase().match(/^ad/) && number) {
                    thedate["year" + suff] = "" + number;
                    number = "";
                    continue;
                }
                if (element.toLocaleLowerCase().match(/(?:mic|tri|hil|eas)/) && !thedate["season" + suff]) {
                    note = element;
                    continue;
                }
            }
            if (number) {
                thedate["day" + suff] = number;
                number = "";
            }
            if (note && !thedate["season" + suff]) {
                thedate["season" + suff] = note.trim();
                note = "";
            }
            suff = "_end";
        }
        if (isRange) {
            for (var j = 0, jlen = CSL.DATE_PARTS_ALL.length; j < jlen; j++) {
                var item = CSL.DATE_PARTS_ALL[j];
                if (thedate[item] && !thedate[item + "_end"]) {
                    thedate[item + "_end"] = thedate[item];
                } else if (!thedate[item] && thedate[item + "_end"]) {
                    thedate[item] = thedate[item + "_end"];
                }
            }
        }
        if (!thedate.year || thedate.year && thedate.day && !thedate.month) {
            thedate = {
                literal: orig
            };
        }
        var parts = [ "year", "month", "day", "year_end", "month_end", "day_end" ];
        for (var i = 0, ilen = parts.length; i < ilen; i++) {
            var part = parts[i];
            if ("string" === typeof thedate[part] && thedate[part].match(/^[0-9]+$/)) {
                thedate[part] = parseInt(thedate[part], 10);
            }
        }
        if (yearIsNegative && Object.keys(thedate).indexOf("year") > -1) {
            thedate.year = thedate.year * -1;
        }
        return thedate;
    };
    this.parseDateToArray = function(txt) {
        return this.convertDateObjectToArray(this.parseDateToObject(txt));
    };
    this.parseDateToString = function(txt) {
        return this.convertDateObjectToString(this.parseDateToObject(txt));
    };
    this.parse = function(txt) {
        return this.parseDateToObject(txt);
    };
    this.setOrderMonthDay();
    this.resetDateParserMonths();
};

CSL.DateParser = new CSL.DateParser;

CSL.Engine = function(sys, style, lang, forceLang) {
    var attrs, langspec;
    this.processor_version = CSL.PROCESSOR_VERSION;
    this.csl_version = "1.0";
    this.sys = sys;
    if (typeof Object.assign != "function") {
        Object.defineProperty(Object, "assign", {
            value: function assign(target) {
                if (target == null) {
                    throw new TypeError("Cannot convert undefined or null to object");
                }
                var to = Object(target);
                for (var index = 1; index < arguments.length; index++) {
                    var nextSource = arguments[index];
                    if (nextSource != null) {
                        for (var nextKey in nextSource) {
                            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                                to[nextKey] = nextSource[nextKey];
                            }
                        }
                    }
                }
                return to;
            },
            writable: true,
            configurable: true
        });
    }
    if (sys.variableWrapper) {
        CSL.VARIABLE_WRAPPER_PREPUNCT_REX = new RegExp("^([" + [ " " ].concat(CSL.SWAPPING_PUNCTUATION).join("") + "]*)(.*)");
    }
    if (CSL.retrieveStyleModule) {
        this.sys.retrieveStyleModule = CSL.retrieveStyleModule;
    }
    if (CSL.getAbbreviation) {
        this.sys.getAbbreviation = CSL.getAbbreviation;
    }
    if (this.sys.stringCompare) {
        CSL.stringCompare = this.sys.stringCompare;
    }
    this.sys.AbbreviationSegments = CSL.AbbreviationSegments;
    this.transform = new CSL.Transform(this);
    this.setParseNames = function(val) {
        this.opt["parse-names"] = val;
    };
    this.opt = new CSL.Engine.Opt;
    this.tmp = new CSL.Engine.Tmp;
    this.build = new CSL.Engine.Build;
    this.fun = new CSL.Engine.Fun(this);
    this.configure = new CSL.Engine.Configure;
    this.citation_sort = new CSL.Engine.CitationSort;
    this.bibliography_sort = new CSL.Engine.BibliographySort;
    this.citation = new CSL.Engine.Citation(this);
    this.bibliography = new CSL.Engine.Bibliography;
    this.intext = new CSL.Engine.InText;
    this.output = new CSL.Output.Queue(this);
    this.dateput = new CSL.Output.Queue(this);
    this.cslXml = CSL.setupXml(style);
    for (var i in CSL.SYS_OPTIONS) {
        var option = CSL.SYS_OPTIONS[i];
        if ("boolean" === typeof this.sys[option]) {
            this.opt.development_extensions[option] = this.sys[option];
        }
    }
    if (this.opt.development_extensions.uppercase_subtitles || this.opt.development_extensions.implicit_short_title) {
        this.opt.development_extensions.main_title_from_short_title = true;
    }
    if (this.opt.development_extensions.csl_reverse_lookup_support) {
        this.build.cslNodeId = 0;
        this.setCslNodeIds = function(myxml, nodename) {
            var children = this.cslXml.children(myxml);
            this.cslXml.setAttribute(myxml, "cslid", this.build.cslNodeId);
            this.opt.nodenames.push(nodename);
            this.build.cslNodeId += 1;
            for (var i = 0, ilen = this.cslXml.numberofnodes(children); i < ilen; i += 1) {
                nodename = this.cslXml.nodename(children[i]);
                if (nodename) {
                    this.setCslNodeIds(children[i], nodename);
                }
            }
        };
        this.setCslNodeIds(this.cslXml.dataObj, "style");
    }
    this.cslXml.addMissingNameNodes(this.cslXml.dataObj);
    this.cslXml.addInstitutionNodes(this.cslXml.dataObj);
    this.cslXml.insertPublisherAndPlace(this.cslXml.dataObj);
    this.cslXml.flagDateMacros(this.cslXml.dataObj);
    attrs = this.cslXml.attributes(this.cslXml.dataObj);
    if ("undefined" === typeof attrs["@sort-separator"]) {
        this.cslXml.setAttribute(this.cslXml.dataObj, "sort-separator", ", ");
    }
    this.opt["initialize-with-hyphen"] = true;
    this.setStyleAttributes();
    this.opt.xclass = this.cslXml.getAttributeValue(this.cslXml.dataObj, "class");
    this.opt["class"] = this.opt.xclass;
    this.opt.styleID = this.cslXml.getStyleId(this.cslXml.dataObj);
    this.opt.styleName = this.cslXml.getStyleId(this.cslXml.dataObj, true);
    if (this.opt.version.slice(0, 4) === "1.1m") {
        this.opt.development_extensions.consolidate_legal_items = true;
        this.opt.development_extensions.consolidate_container_items = true;
        this.opt.development_extensions.main_title_from_short_title = true;
        this.opt.development_extensions.expect_and_symbol_form = true;
        this.opt.development_extensions.require_explicit_legal_case_title_short = true;
        this.opt.development_extensions.force_jurisdiction = true;
        this.opt.development_extensions.force_title_abbrev_fallback = true;
    }
    if (lang) {
        lang = lang.replace("_", "-");
        lang = CSL.normalizeLocaleStr(lang);
    }
    if (this.opt["default-locale"][0]) {
        this.opt["default-locale"][0] = this.opt["default-locale"][0].replace("_", "-");
        this.opt["default-locale"][0] = CSL.normalizeLocaleStr(this.opt["default-locale"][0]);
    }
    if (lang && forceLang) {
        this.opt["default-locale"] = [ lang ];
    }
    if (lang && !forceLang && this.opt["default-locale"][0]) {
        lang = this.opt["default-locale"][0];
    }
    if (this.opt["default-locale"].length === 0) {
        if (!lang) {
            lang = "en-US";
        }
        this.opt["default-locale"].push("en-US");
    }
    if (!lang) {
        lang = this.opt["default-locale"][0];
    }
    langspec = CSL.localeResolve(lang);
    this.opt.lang = langspec.best;
    this.opt["default-locale"][0] = langspec.best;
    this.locale = {};
    if (!this.opt["default-locale-sort"]) {
        this.opt["default-locale-sort"] = this.opt["default-locale"][0];
    }
    if ("dale|".localeCompare("daleb", this.opt["default-locale-sort"]) > -1) {
        this.opt.sort_sep = "@";
    } else {
        this.opt.sort_sep = "|";
    }
    this.localeConfigure(langspec);
    function makeRegExp(lst) {
        var lst = lst.slice();
        var ret = new RegExp("(?:(?:[?!:]*\\s+|-|^)(?:" + lst.join("|") + ")(?=[!?:]*\\s+|-|$))", "g");
        return ret;
    }
    this.locale[this.opt.lang].opts["skip-words-regexp"] = makeRegExp(this.locale[this.opt.lang].opts["skip-words"]);
    this.output.adjust = new CSL.Output.Queue.adjust(this.getOpt("punctuation-in-quote"));
    this.registry = new CSL.Registry(this);
    this.macros = {};
    this.build.area = "citation";
    var area_nodes = this.cslXml.getNodesByName(this.cslXml.dataObj, this.build.area);
    this.buildTokenLists(area_nodes, this[this.build.area].tokens);
    this.build.area = "bibliography";
    var area_nodes = this.cslXml.getNodesByName(this.cslXml.dataObj, this.build.area);
    this.buildTokenLists(area_nodes, this[this.build.area].tokens);
    this.build.area = "intext";
    var area_nodes = this.cslXml.getNodesByName(this.cslXml.dataObj, this.build.area);
    this.buildTokenLists(area_nodes, this[this.build.area].tokens);
    if (this.opt.parallel.enable) {
        this.parallel = new CSL.Parallel(this);
    }
    this.juris = {};
    this.configureTokenLists();
    this.disambiguate = new CSL.Disambiguation(this);
    this.splice_delimiter = false;
    this.fun.dateparser = CSL.DateParser;
    this.fun.flipflopper = new CSL.Util.FlipFlopper(this);
    this.setCloseQuotesArray();
    this.fun.ordinalizer.init(this);
    this.fun.long_ordinalizer.init(this);
    this.fun.page_mangler = CSL.Util.PageRangeMangler.getFunction(this, "page");
    this.fun.year_mangler = CSL.Util.PageRangeMangler.getFunction(this, "year");
    this.setOutputFormat("html");
};

CSL.Engine.prototype.setCloseQuotesArray = function() {
    var ret;
    ret = [];
    ret.push(this.getTerm("close-quote"));
    ret.push(this.getTerm("close-inner-quote"));
    ret.push('"');
    ret.push("'");
    this.opt.close_quotes_array = ret;
};

CSL.makeBuilder = function(me, target) {
    var var_stack = [];
    var node_stack = [];
    function runStart(node) {
        node_stack.push(node);
        CSL.XmlToToken.call(node, me, CSL.START, target, var_stack);
    }
    function runEnd() {
        var node = node_stack.pop();
        CSL.XmlToToken.call(node, me, CSL.END, target, var_stack);
    }
    function runSingle(node) {
        CSL.XmlToToken.call(node, me, CSL.SINGLETON, target, var_stack);
    }
    function buildStyle(nodes, parent, node_stack) {
        if (!nodes) {
            nodes = [];
        }
        if ("undefined" === typeof nodes.length) {
            nodes = [ nodes ];
        }
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if (me.cslXml.nodename(node) === null) {
                continue;
            }
            if (parent && me.cslXml.nodename(node) === "date") {
                CSL.Util.fixDateNode.call(me, parent, i, node);
                node = me.cslXml.children(parent)[i];
            }
            if (me.cslXml.numberofnodes(me.cslXml.children(node))) {
                runStart(node);
                buildStyle(me.cslXml.children(node), node);
                runEnd();
            } else {
                runSingle(node);
            }
        }
    }
    return buildStyle;
};

CSL.Engine.prototype.buildTokenLists = function(area_nodes, target) {
    if (!this.cslXml.getNodeValue(area_nodes)) {
        return;
    }
    var builder = CSL.makeBuilder(this, target);
    var mynode;
    if ("undefined" === typeof area_nodes.length) {
        mynode = area_nodes;
    } else {
        mynode = area_nodes[0];
    }
    builder(mynode);
};

CSL.Engine.prototype.setStyleAttributes = function() {
    var dummy, attributes, attrname;
    var dummy = {};
    dummy.name = this.cslXml.nodename(this.cslXml.dataObj);
    attributes = this.cslXml.attributes(this.cslXml.dataObj);
    for (attrname in attributes) {
        if (attributes.hasOwnProperty(attrname)) {
            CSL.Attributes[attrname].call(dummy, this, attributes[attrname]);
        }
    }
};

CSL.Engine.prototype.getTerm = function(term, form, plural, gender, mode, forceDefaultLocale) {
    if (term && term.match(/[A-Z]/) && term === term.toUpperCase()) {
        CSL.debug("Warning: term key is in uppercase form: " + term);
        term = term.toLowerCase();
    }
    var lang;
    if (forceDefaultLocale) {
        lang = this.opt["default-locale"][0];
    } else {
        lang = this.opt.lang;
    }
    var ret = CSL.Engine.getField(CSL.LOOSE, this.locale[lang].terms, term, form, plural, gender);
    if (!ret && term === "range-delimiter") {
        ret = "–";
    }
    if (typeof ret === "undefined") {
        if (mode === CSL.STRICT) {
            CSL.error('Error in getTerm: term "' + term + '" does not exist.');
        } else if (mode === CSL.TOLERANT) {
            ret = "";
        }
    }
    if (ret) {
        this.tmp.cite_renders_content = true;
    }
    return ret;
};

CSL.Engine.prototype.getDate = function(form, forceDefaultLocale) {
    var lang;
    if (forceDefaultLocale) {
        lang = this.opt["default-locale"];
    } else {
        lang = this.opt.lang;
    }
    if (this.locale[lang].dates[form]) {
        return this.locale[lang].dates[form];
    } else {
        return false;
    }
};

CSL.Engine.prototype.getOpt = function(arg) {
    if ("undefined" !== typeof this.locale[this.opt.lang].opts[arg]) {
        return this.locale[this.opt.lang].opts[arg];
    } else {
        return false;
    }
};

CSL.Engine.prototype.getVariable = function(Item, varname, form, plural) {
    return CSL.Engine.getField(CSL.LOOSE, Item, varname, form, plural);
};

CSL.Engine.prototype.getDateNum = function(ItemField, partname) {
    if ("undefined" === typeof ItemField) {
        return 0;
    } else {
        return ItemField[partname];
    }
};

CSL.Engine.getField = function(mode, hash, term, form, plural, gender) {
    var ret, forms, f, pos, len, hashterm;
    ret = "";
    if ("undefined" === typeof hash[term]) {
        if (mode === CSL.STRICT) {
            CSL.error('Error in getField: term "' + term + '" does not exist.');
        } else {
            return undefined;
        }
    }
    if (gender && hash[term][gender]) {
        hashterm = hash[term][gender];
    } else {
        hashterm = hash[term];
    }
    forms = [];
    if (form === "symbol") {
        forms = [ "symbol", "short" ];
    } else if (form === "verb-short") {
        forms = [ "verb-short", "verb" ];
    } else if (form !== "long") {
        forms = [ form ];
    }
    forms = forms.concat([ "long" ]);
    len = forms.length;
    for (pos = 0; pos < len; pos += 1) {
        f = forms[pos];
        if ("string" === typeof hashterm || "number" === typeof hashterm) {
            ret = hashterm;
        } else if ("undefined" !== typeof hashterm[f]) {
            if ("string" === typeof hashterm[f] || "number" === typeof hashterm[f]) {
                ret = hashterm[f];
            } else {
                if ("number" === typeof plural) {
                    ret = hashterm[f][plural];
                } else {
                    ret = hashterm[f][0];
                }
            }
            break;
        }
    }
    return ret;
};

CSL.Engine.prototype.configureTokenLists = function() {
    var area, pos, len;
    len = CSL.AREAS.length;
    for (pos = 0; pos < len; pos += 1) {
        area = CSL.AREAS[pos];
        var tokens = this[area].tokens;
        this.configureTokenList(tokens);
    }
    this.version = CSL.version;
    return this.state;
};

CSL.Engine.prototype.configureTokenList = function(tokens) {
    var dateparts_master, token, dateparts, part, ppos, pppos, llen, lllen;
    dateparts_master = [ "year", "month", "day" ];
    llen = tokens.length - 1;
    for (ppos = llen; ppos > -1; ppos += -1) {
        token = tokens[ppos];
        if ("date" === token.name && CSL.END === token.tokentype) {
            dateparts = [];
        }
        if ("date-part" === token.name && token.strings.name) {
            lllen = dateparts_master.length;
            for (pppos = 0; pppos < lllen; pppos += 1) {
                part = dateparts_master[pppos];
                if (part === token.strings.name) {
                    dateparts.push(token.strings.name);
                }
            }
        }
        if ("date" === token.name && CSL.START === token.tokentype) {
            dateparts.reverse();
            token.dateparts = dateparts;
        }
        token.next = ppos + 1;
        if (token.name && CSL.Node[token.name].configure) {
            CSL.Node[token.name].configure.call(token, this, ppos);
        }
    }
};

CSL.Engine.prototype.refetchItems = function(ids) {
    var ret = [];
    for (var i = 0, ilen = ids.length; i < ilen; i += 1) {
        ret.push(this.refetchItem("" + ids[i]));
    }
    return ret;
};

CSL.ITERATION = 0;

CSL.Engine.prototype.retrieveItem = function(id) {
    var Item, m, i;
    if (!this.tmp.loadedItemIDs[id]) {
        this.tmp.loadedItemIDs[id] = true;
    } else {
        return this.registry.refhash[id];
    }
    if (this.opt.development_extensions.normalize_lang_keys_to_lowercase && "boolean" === typeof this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
        for (var i = 0, ilen = this.opt["default-locale"].length; i < ilen; i += 1) {
            this.opt["default-locale"][i] = this.opt["default-locale"][i].toLowerCase();
        }
        for (var i = 0, ilen = this.opt["locale-translit"].length; i < ilen; i += 1) {
            this.opt["locale-translit"][i] = this.opt["locale-translit"][i].toLowerCase();
        }
        for (var i = 0, ilen = this.opt["locale-translat"].length; i < ilen; i += 1) {
            this.opt["locale-translat"][i] = this.opt["locale-translat"][i].toLowerCase();
        }
        this.opt.development_extensions.normalize_lang_keys_to_lowercase = 100;
    }
    CSL.ITERATION += 1;
    Item = JSON.parse(JSON.stringify(this.sys.retrieveItem("" + id)));
    if (this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
        if (Item.multi) {
            if (Item.multi._keys) {
                for (var field in Item.multi._keys) {
                    for (var key in Item.multi._keys[field]) {
                        if (key !== key.toLowerCase()) {
                            Item.multi._keys[field][key.toLowerCase()] = Item.multi._keys[field][key];
                            delete Item.multi._keys[field][key];
                        }
                    }
                }
            }
            if (Item.multi.main) {
                for (var field in Item.multi.main) {
                    Item.multi.main[field] = Item.multi.main[field].toLowerCase();
                }
            }
        }
        for (var i = 0, ilen = CSL.NAME_VARIABLES.length; i > ilen; i += 1) {
            var ctype = CSL.NAME_VARIABLES[i];
            if (Item[ctype] && Item[ctype].multi) {
                for (var j = 0, jlen = Item[ctype].length; j < jlen; j += 1) {
                    var creator = Item[ctype][j];
                    if (creator.multi) {
                        if (creator.multi._key) {
                            for (var key in creator.multi._key) {
                                if (key !== key.toLowerCase()) {
                                    creator.multi._key[key.toLowerCase()] = creator.multi._key[key];
                                    delete creator.multi._key[key];
                                }
                            }
                        }
                        if (creator.multi.main) {
                            creator.multi.main = creator.multi.main.toLowerCase();
                        }
                    }
                }
            }
        }
    }
    if (Item.language && Item.language.match(/[><]/)) {
        var m = Item.language.match(/(.*?)([<>])(.*)/);
        if (m[2] === "<") {
            Item["language-name"] = m[1];
            Item["language-name-original"] = m[3];
        } else {
            Item["language-name"] = m[3];
            Item["language-name-original"] = m[1];
        }
        if (this.opt.multi_layout) {
            if (Item["language-name-original"]) {
                Item.language = Item["language-name-original"];
            }
        } else {
            if (Item["language-name"]) {
                Item.language = Item["language-name"];
            }
        }
    }
    if (Item.page) {
        Item["page-first"] = Item.page;
        var num = "" + Item.page;
        var m = num.split(/\s*(?:&|, |-|\u2013)\s*/);
        if (m[0].slice(-1) !== "\\") {
            Item["page-first"] = m[0];
        }
    }
    if (this.opt.development_extensions.field_hack && Item.note) {
        CSL.parseNoteFieldHacks(Item, false, this.opt.development_extensions.allow_field_hack_date_override);
    }
    for (var key in Item) {
        if (CSL.DATE_VARIABLES.indexOf(key.replace(/^alt-/, "")) > -1) {
            var dateobj = Item[key];
            if (dateobj) {
                if (this.opt.development_extensions.raw_date_parsing) {
                    if (dateobj.raw && (!dateobj["date-parts"] || dateobj["date-parts"].length === 0)) {
                        dateobj = this.fun.dateparser.parseDateToObject(dateobj.raw);
                    }
                }
                Item[key] = this.dateParseArray(dateobj);
            }
        }
    }
    if (this.opt.development_extensions.consolidate_legal_items) {
        if (Item.type && [ "bill", "gazette", "legislation", "regulation", "treaty" ].indexOf(Item.type) > -1) {
            var varname;
            var elements = [ "type", "title", "jurisdiction", "genre", "volume", "container-title" ];
            var legislation_id = [];
            for (var i = 0, ilen = elements.length; i < ilen; i += 1) {
                varname = elements[i];
                if (Item[varname]) {
                    legislation_id.push(Item[varname]);
                }
            }
            elements = [ "original-date", "issued" ];
            for (var i = 0, ilen = elements.length; i < ilen; i += 1) {
                varname = elements[i];
                if (Item[varname] && Item[varname].year) {
                    var value = Item[varname].year;
                    legislation_id.push(value);
                    break;
                }
            }
            Item.legislation_id = legislation_id.join("::");
        }
    }
    if (this.bibliography.opt.track_container_items) {
        if (this.bibliography.opt.track_container_items.indexOf(Item.type) > -1) {
            var varname;
            var elements = [ "type", "container-title", "publisher", "edition" ];
            var container_id = [];
            for (var i = 0, ilen = elements.length; i < ilen; i += 1) {
                varname = elements[i];
                if (Item[varname]) {
                    container_id.push(Item[varname]);
                }
            }
            Item.container_id = container_id.join("::");
        }
    }
    if (this.opt.development_extensions.force_jurisdiction) {
        if ("string" === typeof Item.authority) {
            Item.authority = [ {
                literal: Item.authority,
                multi: {
                    _key: {}
                }
            } ];
            if (Item.multi && Item.multi._keys && Item.multi._keys.authority) {
                Item.authority[0].multi._key = {};
                for (var key in Item.multi._keys.authority) {
                    Item.authority[0].multi._key[key] = {
                        literal: Item.multi._keys.authority[key]
                    };
                }
            }
        }
    }
    if (!Item["title-short"]) {
        Item["title-short"] = Item.shortTitle;
    }
    if (this.opt.development_extensions.main_title_from_short_title) {
        var narrowSpaceLocale = this.opt["default-locale"][0].slice(0, 2).toLowerCase() === "fr";
        CSL.extractTitleAndSubtitle.call(this, Item, narrowSpaceLocale);
    }
    var isLegalType = [ "bill", "legal_case", "legislation", "gazette", "regulation" ].indexOf(Item.type) > -1;
    if (this.opt.development_extensions.force_jurisdiction && isLegalType) {
        if (!Item.jurisdiction) {
            Item.jurisdiction = "us";
        }
    }
    var normalizedKey;
    if (!isLegalType && Item.title && this.sys.getAbbreviation) {
        if (!Item.jurisdiction) ;
        if (this.sys.normalizeAbbrevsKey) {
            normalizedKey = this.sys.normalizeAbbrevsKey("title", Item.title);
        } else {
            normalizedKey = Item.title;
        }
        var jurisdiction = this.transform.loadAbbreviation(Item.jurisdiction, "title", normalizedKey, Item.language);
        if (this.transform.abbrevs[jurisdiction].title) {
            if (this.transform.abbrevs[jurisdiction].title[normalizedKey]) {
                Item["title-short"] = this.transform.abbrevs[jurisdiction].title[normalizedKey];
            }
        }
    }
    if (!Item["container-title-short"]) {
        Item["container-title-short"] = Item.journalAbbreviation;
    }
    if (Item["container-title"] && this.sys.getAbbreviation) {
        if (this.sys.normalizeAbbrevsKey) {
            normalizedKey = this.sys.normalizeAbbrevsKey(Item["container-title"]);
        } else {
            normalizedKey = Item["container-title"];
        }
        var jurisdiction = this.transform.loadAbbreviation(Item.jurisdiction, "container-title", normalizedKey, Item.language);
        if (this.transform.abbrevs[jurisdiction]["container-title"]) {
            if (this.transform.abbrevs[jurisdiction]["container-title"][normalizedKey]) {
                Item["container-title-short"] = this.transform.abbrevs[jurisdiction]["container-title"][normalizedKey];
            }
        }
    }
    if (Item.jurisdiction) {
        Item.country = Item.jurisdiction.split(":")[0];
    }
    if (this.registry.refhash[id]) {
        if (JSON.stringify(this.registry.refhash[id]) != JSON.stringify(Item)) {
            for (var key in this.registry.refhash[id]) {
                delete this.registry.refhash[id][key];
            }
            this.tmp.taintedItemIDs[Item.id] = true;
            Object.assign(this.registry.refhash[id], Item);
        }
    } else {
        this.registry.refhash[id] = Item;
    }
    return this.registry.refhash[id];
};

CSL.Engine.prototype.refetchItem = function(id) {
    return this.registry.refhash[id];
};

CSL.Engine.prototype.setOpt = function(token, name, value) {
    if (token.name === "style" || token.name === "cslstyle") {
        this.opt.inheritedAttributes[name] = value;
        this.citation.opt.inheritedAttributes[name] = value;
        this.bibliography.opt.inheritedAttributes[name] = value;
    } else if ([ "citation", "bibliography" ].indexOf(token.name) > -1) {
        this[token.name].opt.inheritedAttributes[name] = value;
    } else {
        token.strings[name] = value;
    }
};

CSL.Engine.prototype.inheritOpt = function(token, attrname, parentname, defaultValue) {
    if ("undefined" !== typeof token.strings[attrname]) {
        return token.strings[attrname];
    } else {
        var parentValue = this[this.tmp.root].opt.inheritedAttributes[parentname ? parentname : attrname];
        if ("undefined" !== typeof parentValue) {
            return parentValue;
        } else {
            return defaultValue;
        }
    }
};

CSL.Engine.prototype.remapSectionVariable = function(inputList) {
    for (var i = 0, ilen = inputList.length; i < ilen; i += 1) {
        var Item = inputList[i][0];
        var item = inputList[i][1];
        if ([ "bill", "gazette", "legislation", "regulation", "treaty" ].indexOf(Item.type) > -1) {
            if (item.locator) {
                item.locator = item.locator.trim();
                var m = item.locator.match(CSL.STATUTE_SUBDIV_PLAIN_REGEX_FRONT);
                if (!m) {
                    if (item.label) {
                        item.locator = CSL.STATUTE_SUBDIV_STRINGS_REVERSE[item.label] + " " + item.locator;
                    } else {
                        item.locator = "p. " + item.locator;
                    }
                }
            }
            var sectionMasterLabel = null;
            if (Item.section) {
                Item.section = Item.section.trim();
                var m = Item.section.match(CSL.STATUTE_SUBDIV_PLAIN_REGEX_FRONT);
                if (!m) {
                    Item.section = "sec. " + Item.section;
                    sectionMasterLabel = "sec.";
                } else {
                    sectionMasterLabel = m[0].trim();
                }
            }
            if (Item.section) {
                if (!item.locator) {
                    item.locator = Item.section;
                } else {
                    var m = item.locator.match(/^([^ ]*)\s*(.*)/);
                    var space = " ";
                    if (m) {
                        if (m[1] === "p." && sectionMasterLabel !== "p.") {
                            item.locator = m[2];
                        }
                        if ([ "[", "(", ".", ",", ";", ":", "?" ].indexOf(item.locator.slice(0, 1)) > -1) {
                            space = "";
                        }
                    } else {
                        space = "";
                    }
                    item.locator = Item.section + space + item.locator;
                }
            }
            item.label = "";
        }
    }
};

CSL.Engine.prototype.setNumberLabels = function(Item) {
    if (Item.number && [ "bill", "gazette", "legislation", "regulation", "treaty" ].indexOf(Item.type) > -1 && this.opt.development_extensions.consolidate_legal_items && !this.tmp.shadow_numbers["number"]) {
        this.tmp.shadow_numbers["number"] = {};
        this.tmp.shadow_numbers["number"].values = [];
        this.tmp.shadow_numbers["number"].plural = 0;
        this.tmp.shadow_numbers["number"].numeric = false;
        this.tmp.shadow_numbers["number"].label = false;
        var value = "" + Item.number;
        value = value.split("\\").join("");
        var firstword = value.split(/\s+/)[0];
        var firstlabel = CSL.STATUTE_SUBDIV_STRINGS[firstword];
        if (firstlabel) {
            var splt = value.split(CSL.STATUTE_SUBDIV_PLAIN_REGEX);
            if (splt.length > 1) {
                var lst = [];
                for (var j = 1, jlen = splt.length; j < jlen; j += 1) {
                    lst.push(splt[j].replace(/\s*$/, "").replace(/^\s*/, ""));
                }
                value = lst.join(" ");
            } else {
                value = splt[0];
            }
            this.tmp.shadow_numbers["number"].label = firstlabel;
            this.tmp.shadow_numbers["number"].values.push([ "Blob", value, false ]);
            this.tmp.shadow_numbers["number"].numeric = false;
        } else {
            this.tmp.shadow_numbers["number"].values.push([ "Blob", value, false ]);
            this.tmp.shadow_numbers["number"].numeric = true;
        }
    }
};

CSL.substituteOne = function(template) {
    return function(state, list) {
        if (!list) {
            return "";
        } else {
            return template.replace("%%STRING%%", list);
        }
    };
};

CSL.substituteTwo = function(template) {
    return function(param) {
        var template2 = template.replace("%%PARAM%%", param);
        return function(state, list) {
            if (!list) {
                return "";
            } else {
                return template2.replace("%%STRING%%", list);
            }
        };
    };
};

CSL.Mode = function(mode) {
    var decorations, params, param, func, val, args;
    decorations = {};
    params = CSL.Output.Formats[mode];
    for (param in params) {
        {
            if ("@" !== param.slice(0, 1)) {
                decorations[param] = params[param];
                continue;
            }
            func = false;
            val = params[param];
            args = param.split("/");
            if (typeof val === "string" && val.indexOf("%%STRING%%") > -1) {
                if (val.indexOf("%%PARAM%%") > -1) {
                    func = CSL.substituteTwo(val);
                } else {
                    func = CSL.substituteOne(val);
                }
            } else if (typeof val === "boolean" && !val) {
                func = CSL.Output.Formatters.passthrough;
            } else if (typeof val === "function") {
                func = val;
            } else {
                CSL.error("Bad " + mode + " config entry for " + param + ": " + val);
            }
            if (args.length === 1) {
                decorations[args[0]] = func;
            } else if (args.length === 2) {
                if (!decorations[args[0]]) {
                    decorations[args[0]] = {};
                }
                decorations[args[0]][args[1]] = func;
            }
        }
    }
    return decorations;
};

CSL.setDecorations = function(state, attributes) {
    var ret, key, pos;
    ret = [];
    for (pos in CSL.FORMAT_KEY_SEQUENCE) {
        {
            var key = CSL.FORMAT_KEY_SEQUENCE[pos];
            if (attributes[key]) {
                ret.push([ key, attributes[key] ]);
                delete attributes[key];
            }
        }
    }
    return ret;
};

CSL.Doppeler = function(rexStr, stringMangler) {
    var matchRex = new RegExp("(" + rexStr + ")", "g");
    var splitRex = new RegExp(rexStr, "g");
    this.split = function(str) {
        if (stringMangler) {
            str = stringMangler(str);
        }
        var match = str.match(matchRex);
        if (!match) {
            return {
                tags: [],
                strings: [ str ]
            };
        }
        var split = str.split(splitRex);
        for (var i = match.length - 1; i > -1; i--) {
            if (typeof match[i] === "number") {
                match[i] = "";
            }
            var tag = match[i];
            if (tag === "'" && split[i + 1].length > 0) {
                split[i + 1] = match[i] + split[i + 1];
                match[i] = "";
            }
        }
        return {
            tags: match,
            strings: split,
            origStrings: split.slice()
        };
    };
    this.join = function(obj) {
        var lst = obj.strings.slice(-1);
        for (var i = obj.tags.length - 1; i > -1; i--) {
            lst.push(obj.tags[i]);
            lst.push(obj.strings[i]);
        }
        lst.reverse();
        return lst.join("");
    };
};

CSL.Engine.prototype.normalDecorIsOrphan = function(blob, params) {
    if (params[1] === "normal") {
        var use_param = false;
        var all_the_decor;
        if (this.tmp.area === "citation") {
            all_the_decor = [ this.citation.opt.layout_decorations ].concat(blob.alldecor);
        } else {
            all_the_decor = blob.alldecor;
        }
        for (var k = all_the_decor.length - 1; k > -1; k += -1) {
            for (var n = all_the_decor[k].length - 1; n > -1; n += -1) {
                if (all_the_decor[k][n][0] === params[0]) {
                    if (all_the_decor[k][n][1] !== "normal") {
                        use_param = true;
                    }
                }
            }
        }
        if (!use_param) {
            return true;
        }
    }
    return false;
};

CSL.Engine.prototype.getCitationLabel = function(Item) {
    var label = "";
    var params = this.getTrigraphParams();
    var config = params[0];
    var myname = this.getTerm("reference", "short", 0);
    if ("undefined" === typeof myname) {
        myname = "reference";
    }
    myname = myname.replace(".", "");
    myname = myname.slice(0, 1).toUpperCase() + myname.slice(1);
    for (var i = 0, ilen = CSL.NAME_VARIABLES.length; i < ilen; i += 1) {
        var n = CSL.NAME_VARIABLES[i];
        if (Item[n]) {
            var names = Item[n];
            if (names.length > params.length) {
                config = params[params.length - 1];
            } else {
                config = params[names.length - 1];
            }
            for (var j = 0, jlen = names.length; j < jlen; j += 1) {
                if (j === config.authors.length) {
                    break;
                }
                var res = this.nameOutput.getName(names[j], "locale-translit", true);
                var name = res.name;
                if (name && name.family) {
                    myname = name.family;
                    myname = myname.replace(/^([ \'\u2019a-z]+\s+)/, "");
                } else if (name && name.literal) {
                    myname = name.literal;
                }
                var m = myname.toLowerCase().match(/^(a\s+|the\s+|an\s+)/);
                if (m) {
                    myname = myname.slice(m[1].length);
                }
                myname = myname.replace(CSL.ROMANESQUE_NOT_REGEXP, "");
                if (!myname) {
                    break;
                }
                myname = myname.slice(0, config.authors[j]);
                if (myname.length > 1) {
                    myname = myname.slice(0, 1).toUpperCase() + myname.slice(1).toLowerCase();
                } else if (myname.length === 1) {
                    myname = myname.toUpperCase();
                }
                label += myname;
            }
            break;
        }
    }
    if (!label) {
        if (Item.title) {
            var skipWords = this.locale[this.opt.lang].opts["skip-words"];
            var lst = Item.title.split(/\s+/);
            for (var i = lst.length - 1; i > -1; i--) {
                if (skipWords.indexOf(lst[i]) > -1) {
                    lst = lst.slice(0, i).concat(lst.slice(i + 1));
                }
            }
            var str = lst.join("");
            str = str.slice(0, params[0].authors[0]);
            if (str.length > 1) {
                str = str.slice(0, 1).toUpperCase() + str.slice(1).toLowerCase();
            } else if (str.length === 1) {
                str = str.toUpperCase();
            }
            label = str;
        }
    }
    var year = "0000";
    if (Item.issued) {
        if (Item.issued.year) {
            year = "" + Item.issued.year;
        }
    }
    year = year.slice(config.year * -1);
    label = label + year;
    return label;
};

CSL.Engine.prototype.getTrigraphParams = function() {
    var params = [];
    var ilst = this.opt.trigraph.split(":");
    if (!this.opt.trigraph || this.opt.trigraph.slice(0, 1) !== "A") {
        CSL.error("Bad trigraph definition: " + this.opt.trigraph);
    }
    for (var i = 0, ilen = ilst.length; i < ilen; i += 1) {
        var str = ilst[i];
        var config = {
            authors: [],
            year: 0
        };
        for (var j = 0, jlen = str.length; j < jlen; j += 1) {
            switch (str.slice(j, j + 1)) {
              case "A":
                config.authors.push(1);
                break;

              case "a":
                config.authors[config.authors.length - 1] += 1;
                break;

              case "0":
                config.year += 1;
                break;

              default:
                CSL.error("Invalid character in trigraph definition: " + this.opt.trigraph);
            }
        }
        params.push(config);
    }
    return params;
};

CSL.Engine.prototype.setOutputFormat = function(mode) {
    this.opt.mode = mode;
    this.fun.decorate = CSL.Mode(mode);
    if (!this.output[mode]) {
        this.output[mode] = {};
        this.output[mode].tmp = {};
    }
};

CSL.Engine.prototype.getSortFunc = function() {
    return function(a, b) {
        a = a.split("-");
        b = b.split("-");
        if (a.length < b.length) {
            return 1;
        } else if (a.length > b.length) {
            return -1;
        } else {
            a = a.slice(-1)[0];
            b = b.slice(-1)[0];
            if (a.length < b.length) {
                return 1;
            } else if (a.length > b.length) {
                return -1;
            } else {
                return 0;
            }
        }
    };
};

CSL.Engine.prototype.setLangTagsForCslSort = function(tags) {
    var i, ilen;
    if (tags) {
        this.opt["locale-sort"] = [];
        for (i = 0, ilen = tags.length; i < ilen; i += 1) {
            this.opt["locale-sort"].push(tags[i]);
        }
    }
    this.opt["locale-sort"].sort(this.getSortFunc());
};

CSL.Engine.prototype.setLangTagsForCslTransliteration = function(tags) {
    var i, ilen;
    this.opt["locale-translit"] = [];
    if (tags) {
        for (i = 0, ilen = tags.length; i < ilen; i += 1) {
            this.opt["locale-translit"].push(tags[i]);
        }
    }
    this.opt["locale-translit"].sort(this.getSortFunc());
};

CSL.Engine.prototype.setLangTagsForCslTranslation = function(tags) {
    var i, ilen;
    this.opt["locale-translat"] = [];
    if (tags) {
        for (i = 0, ilen = tags.length; i < ilen; i += 1) {
            this.opt["locale-translat"].push(tags[i]);
        }
    }
    this.opt["locale-translat"].sort(this.getSortFunc());
};

CSL.Engine.prototype.setLangPrefsForCites = function(obj, conv) {
    var opt = this.opt["cite-lang-prefs"];
    if (!conv) {
        conv = function conv(key) {
            return key.toLowerCase();
        };
    }
    var segments = [ "Persons", "Institutions", "Titles", "Journals", "Publishers", "Places" ];
    for (var i = 0, ilen = segments.length; i < ilen; i += 1) {
        var clientSegment = conv(segments[i]);
        var citeprocSegment = segments[i].toLowerCase();
        if (!obj[clientSegment]) {
            continue;
        }
        var supplements = [];
        while (obj[clientSegment].length > 1) {
            supplements.push(obj[clientSegment].pop());
        }
        var sortval = {
            orig: 1,
            translit: 2,
            translat: 3
        };
        if (supplements.length === 2 && sortval[supplements[0]] < sortval[supplements[1]]) {
            supplements.reverse();
        }
        while (supplements.length) {
            obj[clientSegment].push(supplements.pop());
        }
        var lst = opt[citeprocSegment];
        while (lst.length) {
            lst.pop();
        }
        for (var j = 0, jlen = obj[clientSegment].length; j < jlen; j += 1) {
            lst.push(obj[clientSegment][j]);
        }
    }
};

CSL.Engine.prototype.setLangPrefsForCiteAffixes = function(affixList) {
    if (affixList && affixList.length === 48) {
        var affixes = this.opt.citeAffixes;
        var count = 0;
        var settings = [ "persons", "institutions", "titles", "journals", "publishers", "places" ];
        var forms = [ "translit", "orig", "translit", "translat" ];
        var value;
        for (var i = 0, ilen = settings.length; i < ilen; i += 1) {
            for (var j = 0, jlen = forms.length; j < jlen; j += 1) {
                value = "";
                if (count % 8 === 4) {
                    if (!affixes[settings[i]]["locale-" + forms[j]].prefix && !affixes[settings[i]]["locale-" + forms[j]].suffix) {
                        value = affixList[count] ? affixList[count] : "";
                        affixes[settings[i]]["locale-" + forms[j]].prefix = value;
                        value = affixList[count] ? affixList[count + 1] : "";
                        affixes[settings[i]]["locale-" + forms[j]].suffix = value;
                    }
                } else {
                    value = affixList[count] ? affixList[count] : "";
                    affixes[settings[i]]["locale-" + forms[j]].prefix = value;
                    value = affixList[count] ? affixList[count + 1] : "";
                    affixes[settings[i]]["locale-" + forms[j]].suffix = value;
                }
                count += 2;
            }
        }
        this.opt.citeAffixes = affixes;
    }
};

CSL.Engine.prototype.setAutoVietnameseNamesOption = function(arg) {
    if (arg) {
        this.opt["auto-vietnamese-names"] = true;
    } else {
        this.opt["auto-vietnamese-names"] = false;
    }
};

CSL.Engine.prototype.setAbbreviations = function(arg) {
    if (this.sys.setAbbreviations) {
        this.sys.setAbbreviations(arg);
    }
};

CSL.Engine.prototype.setSuppressTrailingPunctuation = function(arg) {
    this.citation.opt.suppressTrailingPunctuation = !!arg;
};

CSL.Output = {};

CSL.Output.Queue = function(state) {
    this.levelname = [ "top" ];
    this.state = state;
    this.queue = [];
    this.empty = new CSL.Token("empty");
    var tokenstore = {};
    tokenstore.empty = this.empty;
    this.formats = new CSL.Stack(tokenstore);
    this.current = new CSL.Stack(this.queue);
};

CSL.Output.Queue.prototype.pop = function() {
    var drip = this.current.value();
    if (drip.length) {
        return drip.pop();
    } else {
        return drip.blobs.pop();
    }
};

CSL.Output.Queue.prototype.getToken = function(name) {
    var ret = this.formats.value()[name];
    return ret;
};

CSL.Output.Queue.prototype.mergeTokenStrings = function(base, modifier) {
    var base_token, modifier_token, ret, key;
    base_token = this.formats.value()[base];
    modifier_token = this.formats.value()[modifier];
    ret = base_token;
    if (modifier_token) {
        if (!base_token) {
            base_token = new CSL.Token(base, CSL.SINGLETON);
            base_token.decorations = [];
        }
        ret = new CSL.Token(base, CSL.SINGLETON);
        var key = "";
        for (var key in base_token.strings) {
            if (base_token.strings.hasOwnProperty(key)) {
                ret.strings[key] = base_token.strings[key];
            }
        }
        for (var key in modifier_token.strings) {
            if (modifier_token.strings.hasOwnProperty(key)) {
                ret.strings[key] = modifier_token.strings[key];
            }
        }
        ret.decorations = base_token.decorations.concat(modifier_token.decorations);
    }
    return ret;
};

CSL.Output.Queue.prototype.addToken = function(name, modifier, token) {
    var newtok, attr;
    newtok = new CSL.Token("output");
    if ("string" === typeof token) {
        token = this.formats.value()[token];
    }
    if (token && token.strings) {
        for (attr in token.strings) {
            if (token.strings.hasOwnProperty(attr)) {
                newtok.strings[attr] = token.strings[attr];
            }
        }
        newtok.decorations = token.decorations;
    }
    if ("string" === typeof modifier) {
        newtok.strings.delimiter = modifier;
    }
    this.formats.value()[name] = newtok;
};

CSL.Output.Queue.prototype.pushFormats = function(tokenstore) {
    if (!tokenstore) {
        tokenstore = {};
    }
    tokenstore.empty = this.empty;
    this.formats.push(tokenstore);
};

CSL.Output.Queue.prototype.popFormats = function() {
    this.formats.pop();
};

CSL.Output.Queue.prototype.startTag = function(name, token) {
    var tokenstore = {};
    if (this.state.tmp["doing-macro-with-date"] && this.state.tmp.extension) {
        token = this.empty;
        name = "empty";
    }
    tokenstore[name] = token;
    this.pushFormats(tokenstore);
    this.openLevel(name);
};

CSL.Output.Queue.prototype.endTag = function(name) {
    this.closeLevel(name);
    this.popFormats();
};

CSL.Output.Queue.prototype.openLevel = function(token) {
    var blob, curr;
    if ("object" === typeof token) {
        blob = new CSL.Blob(undefined, token);
    } else if ("undefined" === typeof token) {
        blob = new CSL.Blob(undefined, this.formats.value().empty, "empty");
    } else {
        if (!this.formats.value() || !this.formats.value()[token]) {
            CSL.error('CSL processor error: call to nonexistent format token "' + token + '"');
        }
        blob = new CSL.Blob(undefined, this.formats.value()[token], token);
    }
    curr = this.current.value();
    if (!this.state.tmp.just_looking && this.checkNestedBrace) {
        blob.strings.prefix = this.checkNestedBrace.update(blob.strings.prefix);
    }
    curr.push(blob);
    this.current.push(blob);
};

CSL.Output.Queue.prototype.closeLevel = function(name) {
    if (name && name !== this.current.value().levelname) {
        CSL.error("Level mismatch error:  wanted " + name + " but found " + this.current.value().levelname);
    }
    var blob = this.current.pop();
    if (!this.state.tmp.just_looking && this.checkNestedBrace) {
        blob.strings.suffix = this.checkNestedBrace.update(blob.strings.suffix);
    }
};

CSL.Output.Queue.prototype.append = function(str, tokname, notSerious, ignorePredecessor, noStripPeriods) {
    var token, blob, curr;
    var useblob = true;
    if (notSerious) {
        ignorePredecessor = true;
    }
    if (this.state.tmp["doing-macro-with-date"] && !notSerious) {
        if (tokname !== "macro-with-date") {
            return false;
        }
        if (tokname === "macro-with-date") {
            tokname = "empty";
        }
    }
    if ("undefined" === typeof str) {
        return false;
    }
    if ("number" === typeof str) {
        str = "" + str;
    }
    if (!notSerious && this.state.tmp.element_trace && this.state.tmp.element_trace.value() === "suppress-me") {
        return false;
    }
    blob = false;
    if (!tokname) {
        token = this.formats.value().empty;
    } else if (tokname === "literal") {
        token = true;
        useblob = false;
    } else if ("string" === typeof tokname) {
        token = this.formats.value()[tokname];
    } else {
        token = tokname;
    }
    if (!token) {
        CSL.error("CSL processor error: unknown format token name: " + tokname);
    }
    if (token.strings && "undefined" === typeof token.strings.delimiter) {
        token.strings.delimiter = "";
    }
    if ("string" === typeof str && str.length) {
        str = str.replace(/ ([:;?!\u00bb])/g, " $1").replace(/\u00ab /g, "« ");
        this.last_char_rendered = str.slice(-1);
        str = str.replace(/\s+'/g, " '");
        if (!notSerious) {
            str = str.replace(/^'/g, " '");
        }
        if (!ignorePredecessor) {
            this.state.tmp.term_predecessor = true;
            this.state.tmp.in_cite_predecessor = true;
        } else if (notSerious) {
            this.state.tmp.term_predecessor_name = true;
        }
    }
    blob = new CSL.Blob(str, token);
    curr = this.current.value();
    if ("undefined" === typeof curr && this.current.mystack.length === 0) {
        this.current.mystack.push([]);
        curr = this.current.value();
    }
    if ("string" === typeof blob.blobs) {
        if (!ignorePredecessor) {
            this.state.tmp.term_predecessor = true;
            this.state.tmp.in_cite_predecessor = true;
        } else if (notSerious) {
            this.state.tmp.term_predecessor_name = true;
        }
    }
    if ("string" === typeof str) {
        if ("string" === typeof blob.blobs) {
            if (blob.blobs.slice(0, 1) !== " ") {
                var blobPrefix = "";
                var blobBlobs = blob.blobs;
                while (CSL.TERMINAL_PUNCTUATION.indexOf(blobBlobs.slice(0, 1)) > -1) {
                    blobPrefix = blobPrefix + blobBlobs.slice(0, 1);
                    blobBlobs = blobBlobs.slice(1);
                }
                if (blobBlobs && blobPrefix) {
                    blob.strings.prefix = blob.strings.prefix + blobPrefix;
                    blob.blobs = blobBlobs;
                }
            }
        }
        if (blob.strings["text-case"]) {
            blob.blobs = CSL.Output.Formatters[blob.strings["text-case"]](this.state, str);
        }
        if (this.state.tmp.strip_periods && !noStripPeriods) {
            blob.blobs = blob.blobs.replace(/\.([^a-z]|$)/g, "$1");
        }
        for (var i = blob.decorations.length - 1; i > -1; i += -1) {
            if (blob.decorations[i][0] === "@quotes" && blob.decorations[i][1] !== "false") {
                blob.punctuation_in_quote = this.state.getOpt("punctuation-in-quote");
            }
            if (!blob.blobs.match(CSL.ROMANESQUE_REGEXP)) {
                if (blob.decorations[i][0] === "@font-style") {
                    blob.decorations = blob.decorations.slice(0, i).concat(blob.decorations.slice(i + 1));
                }
            }
        }
        curr.push(blob);
        this.state.fun.flipflopper.processTags(blob);
    } else if (useblob) {
        curr.push(blob);
    } else {
        curr.push(str);
    }
    return true;
};

CSL.Output.Queue.prototype.string = function(state, myblobs, blob) {
    var i, ilen, j, jlen, b;
    var txt_esc = CSL.getSafeEscape(this.state);
    var blobs = myblobs.slice();
    var ret = [];
    if (blobs.length === 0) {
        return ret;
    }
    var blob_delimiter = "";
    if (blob) {
        blob_delimiter = blob.strings.delimiter;
    } else {
        state.tmp.count_offset_characters = false;
        state.tmp.offset_characters = 0;
    }
    if (blob && blob.new_locale) {
        blob.old_locale = state.opt.lang;
        state.opt.lang = blob.new_locale;
    }
    var blobjr, use_suffix, use_prefix, params;
    for (var i = 0, ilen = blobs.length; i < ilen; i += 1) {
        blobjr = blobs[i];
        if (blobjr.strings.first_blob) {
            state.tmp.count_offset_characters = blobjr.strings.first_blob;
        }
        if ("string" === typeof blobjr.blobs) {
            if ("number" === typeof blobjr.num) {
                ret.push(blobjr);
            } else if (blobjr.blobs) {
                if (blobjr.particle) {
                    blobjr.blobs = blobjr.particle + blobjr.blobs;
                    blobjr.particle = "";
                }
                b = txt_esc(blobjr.blobs);
                var blen = b.length;
                if (!state.tmp.suppress_decorations) {
                    for (j = 0, jlen = blobjr.decorations.length; j < jlen; j += 1) {
                        params = blobjr.decorations[j];
                        if (params[0] === "@showid") {
                            continue;
                        }
                        if (state.normalDecorIsOrphan(blobjr, params)) {
                            continue;
                        }
                        b = state.fun.decorate[params[0]][params[1]].call(blobjr, state, b, params[2]);
                    }
                }
                if (b && b.length) {
                    b = txt_esc(blobjr.strings.prefix) + b + txt_esc(blobjr.strings.suffix);
                    if (state.opt.development_extensions.csl_reverse_lookup_support && !state.tmp.suppress_decorations) {
                        for (j = 0, jlen = blobjr.decorations.length; j < jlen; j += 1) {
                            params = blobjr.decorations[j];
                            if (params[0] === "@showid") {
                                b = state.fun.decorate[params[0]][params[1]].call(blobjr, state, b, params[2]);
                            }
                        }
                    }
                    ret.push(b);
                    if (state.tmp.count_offset_characters) {
                        state.tmp.offset_characters += blen + blobjr.strings.suffix.length + blobjr.strings.prefix.length;
                    }
                }
            }
        } else if (blobjr.blobs.length) {
            var addtoret = state.output.string(state, blobjr.blobs, blobjr);
            if (blob) {
                if ("string" !== addtoret && addtoret.length > 1 && blobjr.strings.delimiter) {
                    var numberSeen = false;
                    for (var j = 0, jlen = addtoret.length; j < jlen; j++) {
                        if ("string" !== typeof addtoret[j]) {
                            numberSeen = true;
                        } else if (numberSeen) {
                            addtoret[j] = blobjr.strings.delimiter + addtoret[j];
                        }
                    }
                }
            }
            ret = ret.concat(addtoret);
        }
        if (blobjr.strings.first_blob && state.registry.registry[blobjr.strings.first_blob]) {
            state.registry.registry[blobjr.strings.first_blob].offset = state.tmp.offset_characters;
            state.tmp.count_offset_characters = false;
        }
    }
    for (i = 0, ilen = ret.length - 1; i < ilen; i += 1) {
        if ("number" === typeof ret[i].num && "number" === typeof ret[i + 1].num && !ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK) {
            ret[i].strings.suffix = ret[i].strings.suffix + (blob_delimiter ? blob_delimiter : "");
            ret[i + 1].successor_prefix = "";
            ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK = true;
        }
    }
    var span_split = 0;
    for (var i = 0, ilen = ret.length; i < ilen; i += 1) {
        if ("string" === typeof ret[i]) {
            span_split = parseInt(i, 10) + 1;
            if (i < ret.length - 1 && "object" === typeof ret[i + 1]) {
                if (blob_delimiter && !ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK) {
                    ret[i] += txt_esc(blob_delimiter);
                }
                ret[i + 1].UGLY_DELIMITER_SUPPRESS_HACK = true;
            }
        }
    }
    if (blob && (blob.decorations.length || blob.strings.suffix)) {
        span_split = ret.length;
    } else if (blob && blob.strings.prefix) {
        for (var i = 0, ilen = ret.length; i < ilen; i++) {
            if ("undefined" !== typeof ret[i].num) {
                span_split = i;
                if (i === 0) {
                    ret[i].strings.prefix = blob.strings.prefix + ret[i].strings.prefix;
                }
                break;
            }
        }
    }
    var blobs_start = state.output.renderBlobs(ret.slice(0, span_split), blob_delimiter, false, blob);
    if (blobs_start && blob && (blob.decorations.length || blob.strings.suffix || blob.strings.prefix)) {
        if (!state.tmp.suppress_decorations) {
            for (var i = 0, ilen = blob.decorations.length; i < ilen; i += 1) {
                params = blob.decorations[i];
                if ([ "@cite", "@bibliography", "@display", "@showid" ].indexOf(params[0]) > -1) {
                    continue;
                }
                if (state.normalDecorIsOrphan(blobjr, params)) {
                    continue;
                }
                if (!params[0]) continue;
                if ("string" === typeof blobs_start) {
                    blobs_start = state.fun.decorate[params[0]][params[1]].call(blob, state, blobs_start, params[2]);
                }
            }
        }
        b = blobs_start;
        use_suffix = blob.strings.suffix;
        if (b && b.length) {
            use_prefix = blob.strings.prefix;
            b = txt_esc(use_prefix) + b + txt_esc(use_suffix);
            if (state.tmp.count_offset_characters) {
                state.tmp.offset_characters += use_prefix.length + use_suffix.length;
            }
        }
        blobs_start = b;
        if (!state.tmp.suppress_decorations) {
            for (var i = 0, ilen = blob.decorations.length; i < ilen; i += 1) {
                params = blob.decorations[i];
                if ([ "@cite", "@bibliography", "@display", "@showid" ].indexOf(params[0]) === -1) {
                    continue;
                }
                if ("string" === typeof blobs_start) {
                    blobs_start = state.fun.decorate[params[0]][params[1]].call(blob, state, blobs_start, params[2]);
                }
            }
        }
    }
    var blobs_end = ret.slice(span_split, ret.length);
    if (!blobs_end.length && blobs_start) {
        ret = [ blobs_start ];
    } else if (blobs_end.length && !blobs_start) {
        ret = blobs_end;
    } else if (blobs_start && blobs_end.length) {
        ret = [ blobs_start ].concat(blobs_end);
    }
    if ("undefined" === typeof blob) {
        this.queue = [];
        this.current.mystack = [];
        this.current.mystack.push(this.queue);
        if (state.tmp.suppress_decorations) {
            ret = state.output.renderBlobs(ret, undefined, false);
        }
    } else if ("boolean" === typeof blob) {
        ret = state.output.renderBlobs(ret, undefined, true);
    }
    if (blob && blob.new_locale) {
        state.opt.lang = blob.old_locale;
    }
    return ret;
};

CSL.Output.Queue.prototype.clearlevel = function() {
    var blob, pos, len;
    blob = this.current.value();
    len = blob.blobs.length;
    for (pos = 0; pos < len; pos += 1) {
        blob.blobs.pop();
    }
};

CSL.Output.Queue.prototype.renderBlobs = function(blobs, delim, in_cite, parent) {
    var state, ret, use_delim, blob, pos, len, ppos, llen, str, params, txt_esc;
    txt_esc = CSL.getSafeEscape(this.state);
    if (!delim) {
        delim = "";
    }
    state = this.state;
    ret = "";
    use_delim = "";
    len = blobs.length;
    if (this.state.tmp.area === "citation" && !this.state.tmp.just_looking && len === 1 && typeof blobs[0] === "object" && parent) {
        blobs[0].strings.prefix = parent.strings.prefix + blobs[0].strings.prefix;
        blobs[0].strings.suffix = blobs[0].strings.suffix + parent.strings.suffix;
        blobs[0].decorations = blobs[0].decorations.concat(parent.decorations);
        blobs[0].params = parent.params;
        return blobs[0];
    }
    var start = true;
    for (pos = 0; pos < len; pos += 1) {
        if (blobs[pos].checkNext) {
            blobs[pos].checkNext(blobs[pos + 1], start);
            start = false;
        } else if (blobs[pos + 1] && blobs[pos + 1].splice_prefix) {
            start = false;
        } else {
            start = true;
        }
    }
    var doit = true;
    for (pos = blobs.length - 1; pos > 0; pos += -1) {
        if (blobs[pos].checkLast) {
            if (doit && blobs[pos].checkLast(blobs[pos - 1])) {
                doit = false;
            }
        } else {
            doit = true;
        }
    }
    len = blobs.length;
    for (pos = 0; pos < len; pos += 1) {
        blob = blobs[pos];
        if (ret) {
            use_delim = delim;
        }
        if ("string" === typeof blob) {
            ret += txt_esc(use_delim);
            ret += blob;
            if (state.tmp.count_offset_characters) {
                state.tmp.offset_characters += use_delim.length;
            }
        } else if (in_cite) {
            if (ret) {
                ret = [ ret, blob ];
            } else {
                ret = [ blob ];
            }
        } else if (blob.status !== CSL.SUPPRESS) {
            if (blob.particle) {
                str = blob.particle + blob.num;
            } else {
                str = blob.formatter.format(blob.num, blob.gender);
            }
            var strlen = str.replace(/<[^>]*>/g, "").length;
            this.append(str, "empty", true);
            var str_blob = this.pop();
            var count_offset_characters = state.tmp.count_offset_characters;
            str = this.string(state, [ str_blob ], false);
            state.tmp.count_offset_characters = count_offset_characters;
            if (blob.strings["text-case"]) {
                str = CSL.Output.Formatters[blob.strings["text-case"]](this.state, str);
            }
            if (str && this.state.tmp.strip_periods) {
                str = str.replace(/\.([^a-z]|$)/g, "$1");
            }
            if (!state.tmp.suppress_decorations) {
                llen = blob.decorations.length;
                for (ppos = 0; ppos < llen; ppos += 1) {
                    params = blob.decorations[ppos];
                    if (state.normalDecorIsOrphan(blob, params)) {
                        continue;
                    }
                    str = state.fun.decorate[params[0]][params[1]].call(blob, state, str, params[2]);
                }
            }
            str = txt_esc(blob.strings.prefix) + str + txt_esc(blob.strings.suffix);
            var addme = "";
            if (blob.status === CSL.END) {
                addme = txt_esc(blob.range_prefix);
            } else if (blob.status === CSL.SUCCESSOR) {
                addme = txt_esc(blob.successor_prefix);
            } else if (blob.status === CSL.START) {
                if (pos > 0 && !blob.suppress_splice_prefix) {
                    addme = txt_esc(blob.splice_prefix);
                } else {
                    addme = "";
                }
            } else if (blob.status === CSL.SEEN) {
                addme = txt_esc(blob.splice_prefix);
            }
            ret += addme;
            ret += str;
            if (state.tmp.count_offset_characters) {
                state.tmp.offset_characters += addme.length + blob.strings.prefix.length + strlen + blob.strings.suffix.length;
            }
        }
    }
    return ret;
};

CSL.Output.Queue.purgeEmptyBlobs = function(parent) {
    if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
        return;
    }
    for (var i = parent.blobs.length - 1; i > -1; i--) {
        CSL.Output.Queue.purgeEmptyBlobs(parent.blobs[i]);
        var child = parent.blobs[i];
        if (!child || !child.blobs || !child.blobs.length) {
            var buf = [];
            while (parent.blobs.length - 1 > i) {
                buf.push(parent.blobs.pop());
            }
            parent.blobs.pop();
            while (buf.length) {
                parent.blobs.push(buf.pop());
            }
        }
    }
};

CSL.Output.Queue.adjust = function(punctInQuote) {
    var NO_SWAP_IN = {
        ";": true,
        ":": true
    };
    var NO_SWAP_OUT = {
        ".": true,
        "!": true,
        "?": true
    };
    var LtoR_MAP = {
        "!": {
            ".": "!",
            "?": "!?",
            ":": "!",
            ",": "!,",
            ";": "!;"
        },
        "?": {
            "!": "?!",
            ".": "?",
            ":": "?",
            ",": "?,",
            ";": "?;"
        },
        ".": {
            "!": ".!",
            "?": ".?",
            ":": ".:",
            ",": ".,",
            ";": ".;"
        },
        ":": {
            "!": "!",
            "?": "?",
            ".": ":",
            ",": ":,",
            ";": ":;"
        },
        ",": {
            "!": ",!",
            "?": ",?",
            ":": ",:",
            ".": ",.",
            ";": ",;"
        },
        ";": {
            "!": "!",
            "?": "?",
            ":": ";",
            ",": ";,",
            ".": ";"
        }
    };
    var SWAP_IN = {};
    var SWAP_OUT = {};
    var PUNCT = {};
    var PUNCT_OR_SPACE = {};
    for (var key in LtoR_MAP) {
        PUNCT[key] = true;
        PUNCT_OR_SPACE[key] = true;
        if (!NO_SWAP_IN[key]) {
            SWAP_IN[key] = true;
        }
        if (!NO_SWAP_OUT[key]) {
            SWAP_OUT[key] = true;
        }
    }
    PUNCT_OR_SPACE[" "] = true;
    PUNCT_OR_SPACE[" "] = true;
    var RtoL_MAP = {};
    for (var key in LtoR_MAP) {
        for (var subkey in LtoR_MAP[key]) {
            if (!RtoL_MAP[subkey]) {
                RtoL_MAP[subkey] = {};
            }
            RtoL_MAP[subkey][key] = LtoR_MAP[key][subkey];
        }
    }
    function blobIsNumber(blob) {
        return "number" === typeof blob.num || blob.blobs && blob.blobs.length === 1 && "number" === typeof blob.blobs[0].num;
    }
    function blobEndsInNumber(blob) {
        if ("number" === typeof blob.num) {
            return true;
        }
        if (!blob.blobs || "object" !== typeof blob.blobs) {
            return false;
        }
        if (blobEndsInNumber(blob.blobs[blob.blobs.length - 1])) {
            return true;
        }
    }
    function blobHasDecorations(blob, includeQuotes) {
        var ret = false;
        var decorlist = [ "@font-style", "@font-variant", "@font-weight", "@text-decoration", "@vertical-align" ];
        if (includeQuotes) {
            decorlist.push("@quotes");
        }
        if (blob.decorations) {
            for (var i = 0, ilen = blob.decorations.length; i < ilen; i++) {
                if (decorlist.indexOf(blob.decorations[i][0]) > -1) {
                    ret = true;
                    break;
                }
            }
        }
        return ret;
    }
    function blobHasDescendantQuotes(blob) {
        if (blob.decorations) {
            for (var i = 0, ilen = blob.decorations.length; i < ilen; i++) {
                if (blob.decorations[i][0] === "@quotes" && blob.decorations[i][1] !== "false") {
                    return true;
                }
            }
        }
        if ("object" !== typeof blob.blobs) {
            return false;
        }
        return blobHasDescendantQuotes(blob.blobs[blob.blobs.length - 1]);
    }
    function blobHasDescendantMergingPunctuation(parentChar, blob) {
        var childChar = blob.strings.suffix.slice(-1);
        if (!childChar && "string" === typeof blob.blobs) {
            childChar = blob.blobs.slice(-1);
        }
        var mergedChars = RtoL_MAP[parentChar][childChar];
        if (mergedChars && mergedChars.length === 1) {
            return true;
        }
        if ("object" !== typeof blob.blobs) {
            return false;
        }
        if (blobHasDescendantMergingPunctuation(parentChar, blob.blobs[blob.blobs.length - 1])) {
            return true;
        }
        return false;
    }
    function matchLastChar(blob, chr) {
        if (!PUNCT[chr]) {
            return false;
        }
        if ("string" === typeof blob.blobs) {
            if (blob.blobs.slice(-1) === chr) {
                return true;
            } else {
                return false;
            }
        } else {
            var child = blob.blobs[blob.blobs.length - 1];
            if (child) {
                var childChar = child.strings.suffix.slice(-1);
                if (!childChar) {
                    return matchLastChar(child, chr);
                } else if (child.strings.suffix.slice(-1) == chr) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
    }
    function mergeChars(First, first, Second, second, merge_right) {
        var FirstStrings = "blobs" === first ? First : First.strings;
        var SecondStrings = "blobs" === second ? Second : Second.strings;
        var firstChar = FirstStrings[first].slice(-1);
        var secondChar = SecondStrings[second].slice(0, 1);
        function cullRight() {
            SecondStrings[second] = SecondStrings[second].slice(1);
        }
        function cullLeft() {
            FirstStrings[first] = FirstStrings[first].slice(0, -1);
        }
        function addRight(chr) {
            SecondStrings[second] = chr + SecondStrings[second];
        }
        function addLeft(chr) {
            FirstStrings[first] += chr;
        }
        var cull = merge_right ? cullLeft : cullRight;
        function matchOnRight() {
            return RtoL_MAP[secondChar];
        }
        function matchOnLeft() {
            return LtoR_MAP[firstChar];
        }
        var match = merge_right ? matchOnLeft : matchOnRight;
        function mergeToRight() {
            var chr = LtoR_MAP[firstChar][secondChar];
            if ("string" === typeof chr) {
                cullLeft();
                cullRight();
                addRight(chr);
            } else {
                addRight(firstChar);
                cullLeft();
            }
        }
        function mergeToLeft() {
            var chr = RtoL_MAP[secondChar][firstChar];
            if ("string" === typeof chr) {
                cullLeft();
                cullRight();
                addLeft(chr);
            } else {
                addLeft(secondChar);
                cullRight();
            }
        }
        var merge = merge_right ? mergeToRight : mergeToLeft;
        var isDuplicate = firstChar === secondChar;
        if (isDuplicate) {
            cull();
        } else {
            if (match()) {
                merge();
            }
        }
    }
    function upward(parent) {
        if (parent.blobs && "string" == typeof parent.blobs) {
            if (PUNCT[parent.strings.suffix.slice(0, 1)] && parent.strings.suffix.slice(0, 1) === parent.blobs.slice(-1)) {
                parent.strings.suffix = parent.strings.suffix.slice(1);
            }
            return;
        } else if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
            return;
        }
        var parentDecorations = blobHasDecorations(parent, true);
        for (var i = parent.blobs.length - 1; i > -1; i--) {
            this.upward(parent.blobs[i]);
            var parentStrings = parent.strings;
            var childStrings = parent.blobs[i].strings;
            if (i === 0) {
                if (" " === parentStrings.prefix.slice(-1) && " " === childStrings.prefix.slice(0, 1)) {
                    childStrings.prefix = childStrings.prefix.slice(1);
                }
                var childChar = childStrings.prefix.slice(0, 1);
                if (!parentDecorations && PUNCT_OR_SPACE[childChar] && !parentStrings.prefix) {
                    parentStrings.prefix += childChar;
                    childStrings.prefix = childStrings.prefix.slice(1);
                }
            }
            if (i === parent.blobs.length - 1) {
                var childChar = childStrings.suffix.slice(-1);
                if (!parentDecorations && [ " " ].indexOf(childChar) > -1) {
                    if (parentStrings.suffix.slice(0, 1) !== childChar) {
                        parentStrings.suffix = childChar + parentStrings.suffix;
                    }
                    childStrings.suffix = childStrings.suffix.slice(0, -1);
                }
            }
            if (parentStrings.delimiter && i > 0) {
                if (PUNCT_OR_SPACE[parentStrings.delimiter.slice(-1)] && parentStrings.delimiter.slice(-1) === childStrings.prefix.slice(0, 1)) {
                    childStrings.prefix = childStrings.prefix.slice(1);
                }
            }
        }
    }
    function leftward(parent) {
        if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
            return;
        }
        for (var i = parent.blobs.length - 1; i > -1; i--) {
            this.leftward(parent.blobs[i]);
            if (i < parent.blobs.length - 1 && !parent.strings.delimiter) {
                var child = parent.blobs[i];
                var childChar = child.strings.suffix.slice(-1);
                var sibling = parent.blobs[i + 1];
                var siblingChar = sibling.strings.prefix.slice(0, 1);
                var hasDecorations = blobHasDecorations(child) || blobHasDecorations(sibling);
                var hasNumber = "number" === typeof childChar || "number" === typeof siblingChar;
                if (!hasDecorations && !hasNumber && PUNCT[siblingChar] && !hasNumber) {
                    var suffixAndPrefixMatch = siblingChar === child.strings.suffix.slice(-1);
                    var suffixAndFieldMatch = !child.strings.suffix && "string" === typeof child.blobs && child.blobs.slice(-1) === siblingChar;
                    if (!suffixAndPrefixMatch && !suffixAndFieldMatch) {
                        mergeChars(child, "suffix", sibling, "prefix");
                    } else {
                        sibling.strings.prefix = sibling.strings.prefix.slice(1);
                    }
                }
            }
        }
    }
    function downward(parent) {
        if (parent.blobs && "string" == typeof parent.blobs) {
            if (PUNCT[parent.strings.suffix.slice(0, 1)] && parent.strings.suffix.slice(0, 1) === parent.blobs.slice(-1)) {
                parent.strings.suffix = parent.strings.suffix.slice(1);
            }
            return;
        } else if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
            return;
        }
        var parentStrings = parent.strings;
        for (var i = 0, ilen = parent.blobs.length; i < ilen; i++) {
            if (blobIsNumber(parent.blobs[i])) {
                break;
            }
        }
        {
            if (parentStrings.delimiter && PUNCT[parentStrings.delimiter.slice(0, 1)]) {
                var delimChar = parentStrings.delimiter.slice(0, 1);
                for (var i = parent.blobs.length - 2; i > -1; i--) {
                    var childStrings = parent.blobs[i].strings;
                    if (childStrings.suffix.slice(-1) !== delimChar) {
                        childStrings.suffix += delimChar;
                    }
                }
                parentStrings.delimiter = parentStrings.delimiter.slice(1);
            }
        }
        for (var i = parent.blobs.length - 1; i > -1; i--) {
            var child = parent.blobs[i];
            var childStrings = parent.blobs[i].strings;
            var childDecorations = blobHasDecorations(child, true);
            var childIsNumber = blobIsNumber(child);
            if (i === parent.blobs.length - 1) {
                {
                    var parentChar = parentStrings.suffix.slice(0, 1);
                    var allowMigration = false;
                    if (PUNCT[parentChar]) {
                        allowMigration = blobHasDescendantMergingPunctuation(parentChar, child);
                        if (!allowMigration && punctInQuote) {
                            allowMigration = blobHasDescendantQuotes(child);
                        }
                    }
                    if (allowMigration) {
                        if (PUNCT[parentChar]) {
                            if (!blobEndsInNumber(child)) {
                                if ("string" === typeof child.blobs) {
                                    mergeChars(child, "blobs", parent, "suffix");
                                } else {
                                    mergeChars(child, "suffix", parent, "suffix");
                                }
                                if (parentStrings.suffix.slice(0, 1) === ".") {
                                    childStrings.suffix += parentStrings.suffix.slice(0, 1);
                                    parentStrings.suffix = parentStrings.suffix.slice(1);
                                }
                            }
                        }
                    }
                    if (childStrings.suffix.slice(-1) === " " && parentStrings.suffix.slice(0, 1) === " ") {
                        parentStrings.suffix = parentStrings.suffix.slice(1);
                    }
                    if (PUNCT_OR_SPACE[childStrings.suffix.slice(0, 1)]) {
                        if ("string" === typeof child.blobs && child.blobs.slice(-1) === childStrings.suffix.slice(0, 1)) {
                            childStrings.suffix = childStrings.suffix.slice(1);
                        }
                        if (childStrings.suffix.slice(-1) === parentStrings.suffix.slice(0, 1)) {
                            parentStrings.suffix = parentStrings.suffix.slice(0, -1);
                        }
                    }
                }
                if (matchLastChar(parent, parent.strings.suffix.slice(0, 1))) {
                    parent.strings.suffix = parent.strings.suffix.slice(1);
                }
            } else if (parentStrings.delimiter) {
                if (PUNCT_OR_SPACE[parentStrings.delimiter.slice(0, 1)] && parentStrings.delimiter.slice(0, 1) === childStrings.suffix.slice(-1)) {
                    parent.blobs[i].strings.suffix = parent.blobs[i].strings.suffix.slice(0, -1);
                }
            } else {
                var siblingStrings = parent.blobs[i + 1].strings;
                if (!blobIsNumber(child) && !childDecorations && PUNCT_OR_SPACE[childStrings.suffix.slice(-1)] && childStrings.suffix.slice(-1) === siblingStrings.prefix.slice(0, 1)) {
                    siblingStrings.prefix = siblingStrings.prefix.slice(1);
                }
            }
            if (!childIsNumber && !childDecorations && PUNCT[childStrings.suffix.slice(0, 1)] && "string" === typeof child.blobs) {
                mergeChars(child, "blobs", child, "suffix");
            }
            this.downward(parent.blobs[i]);
        }
    }
    function swapToTheLeft(child) {
        var childChar = child.strings.suffix.slice(0, 1);
        if ("string" === typeof child.blobs) {
            while (SWAP_IN[childChar]) {
                mergeChars(child, "blobs", child, "suffix");
                childChar = child.strings.suffix.slice(0, 1);
            }
        } else {
            while (SWAP_IN[childChar]) {
                mergeChars(child.blobs[child.blobs.length - 1], "suffix", child, "suffix");
                childChar = child.strings.suffix.slice(0, 1);
            }
        }
    }
    function swapToTheRight(child) {
        if ("string" === typeof child.blobs) {
            var childChar = child.blobs.slice(-1);
            while (SWAP_OUT[childChar]) {
                mergeChars(child, "blobs", child, "suffix", true);
                childChar = child.blobs.slice(-1);
            }
        } else {
            var childChar = child.blobs[child.blobs.length - 1].strings.suffix.slice(-1);
            while (SWAP_OUT[childChar]) {
                mergeChars(child.blobs[child.blobs.length - 1], "suffix", child, "suffix", true);
                childChar = child.blobs[child.blobs.length - 1].strings.suffix.slice(-1);
            }
        }
    }
    function fix(parent) {
        if ("object" !== typeof parent || "object" !== typeof parent.blobs || !parent.blobs.length) {
            return;
        }
        var lastChar;
        for (var i = 0, ilen = parent.blobs.length; i < ilen; i++) {
            var child = parent.blobs[i];
            var quoteSwap = false;
            for (var j = 0, jlen = child.decorations.length; j < jlen; j++) {
                var decoration = child.decorations[j];
                if (decoration[0] === "@quotes" && decoration[1] !== "false") {
                    quoteSwap = true;
                }
            }
            if (quoteSwap) {
                if (punctInQuote) {
                    swapToTheLeft(child);
                } else {
                    swapToTheRight(child);
                }
            }
            lastChar = this.fix(parent.blobs[i]);
            if (child.blobs && "string" === typeof child.blobs) {
                lastChar = child.blobs.slice(-1);
            }
        }
        return lastChar;
    }
    this.upward = upward;
    this.leftward = leftward;
    this.downward = downward;
    this.fix = fix;
};

CSL.Engine.Opt = function() {
    this.parallel = {
        enable: false
    }, this.has_disambiguate = false;
    this.mode = "html";
    this.dates = {};
    this.jurisdictions_seen = {};
    this.suppressedJurisdictions = {};
    this.inheritedAttributes = {};
    this["locale-sort"] = [];
    this["locale-translit"] = [];
    this["locale-translat"] = [];
    this.citeAffixes = {
        persons: {
            "locale-orig": {
                prefix: "",
                suffix: ""
            },
            "locale-translit": {
                prefix: "",
                suffix: ""
            },
            "locale-translat": {
                prefix: "",
                suffix: ""
            }
        },
        institutions: {
            "locale-orig": {
                prefix: "",
                suffix: ""
            },
            "locale-translit": {
                prefix: "",
                suffix: ""
            },
            "locale-translat": {
                prefix: "",
                suffix: ""
            }
        },
        titles: {
            "locale-orig": {
                prefix: "",
                suffix: ""
            },
            "locale-translit": {
                prefix: "",
                suffix: ""
            },
            "locale-translat": {
                prefix: "",
                suffix: ""
            }
        },
        journals: {
            "locale-orig": {
                prefix: "",
                suffix: ""
            },
            "locale-translit": {
                prefix: "",
                suffix: ""
            },
            "locale-translat": {
                prefix: "",
                suffix: ""
            }
        },
        publishers: {
            "locale-orig": {
                prefix: "",
                suffix: ""
            },
            "locale-translit": {
                prefix: "",
                suffix: ""
            },
            "locale-translat": {
                prefix: "",
                suffix: ""
            }
        },
        places: {
            "locale-orig": {
                prefix: "",
                suffix: ""
            },
            "locale-translit": {
                prefix: "",
                suffix: ""
            },
            "locale-translat": {
                prefix: "",
                suffix: ""
            }
        }
    };
    this["default-locale"] = [];
    this.update_mode = CSL.NONE;
    this.bib_mode = CSL.NONE;
    this.sort_citations = false;
    this["et-al-min"] = 0;
    this["et-al-use-first"] = 1;
    this["et-al-use-last"] = false;
    this["et-al-subsequent-min"] = false;
    this["et-al-subsequent-use-first"] = false;
    this["demote-non-dropping-particle"] = "display-and-sort";
    this["parse-names"] = true;
    this.citation_number_slug = false;
    this.trigraph = "Aaaa00:AaAa00:AaAA00:AAAA00";
    this.nodenames = [];
    this.gender = {};
    this["cite-lang-prefs"] = {
        persons: [ "orig" ],
        institutions: [ "orig" ],
        titles: [ "orig" ],
        journals: [ "orig" ],
        publishers: [ "orig" ],
        places: [ "orig" ],
        number: [ "orig" ]
    };
    this.has_layout_locale = false;
    this.disable_duplicate_year_suppression = [];
    this.use_context_condition = false;
    this.jurisdiction_fallbacks = {};
    this.development_extensions = {};
    this.development_extensions.field_hack = true;
    this.development_extensions.allow_field_hack_date_override = true;
    this.development_extensions.locator_date_and_revision = true;
    this.development_extensions.locator_label_parse = true;
    this.development_extensions.raw_date_parsing = true;
    this.development_extensions.clean_up_csl_flaws = true;
    this.development_extensions.consolidate_legal_items = false;
    this.development_extensions.csl_reverse_lookup_support = false;
    this.development_extensions.wrap_url_and_doi = false;
    this.development_extensions.thin_non_breaking_space_html_hack = false;
    this.development_extensions.apply_citation_wrapper = false;
    this.development_extensions.main_title_from_short_title = false;
    this.development_extensions.uppercase_subtitles = false;
    this.development_extensions.normalize_lang_keys_to_lowercase = false;
    this.development_extensions.strict_text_case_locales = false;
    this.development_extensions.expect_and_symbol_form = false;
    this.development_extensions.require_explicit_legal_case_title_short = false;
    this.development_extensions.spoof_institutional_affiliations = false;
    this.development_extensions.force_jurisdiction = false;
    this.development_extensions.parse_names = true;
    this.development_extensions.hanging_indent_legacy_number = false;
    this.development_extensions.throw_on_empty = false;
    this.development_extensions.strict_inputs = true;
    this.development_extensions.prioritize_disambiguate_condition = false;
    this.development_extensions.force_short_title_casing_alignment = true;
    this.development_extensions.implicit_short_title = false;
    this.development_extensions.force_title_abbrev_fallback = false;
    this.development_extensions.split_container_title = false;
    this.development_extensions.legacy_institution_name_ordering = false;
    this.development_extensions.etal_min_etal_usefirst_hack = false;
};

CSL.Engine.Tmp = function() {
    this.names_max = new CSL.Stack;
    this.names_base = new CSL.Stack;
    this.givens_base = new CSL.Stack;
    this.value = [];
    this.namepart_decorations = {};
    this.namepart_type = false;
    this.area = "citation";
    this.root = "citation";
    this.extension = "";
    this.can_substitute = new CSL.Stack(0, CSL.LITERAL);
    this.element_rendered_ok = false;
    this.element_trace = new CSL.Stack("style");
    this.nameset_counter = 0;
    this.group_context = new CSL.Stack({
        term_intended: false,
        variable_attempt: false,
        variable_success: false,
        output_tip: undefined,
        label_form: undefined,
        parallel_first: undefined,
        parallel_last: undefined,
        parallel_delimiter_override: undefined,
        condition: false,
        force_suppress: false,
        done_vars: []
    });
    this.term_predecessor = false;
    this.in_cite_predecessor = false;
    this.jump = new CSL.Stack(0, CSL.LITERAL);
    this.decorations = new CSL.Stack;
    this.tokenstore_stack = new CSL.Stack;
    this.last_suffix_used = "";
    this.last_names_used = [];
    this.last_years_used = [];
    this.years_used = [];
    this.names_used = [];
    this.taintedItemIDs = {};
    this.taintedCitationIDs = {};
    this.initialize_with = new CSL.Stack;
    this.disambig_request = false;
    this["name-as-sort-order"] = false;
    this.suppress_decorations = false;
    this.disambig_settings = new CSL.AmbigConfig;
    this.bib_sort_keys = [];
    this.prefix = new CSL.Stack("", CSL.LITERAL);
    this.suffix = new CSL.Stack("", CSL.LITERAL);
    this.delimiter = new CSL.Stack("", CSL.LITERAL);
    this.cite_locales = [];
    this.cite_affixes = {
        citation: false,
        bibliography: false,
        citation_sort: false,
        bibliography_sort: false
    };
    this.strip_periods = 0;
    this.shadow_numbers = {};
    this.authority_stop_last = 0;
    this.loadedItemIDs = {};
    this.condition_counter = 0;
    this.condition_lang_val_arr = [];
    this.condition_lang_counter_arr = [];
};

CSL.Engine.Fun = function(state) {
    this.match = new CSL.Util.Match;
    this.suffixator = new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);
    this.romanizer = new CSL.Util.Romanizer;
    this.ordinalizer = new CSL.Util.Ordinalizer(state);
    this.long_ordinalizer = new CSL.Util.LongOrdinalizer;
};

CSL.Engine.Build = function() {
    this["alternate-term"] = false;
    this.in_bibliography = false;
    this.in_style = false;
    this.skip = false;
    this.postponed_macro = false;
    this.layout_flag = false;
    this.name = false;
    this.names_variables = [ [] ];
    this.name_label = [ {} ];
    this.form = false;
    this.term = false;
    this.macro = {};
    this.macro_stack = [];
    this.text = false;
    this.lang = false;
    this.area = "citation";
    this.root = "citation";
    this.extension = "";
    this.substitute_level = new CSL.Stack(0, CSL.LITERAL);
    this.names_level = 0;
    this.render_nesting_level = 0;
    this.render_seen = false;
    this.bibliography_key_pos = 0;
};

CSL.Engine.Configure = function() {
    this.tests = [];
    this.fail = [];
    this.succeed = [];
};

CSL.Engine.Citation = function(state) {
    this.opt = {
        inheritedAttributes: {}
    };
    this.tokens = [];
    this.srt = new CSL.Registry.Comparifier(state, "citation_sort");
    this.opt.collapse = [];
    this.opt["disambiguate-add-names"] = false;
    this.opt["disambiguate-add-givenname"] = false;
    this.opt["disambiguate-add-year-suffix"] = false;
    this.opt["givenname-disambiguation-rule"] = "by-cite";
    this.opt["near-note-distance"] = 5;
    this.opt.topdecor = [];
    this.opt.layout_decorations = [];
    this.opt.layout_prefix = "";
    this.opt.layout_suffix = "";
    this.opt.layout_delimiter = "";
    this.opt.sort_locales = [];
    this.opt.max_number_of_names = 0;
    this.root = "citation";
};

CSL.Engine.Bibliography = function() {
    this.opt = {
        inheritedAttributes: {}
    };
    this.tokens = [];
    this.opt.collapse = [];
    this.opt.topdecor = [];
    this.opt.layout_decorations = [];
    this.opt.layout_prefix = "";
    this.opt.layout_suffix = "";
    this.opt.layout_delimiter = "";
    this.opt["line-spacing"] = 1;
    this.opt["entry-spacing"] = 1;
    this.opt.sort_locales = [];
    this.opt.max_number_of_names = 0;
    this.root = "bibliography";
};

CSL.Engine.BibliographySort = function() {
    this.tokens = [];
    this.opt = {};
    this.opt.sort_directions = [];
    this.opt.topdecor = [];
    this.opt.citation_number_sort_direction = CSL.ASCENDING;
    this.opt.citation_number_secondary = false;
    this.tmp = {};
    this.keys = [];
    this.root = "bibliography";
};

CSL.Engine.CitationSort = function() {
    this.tokens = [];
    this.opt = {};
    this.opt.sort_directions = [];
    this.keys = [];
    this.opt.topdecor = [];
    this.root = "citation";
};

CSL.Engine.InText = function() {
    this.opt = {
        inheritedAttributes: {}
    };
    this.tokens = [];
    this.opt.collapse = [];
    this.opt["disambiguate-add-names"] = false;
    this.opt["disambiguate-add-givenname"] = false;
    this.opt["disambiguate-add-year-suffix"] = false;
    this.opt["givenname-disambiguation-rule"] = "by-cite";
    this.opt["near-note-distance"] = 5;
    this.opt.topdecor = [];
    this.opt.layout_decorations = [];
    this.opt.layout_prefix = "";
    this.opt.layout_suffix = "";
    this.opt.layout_delimiter = "";
    this.opt.sort_locales = [];
    this.opt.max_number_of_names = 0;
    this.root = "intext";
};

CSL.Engine.prototype.previewCitationCluster = function(citation, citationsPre, citationsPost, newMode) {
    var oldMode = this.opt.mode;
    this.setOutputFormat(newMode);
    if (citation.citationID) {
        delete citation.citationID;
    }
    var ret = this.processCitationCluster(citation, citationsPre, citationsPost, CSL.PREVIEW);
    this.setOutputFormat(oldMode);
    return ret[1];
};

CSL.Engine.prototype.appendCitationCluster = function(citation) {
    var citationsPre = [];
    var len = this.registry.citationreg.citationByIndex.length;
    for (var pos = 0; pos < len; pos += 1) {
        var c = this.registry.citationreg.citationByIndex[pos];
        citationsPre.push([ "" + c.citationID, c.properties.noteIndex ]);
    }
    return this.processCitationCluster(citation, citationsPre, [])[1];
};

CSL.Engine.prototype.processCitationCluster = function(citation, citationsPre, citationsPost, flag) {
    var c, preCitation, postCitation, i, ilen, j, jlen, k, klen, n, nlen, key, Item, item, noteCitations, textCitations, m, citationsInNote;
    this.debug = false;
    this.tmp.loadedItemIDs = {};
    this.tmp.citation_errors = [];
    this.registry.return_data = {
        bibchange: false
    };
    this.setCitationId(citation);
    var oldCitationList;
    var oldItemList;
    var oldAmbigs;
    if (flag === CSL.PREVIEW) {
        if (this.debug) {
            CSL.debug("****** start state save *********");
        }
        oldCitationList = this.registry.citationreg.citationByIndex.slice();
        oldItemList = this.registry.reflist.slice();
        var newCitationList = citationsPre.concat(citationsPost);
        var newItemIds = {};
        var newItemIdsList = [];
        for (var i = 0, ilen = newCitationList.length; i < ilen; i += 1) {
            c = this.registry.citationreg.citationById[newCitationList[i][0]];
            for (j = 0, jlen = c.citationItems.length; j < jlen; j += 1) {
                newItemIds[c.citationItems[j].id] = true;
                newItemIdsList.push("" + c.citationItems[j].id);
            }
        }
        for (j = 0, jlen = citation.citationItems.length; j < jlen; j += 1) {
            newItemIds[citation.citationItems[j].id] = true;
            newItemIdsList.push("" + citation.citationItems[j].id);
        }
        oldAmbigs = {};
        for (var i = 0, ilen = oldItemList.length; i < ilen; i += 1) {
            if (!newItemIds[oldItemList[i].id]) {
                var oldAkey = this.registry.registry[oldItemList[i].id].ambig;
                var ids = this.registry.ambigcites[oldAkey];
                if (ids) {
                    for (j = 0, jlen = ids.length; j < jlen; j += 1) {
                        oldAmbigs[ids[j]] = CSL.cloneAmbigConfig(this.registry.registry[ids[j]].disambig);
                    }
                }
            }
        }
        if (this.debug) {
            CSL.debug("****** end state save *********");
        }
    }
    this.tmp.taintedCitationIDs = {};
    var sortedItems = [];
    var rerunAkeys = {};
    for (var i = 0, ilen = citation.citationItems.length; i < ilen; i += 1) {
        item = {};
        for (var key in citation.citationItems[i]) {
            item[key] = citation.citationItems[i][key];
        }
        Item = this.retrieveItem("" + item.id);
        if (Item.id) {
            this.transform.loadAbbreviation("default", "hereinafter", Item.id, Item.language);
        }
        item = CSL.parseLocator.call(this, item);
        if (this.opt.development_extensions.consolidate_legal_items) {
            this.remapSectionVariable([ [ Item, item ] ]);
        }
        if (this.opt.development_extensions.locator_label_parse) {
            if (item.locator && [ "bill", "gazette", "legislation", "regulation", "treaty" ].indexOf(Item.type) === -1 && (!item.label || item.label === "page")) {
                var m = CSL.LOCATOR_LABELS_REGEXP.exec(item.locator);
                if (m) {
                    var tryLabel = CSL.LOCATOR_LABELS_MAP[m[2]];
                    if (this.getTerm(tryLabel)) {
                        item.label = tryLabel;
                        item.locator = m[3];
                    }
                }
            }
        }
        var newitem = [ Item, item ];
        sortedItems.push(newitem);
        citation.citationItems[i].item = Item;
    }
    citation.sortedItems = sortedItems;
    var citationByIndex = [];
    var citationById = {};
    var lastNotePos;
    for (i = 0, ilen = citationsPre.length; i < ilen; i += 1) {
        preCitation = citationsPre[i];
        if (this.opt.development_extensions.strict_inputs) {
            if (citationById[preCitation[0]]) {
                CSL.error("Previously referenced citationID " + preCitation[0] + " encountered in citationsPre");
            }
            if (preCitation[1]) {
                if (lastNotePos > preCitation[1]) {
                    CSL.debug("Note index sequence is not sane at citationsPre[" + i + "]");
                }
                lastNotePos = preCitation[1];
            }
        }
        this.registry.citationreg.citationById[preCitation[0]].properties.noteIndex = preCitation[1];
        citationByIndex.push(this.registry.citationreg.citationById[preCitation[0]]);
        citationById[preCitation[0]] = this.registry.citationreg.citationById[preCitation[0]];
    }
    if (!citation.properties) {
        citation.properties = {
            noteIndex: 0
        };
    }
    if (this.opt.development_extensions.strict_inputs) {
        if (citationById[citation.citationID]) {
            CSL.error("Citation with previously referenced citationID " + citation.citationID);
        }
        if (citation.properties.noteIndex) {
            if (lastNotePos > citation.properties.noteIndex) {
                CSL.debug("Note index sequence is not sane for citation " + citation.citationID);
            }
            lastNotePos = citation.properties.noteIndex;
        }
    }
    citationByIndex.push(citation);
    citationById[citation.citationID] = citation;
    for (i = 0, ilen = citationsPost.length; i < ilen; i += 1) {
        postCitation = citationsPost[i];
        if (this.opt.development_extensions.strict_inputs) {
            if (citationById[postCitation[0]]) {
                CSL.error("Previously referenced citationID " + postCitation[0] + " encountered in citationsPost");
            }
            if (postCitation[1]) {
                if (lastNotePos > postCitation[1]) {
                    CSL.debug("Note index sequence is not sane at postCitation[" + i + "]");
                }
                lastNotePos = postCitation[1];
            }
        }
        this.registry.citationreg.citationById[postCitation[0]].properties.noteIndex = postCitation[1];
        citationByIndex.push(this.registry.citationreg.citationById[postCitation[0]]);
        citationById[postCitation[0]] = this.registry.citationreg.citationById[postCitation[0]];
    }
    this.registry.citationreg.citationByIndex = citationByIndex;
    this.registry.citationreg.citationById = citationById;
    this.registry.citationreg.citationsByItemId = {};
    if (this.opt.update_mode === CSL.POSITION) {
        textCitations = [];
        noteCitations = [];
        citationsInNote = {};
    }
    var update_items = [];
    for (var i = 0, ilen = citationByIndex.length; i < ilen; i += 1) {
        citationByIndex[i].properties.index = i;
        for (j = 0, jlen = citationByIndex[i].sortedItems.length; j < jlen; j += 1) {
            item = citationByIndex[i].sortedItems[j];
            if (!this.registry.citationreg.citationsByItemId[item[1].id]) {
                this.registry.citationreg.citationsByItemId[item[1].id] = [];
                update_items.push("" + item[1].id);
            }
            if (this.registry.citationreg.citationsByItemId[item[1].id].indexOf(citationByIndex[i]) === -1) {
                this.registry.citationreg.citationsByItemId[item[1].id].push(citationByIndex[i]);
            }
        }
        if (this.opt.update_mode === CSL.POSITION) {
            if (citationByIndex[i].properties.noteIndex) {
                noteCitations.push(citationByIndex[i]);
            } else {
                citationByIndex[i].properties.noteIndex = 0;
                textCitations.push(citationByIndex[i]);
            }
        }
    }
    if (flag !== CSL.ASSUME_ALL_ITEMS_REGISTERED) {
        if (this.debug) {
            CSL.debug("****** start update items *********");
        }
        this.updateItems(update_items, null, null, true);
        if (this.debug) {
            CSL.debug("****** endo update items *********");
        }
    }
    if (!this.opt.citation_number_sort && sortedItems && sortedItems.length > 1 && this.citation_sort.tokens.length > 0) {
        for (var i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
            sortedItems[i][1].sortkeys = CSL.getSortKeys.call(this, sortedItems[i][0], "citation_sort");
        }
        if (this.opt.grouped_sort && !citation.properties.unsorted) {
            for (var i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
                var sortkeys = sortedItems[i][1].sortkeys;
                this.tmp.authorstring_request = true;
                var mydisambig = this.registry.registry[sortedItems[i][0].id].disambig;
                this.tmp.authorstring_request = true;
                CSL.getAmbiguousCite.call(this, sortedItems[i][0], mydisambig);
                var authorstring = this.registry.authorstrings[sortedItems[i][0].id];
                this.tmp.authorstring_request = false;
                sortedItems[i][1].sortkeys = [ authorstring ].concat(sortkeys);
            }
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
            var lastauthor = false;
            var thiskey = false;
            var thisauthor = false;
            for (var i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
                if (sortedItems[i][1].sortkeys[0] !== lastauthor) {
                    thisauthor = sortedItems[i][1].sortkeys[0];
                    thiskey = sortedItems[i][1].sortkeys[1];
                }
                sortedItems[i][1].sortkeys[0] = "" + thiskey + i;
                lastauthor = thisauthor;
            }
        }
        if (!citation.properties.unsorted) {
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
        }
    }
    if (this.opt.parallel.enable) {
        this.parallel.StartCitation(citation.sortedItems);
    }
    var citations;
    if (this.opt.update_mode === CSL.POSITION) {
        for (var i = 0; i < 2; i += 1) {
            var first_ref = {};
            var last_ref = {};
            var first_container_ref = {};
            citations = [ textCitations, noteCitations ][i];
            for (j = 0, jlen = citations.length; j < jlen; j += 1) {
                var onecitation = citations[j];
                if (!citations[j].properties.noteIndex) {
                    citations[j].properties.noteIndex = 0;
                }
                citations[j].properties.noteIndex = parseInt(citations[j].properties.noteIndex, 10);
                if (j > 0 && onecitation.properties.noteIndex && citations[j - 1].properties.noteIndex > onecitation.properties.noteIndex) {
                    citationsInNote = {};
                    first_ref = {};
                    last_ref = {};
                    first_container_ref = {};
                }
                for (k = 0, klen = onecitation.sortedItems.length; k < klen; k += 1) {
                    if (onecitation.sortedItems[k][1].parallel && onecitation.sortedItems[k][1].parallel !== "first") {
                        continue;
                    }
                    if (!citationsInNote[onecitation.properties.noteIndex]) {
                        citationsInNote[onecitation.properties.noteIndex] = 1;
                    } else {
                        citationsInNote[onecitation.properties.noteIndex] += 1;
                    }
                }
                for (k = 0, klen = citations[j].sortedItems.length; k < klen; k += 1) {
                    item = citations[j].sortedItems[k];
                    var item_id = item[0].id;
                    var first_id = item[0].legislation_id ? item[0].legislation_id : item[0].id;
                    var last_id = item[0].legislation_id ? item[0].legislation_id : item[0].container_id ? item[0].container_id : item[0].id;
                    var myxloc = item[1]["locator-extra"];
                    var mylocator = item[1].locator;
                    var mylabel = item[1].label;
                    var incitationid;
                    var incitationxloc;
                    if (k > 0) {
                        if (onecitation.sortedItems[k - 1][0].legislation_id) {
                            incitationid = onecitation.sortedItems[k - 1][0].legislation_id;
                        } else {
                            incitationid = onecitation.sortedItems[k - 1][1].id;
                            incitationxloc = onecitation.sortedItems[k - 1][1]["locator-extra"];
                            for (var l = k - 2; l > -1; l--) {
                                if (onecitation.sortedItems[l][1].parallel === "first") {
                                    incitationid = onecitation.sortedItems[l][1].id;
                                    incitationxloc = onecitation.sortedItems[l][1]["locator-extra"];
                                }
                            }
                        }
                    }
                    if (flag === CSL.PREVIEW) {
                        if (onecitation.citationID != citation.citationID) {
                            if ("undefined" === typeof first_ref[item[1].id]) {
                                first_ref[first_id] = onecitation.properties.noteIndex;
                                last_ref[last_id] = onecitation.properties.noteIndex;
                            } else {
                                last_ref[last_id] = onecitation.properties.noteIndex;
                            }
                            continue;
                        }
                    }
                    var oldvalue = {};
                    oldvalue.position = item[1].position;
                    oldvalue["first-reference-note-number"] = item[1]["first-reference-note-number"];
                    oldvalue["first-container-reference-note-number"] = item[1]["first-container-reference-note-number"];
                    oldvalue["near-note"] = item[1]["near-note"];
                    item[1]["first-reference-note-number"] = 0;
                    item[1]["first-container-reference-note-number"] = 0;
                    item[1]["near-note"] = false;
                    if (this.registry.citationreg.citationsByItemId[item_id]) {
                        if (this.opt.xclass === "note" && this.opt.has_disambiguate) {
                            var oldCount = this.registry.registry[item[0].id]["citation-count"];
                            var newCount = this.registry.citationreg.citationsByItemId[item_id].length;
                            this.registry.registry[item[0].id]["citation-count"] = this.registry.citationreg.citationsByItemId[item_id].length;
                            if ("number" === typeof oldCount) {
                                var oldCountCheck = oldCount < 2;
                                var newCountCheck = newCount < 2;
                                if (oldCountCheck !== newCountCheck) {
                                    for (var l = 0, llen = this.registry.citationreg.citationsByItemId[item_id].length; l < llen; l++) {
                                        rerunAkeys[this.registry.registry[item[0].id].ambig] = true;
                                        this.tmp.taintedCitationIDs[this.registry.citationreg.citationsByItemId[item_id][l].citationID] = true;
                                    }
                                }
                            } else {
                                for (var l = 0, llen = this.registry.citationreg.citationsByItemId[item_id].length; l < llen; l++) {
                                    rerunAkeys[this.registry.registry[item[0].id].ambig] = true;
                                    this.tmp.taintedCitationIDs[this.registry.citationreg.citationsByItemId[item_id][l].citationID] = true;
                                }
                            }
                        }
                    }
                    var oldlastid;
                    var oldlastxloc;
                    if ("undefined" === typeof last_ref[last_id] && onecitation.properties.mode !== "author-only") {
                        first_ref[first_id] = onecitation.properties.noteIndex;
                        last_ref[last_id] = onecitation.properties.noteIndex;
                        first_container_ref[last_id] = onecitation.properties.noteIndex;
                        item[1].position = CSL.POSITION_FIRST;
                    } else {
                        var ibidme = false;
                        var suprame = false;
                        var prevCitation = null;
                        if (j > 0) {
                            var prevCitation = citations[j - 1];
                        }
                        var thisCitation = citations[j];
                        if (j > 0) {
                            var old_last_id_offset = 1;
                            if (prevCitation.properties.mode === "author-only" && j > 1) {
                                old_last_id_offset = 2;
                            }
                            var adjusted_offset = j - old_last_id_offset;
                            if (citations[adjusted_offset].sortedItems.length) {
                                oldlastid = citations[adjusted_offset].sortedItems.slice(-1)[0][1].id;
                                oldlastxloc = citations[j - old_last_id_offset].sortedItems.slice(-1)[0][1]["locator-extra"];
                            }
                            if (prevCitation.sortedItems.length) {
                                if (prevCitation.sortedItems[0].slice(-1)[0].legislation_id) {
                                    oldlastid = prevCitation.sortedItems[0].slice(-1)[0].legislation_id;
                                }
                            }
                        }
                        if (j > 0 && k === 0 && prevCitation.properties.noteIndex !== thisCitation.properties.noteIndex) {
                            var useme = false;
                            var oldid = prevCitation.sortedItems[0][0].id;
                            if (prevCitation.sortedItems[0][0].legislation_id) {
                                oldid = prevCitation.sortedItems[0][0].legislation_id;
                            }
                            if (oldid == first_id && prevCitation.properties.noteIndex >= thisCitation.properties.noteIndex - 1) {
                                var prevxloc = prevCitation.sortedItems[0][1]["locator-extra"];
                                var thisxloc = thisCitation.sortedItems[0][1]["locator-extra"];
                                if ((citationsInNote[prevCitation.properties.noteIndex] === 1 || prevCitation.properties.noteIndex === 0) && prevxloc === thisxloc) {
                                    useme = true;
                                }
                            }
                            if (useme) {
                                ibidme = true;
                            } else {
                                suprame = true;
                            }
                        } else if (k > 0 && incitationid == first_id && incitationxloc == myxloc) {
                            ibidme = true;
                        } else if (k === 0 && j > 0 && prevCitation.properties.noteIndex == thisCitation.properties.noteIndex && prevCitation.sortedItems.length && oldlastid == first_id && oldlastxloc == myxloc) {
                            ibidme = true;
                        } else {
                            suprame = true;
                        }
                        var prev, prev_locator, prev_label, curr_locator, curr_label;
                        if (ibidme) {
                            if (k > 0) {
                                prev = onecitation.sortedItems[k - 1][1];
                            } else {
                                prev = citations[j - 1].sortedItems[0][1];
                            }
                            if (prev.locator) {
                                if (prev.label) {
                                    prev_label = prev.label;
                                } else {
                                    prev_label = "";
                                }
                                prev_locator = "" + prev.locator + prev_label;
                            } else {
                                prev_locator = prev.locator;
                            }
                            if (mylocator) {
                                if (mylabel) {
                                    curr_label = mylabel;
                                } else {
                                    curr_label = "";
                                }
                                curr_locator = "" + mylocator + curr_label;
                            } else {
                                curr_locator = mylocator;
                            }
                        }
                        if (ibidme && prev_locator && !curr_locator) {
                            ibidme = false;
                            suprame = true;
                        }
                        if (ibidme) {
                            if (!prev_locator && curr_locator) {
                                item[1].position = CSL.POSITION_IBID_WITH_LOCATOR;
                            } else if (!prev_locator && !curr_locator) {
                                item[1].position = CSL.POSITION_IBID;
                            } else if (prev_locator && curr_locator === prev_locator) {
                                item[1].position = CSL.POSITION_IBID;
                            } else if (prev_locator && curr_locator && curr_locator !== prev_locator) {
                                item[1].position = CSL.POSITION_IBID_WITH_LOCATOR;
                            } else {
                                ibidme = false;
                                suprame = true;
                            }
                        }
                        if (suprame) {
                            item[1].position = CSL.POSITION_CONTAINER_SUBSEQUENT;
                            if ("undefined" === typeof first_ref[first_id]) {
                                first_ref[first_id] = onecitation.properties.noteIndex;
                            } else {
                                item[1].position = CSL.POSITION_SUBSEQUENT;
                            }
                        }
                        if (suprame || ibidme) {
                            if (onecitation.properties.mode === "author-only") {
                                item[1].position = CSL.POSITION_FIRST;
                            }
                            if (first_container_ref[last_id] != onecitation.properties.noteIndex) {
                                item[1]["first-container-reference-note-number"] = first_container_ref[last_id];
                                if (this.registry.registry[item[0].id]) {
                                    this.registry.registry[item[0].id]["first-container-reference-note-number"] = first_container_ref[last_id];
                                }
                            }
                            if (first_ref[first_id] != onecitation.properties.noteIndex) {
                                item[1]["first-reference-note-number"] = first_ref[first_id];
                                if (this.registry.registry[item[0].id]) {
                                    this.registry.registry[item[0].id]["first-reference-note-number"] = first_ref[first_id];
                                }
                            }
                        }
                    }
                    if (onecitation.properties.noteIndex) {
                        var note_distance = parseInt(onecitation.properties.noteIndex, 10) - parseInt(last_ref[last_id], 10);
                        if (item[1].position !== CSL.POSITION_FIRST && note_distance <= this.citation.opt["near-note-distance"]) {
                            item[1]["near-note"] = true;
                        }
                        last_ref[last_id] = onecitation.properties.noteIndex;
                    } else if (item[1].position !== CSL.POSITION_FIRST) {
                        item[1]["near-note"] = true;
                    }
                    if (onecitation.citationID != citation.citationID) {
                        for (n = 0, nlen = CSL.POSITION_TEST_VARS.length; n < nlen; n += 1) {
                            var param = CSL.POSITION_TEST_VARS[n];
                            if (item[1][param] !== oldvalue[param]) {
                                if (this.registry.registry[item[0].id]) {
                                    if (param === "first-reference-note-number") {
                                        rerunAkeys[this.registry.registry[item[0].id].ambig] = true;
                                        this.tmp.taintedItemIDs[item[0].id] = true;
                                    }
                                }
                                this.tmp.taintedCitationIDs[onecitation.citationID] = true;
                            }
                        }
                    }
                    if (this.sys.variableWrapper) {
                        item[1].index = onecitation.properties.index;
                        item[1].noteIndex = onecitation.properties.noteIndex;
                    }
                }
            }
        }
    }
    if (this.opt.citation_number_sort && sortedItems && sortedItems.length > 1 && this.citation_sort.tokens.length > 0) {
        if (!citation.properties.unsorted) {
            for (var i = 0, ilen = sortedItems.length; i < ilen; i += 1) {
                sortedItems[i][1].sortkeys = CSL.getSortKeys.call(this, sortedItems[i][0], "citation_sort");
            }
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
        }
    }
    for (var key in this.tmp.taintedItemIDs) {
        if (this.tmp.taintedItemIDs.hasOwnProperty(key)) {
            citations = this.registry.citationreg.citationsByItemId[key];
            if (citations) {
                for (var i = 0, ilen = citations.length; i < ilen; i += 1) {
                    this.tmp.taintedCitationIDs[citations[i].citationID] = true;
                }
            }
        }
    }
    var ret = [];
    if (flag === CSL.PREVIEW) {
        if (this.debug) {
            CSL.debug("****** start run processor *********");
        }
        try {
            ret = this.process_CitationCluster.call(this, citation.sortedItems, citation);
        } catch (e) {
            CSL.error("Error running CSL processor for preview: " + e);
        }
        if (this.debug) {
            CSL.debug("****** end run processor *********");
            CSL.debug("****** start state restore *********");
        }
        this.registry.citationreg.citationByIndex = oldCitationList;
        this.registry.citationreg.citationById = {};
        for (var i = 0, ilen = oldCitationList.length; i < ilen; i += 1) {
            this.registry.citationreg.citationById[oldCitationList[i].citationID] = oldCitationList[i];
        }
        if (this.debug) {
            CSL.debug("****** start final update *********");
        }
        var oldItemIds = [];
        for (var i = 0, ilen = oldItemList.length; i < ilen; i += 1) {
            oldItemIds.push("" + oldItemList[i].id);
        }
        this.updateItems(oldItemIds, null, null, true);
        if (this.debug) {
            CSL.debug("****** end final update *********");
        }
        for (var key in oldAmbigs) {
            if (oldAmbigs.hasOwnProperty(key)) {
                this.registry.registry[key].disambig = oldAmbigs[key];
            }
        }
        if (this.debug) {
            CSL.debug("****** end state restore *********");
        }
    } else {
        for (var rerunAkey in rerunAkeys) {
            this.disambiguate.run(rerunAkey, citation);
        }
        var obj;
        for (var key in this.tmp.taintedCitationIDs) {
            if (key == citation.citationID) {
                continue;
            }
            var mycitation = this.registry.citationreg.citationById[key];
            if (!mycitation.properties.unsorted) {
                for (var i = 0, ilen = mycitation.sortedItems.length; i < ilen; i += 1) {
                    mycitation.sortedItems[i][1].sortkeys = CSL.getSortKeys.call(this, mycitation.sortedItems[i][0], "citation_sort");
                }
                mycitation.sortedItems.sort(this.citation.srt.compareCompositeKeys);
            }
            this.tmp.citation_pos = mycitation.properties.index;
            this.tmp.citation_note_index = mycitation.properties.noteIndex;
            this.tmp.citation_id = "" + mycitation.citationID;
            obj = [];
            obj.push(mycitation.properties.index);
            obj.push(this.process_CitationCluster.call(this, mycitation.sortedItems, mycitation));
            obj.push(mycitation.citationID);
            ret.push(obj);
        }
        this.tmp.taintedItemIDs = {};
        this.tmp.taintedCitationIDs = {};
        this.tmp.citation_pos = citation.properties.index;
        this.tmp.citation_note_index = citation.properties.noteIndex;
        this.tmp.citation_id = "" + citation.citationID;
        obj = [];
        obj.push(citationsPre.length);
        obj.push(this.process_CitationCluster.call(this, sortedItems, citation));
        obj.push(citation.citationID);
        ret.push(obj);
        ret.sort(function(a, b) {
            if (a[0] > b[0]) {
                return 1;
            } else if (a[0] < b[0]) {
                return -1;
            } else {
                return 0;
            }
        });
    }
    this.registry.return_data.citation_errors = this.tmp.citation_errors.slice();
    return [ this.registry.return_data, ret ];
};

CSL.Engine.prototype.process_CitationCluster = function(sortedItems, citation) {
    var str = "";
    if (citation && citation.properties && citation.properties.mode === "composite") {
        citation.properties.mode = "author-only";
        var firstChunk = CSL.getCitationCluster.call(this, sortedItems, citation);
        citation.properties.mode = "suppress-author";
        var secondChunk = "";
        if (citation.properties.infix) {
            this.output.append(citation.properties.infix);
            secondChunk = this.output.string(this, this.output.queue);
            if ("object" === typeof secondChunk) {
                secondChunk = secondChunk.join("");
            }
        }
        var thirdChunk = CSL.getCitationCluster.call(this, sortedItems, citation);
        citation.properties.mode = "composite";
        if (firstChunk && secondChunk && CSL.SWAPPING_PUNCTUATION.concat([ "’", "'" ]).indexOf(secondChunk[0]) > -1) {
            firstChunk += secondChunk;
            secondChunk = false;
        }
        str = [ firstChunk, secondChunk, thirdChunk ].filter(function(obj) {
            return obj;
        }).join(" ");
    } else {
        str = CSL.getCitationCluster.call(this, sortedItems, citation);
    }
    return str;
};

CSL.Engine.prototype.makeCitationCluster = function(rawList) {
    var inputList, newitem, str, pos, len, item, Item;
    inputList = [];
    len = rawList.length;
    for (pos = 0; pos < len; pos += 1) {
        item = {};
        for (var key in rawList[pos]) {
            item[key] = rawList[pos][key];
        }
        Item = this.retrieveItem("" + item.id);
        if (this.opt.development_extensions.locator_label_parse) {
            if (item.locator && [ "bill", "gazette", "legislation", "regulation", "treaty" ].indexOf(Item.type) === -1 && (!item.label || item.label === "page")) {
                var m = CSL.LOCATOR_LABELS_REGEXP.exec(item.locator);
                if (m) {
                    var tryLabel = CSL.LOCATOR_LABELS_MAP[m[2]];
                    if (this.getTerm(tryLabel)) {
                        item.label = tryLabel;
                        item.locator = m[3];
                    }
                }
            }
        }
        if (item.locator) {
            item.locator = ("" + item.locator).replace(/\s+$/, "");
        }
        newitem = [ Item, item ];
        inputList.push(newitem);
    }
    if (this.opt.development_extensions.consolidate_legal_items) {
        this.remapSectionVariable(inputList);
    }
    if (inputList && inputList.length > 1 && this.citation_sort.tokens.length > 0) {
        len = inputList.length;
        for (pos = 0; pos < len; pos += 1) {
            inputList[pos][1].sortkeys = CSL.getSortKeys.call(this, inputList[pos][0], "citation_sort");
        }
        inputList.sort(this.citation.srt.compareCompositeKeys);
    }
    this.tmp.citation_errors = [];
    var str = CSL.getCitationCluster.call(this, inputList);
    return str;
};

CSL.getAmbiguousCite = function(Item, disambig, visualForm, item) {
    var ret;
    var flags = this.tmp.group_context.tip;
    var oldTermSiblingLayer = {
        term_intended: flags.term_intended,
        variable_attempt: flags.variable_attempt,
        variable_success: flags.variable_success,
        output_tip: flags.output_tip,
        label_form: flags.label_form,
        non_parallel: flags.non_parallel,
        parallel_last: flags.parallel_last,
        parallel_first: flags.parallel_first,
        parallel_last_override: flags.parallel_last_override,
        parallel_delimiter_override: flags.parallel_delimiter_override,
        parallel_delimiter_override_on_suppress: flags.parallel_delimiter_override_on_suppress,
        condition: flags.condition,
        force_suppress: flags.force_suppress,
        done_vars: flags.done_vars.slice()
    };
    if (disambig) {
        this.tmp.disambig_request = disambig;
    } else {
        this.tmp.disambig_request = false;
    }
    var itemSupp = {
        position: CSL.POSITION_SUBSEQUENT,
        "near-note": true
    };
    if (item) {
        itemSupp.locator = item.locator;
        itemSupp.label = item.label;
    }
    if (this.registry.registry[Item.id] && this.registry.citationreg.citationsByItemId && this.registry.citationreg.citationsByItemId[Item.id] && this.registry.citationreg.citationsByItemId[Item.id].length && visualForm) {
        if (this.citation.opt["givenname-disambiguation-rule"] === "by-cite") {
            itemSupp["first-reference-note-number"] = this.registry.registry[Item.id]["first-reference-note-number"];
        }
    }
    this.tmp.area = "citation";
    this.tmp.root = "citation";
    var origSuppressDecorations = this.tmp.suppress_decorations;
    this.tmp.suppress_decorations = true;
    this.tmp.just_looking = true;
    CSL.getCite.call(this, Item, itemSupp, null, false);
    for (var i = 0, ilen = this.output.queue.length; i < ilen; i += 1) {
        CSL.Output.Queue.purgeEmptyBlobs(this.output.queue[i]);
    }
    if (this.opt.development_extensions.clean_up_csl_flaws) {
        for (var j = 0, jlen = this.output.queue.length; j < jlen; j += 1) {
            this.output.adjust.upward(this.output.queue[j]);
            this.output.adjust.leftward(this.output.queue[j]);
            this.output.adjust.downward(this.output.queue[j]);
            this.output.adjust.fix(this.output.queue[j]);
        }
    }
    var ret = this.output.string(this, this.output.queue);
    this.tmp.just_looking = false;
    this.tmp.suppress_decorations = origSuppressDecorations;
    this.tmp.group_context.replace(oldTermSiblingLayer);
    return ret;
};

CSL.getSpliceDelimiter = function(last_locator, last_collapsed, pos) {
    if (undefined !== this.citation.opt["after-collapse-delimiter"]) {
        if (last_locator) {
            this.tmp.splice_delimiter = this.citation.opt["after-collapse-delimiter"];
        } else if (last_collapsed && !this.tmp.have_collapsed) {
            this.tmp.splice_delimiter = this.citation.opt["after-collapse-delimiter"];
        } else if (!last_collapsed && !this.tmp.have_collapsed && this.citation.opt.collapse !== "year-suffix") {
            this.tmp.splice_delimiter = this.citation.opt["after-collapse-delimiter"];
        } else {
            this.tmp.splice_delimiter = this.citation.opt.layout_delimiter;
        }
    } else if (this.tmp.use_cite_group_delimiter) {
        this.tmp.splice_delimiter = this.citation.opt.cite_group_delimiter;
    } else {
        if (this.tmp.have_collapsed && this.opt.xclass === "in-text" && this.opt.update_mode !== CSL.NUMERIC) {
            this.tmp.splice_delimiter = ", ";
        } else if (this.tmp.cite_locales[pos - 1]) {
            var alt_affixes = this.tmp.cite_affixes[this.tmp.area][this.tmp.cite_locales[pos - 1]];
            if (alt_affixes && alt_affixes.delimiter) {
                this.tmp.splice_delimiter = alt_affixes.delimiter;
            }
        } else if (!this.tmp.splice_delimiter) {
            this.tmp.splice_delimiter = "";
        }
    }
    return this.tmp.splice_delimiter;
};

CSL.getCitationCluster = function(inputList, citation) {
    var result, objects, myparams, len, pos, item, last_collapsed, params, composite, compie, myblobs, Item, llen, ppos, obj, preceding_item, txt_esc, error_object, citationID, authorOnly, suppressAuthor;
    var citation_prefix = "";
    this.output.checkNestedBrace = new CSL.checkNestedBrace(this);
    if (citation) {
        citationID = citation.citationID;
        authorOnly = citation.properties.mode === "author-only" ? !!citation.properties.mode : false;
        if (this.opt.xclass !== "note") {
            suppressAuthor = citation.properties.mode === "suppress-author" ? !!citation.properties.mode : false;
        }
        if (citation.properties.prefix) {
            citation_prefix = CSL.checkPrefixSpaceAppend(this, citation.properties.prefix);
        }
    }
    inputList = inputList ? inputList : [];
    this.tmp.last_primary_names_string = false;
    txt_esc = CSL.getSafeEscape(this);
    this.tmp.area = "citation";
    this.tmp.root = "citation";
    result = "";
    objects = [];
    this.tmp.last_suffix_used = "";
    this.tmp.last_names_used = [];
    this.tmp.last_years_used = [];
    this.tmp.backref_index = [];
    this.tmp.cite_locales = [];
    if (!this.tmp.just_looking) {
        this.tmp.abbrev_trimmer = {
            QUASHES: {}
        };
    }
    var use_layout_prefix = this.output.checkNestedBrace.update(this.citation.opt.layout_prefix + citation_prefix);
    var suppressTrailingPunctuation = false;
    if (this.citation.opt.suppressTrailingPunctuation) {
        suppressTrailingPunctuation = true;
    }
    if (citationID) {
        if (this.registry.citationreg.citationById[citationID].properties["suppress-trailing-punctuation"]) {
            suppressTrailingPunctuation = true;
        }
    }
    if (this.opt.xclass === "note") {
        var parasets = [];
        var lastTitle = false;
        var lastID = false;
        var lst = [];
        for (var i = 0, ilen = inputList.length; i < ilen; i += 1) {
            var type = inputList[i][0].type;
            var title = inputList[i][0].title;
            var position = inputList[i][1].position;
            var id = inputList[i][0].id;
            if (title && type === "legal_case" && id !== lastID && position) {
                if (title !== lastTitle || parasets.length === 0) {
                    lst = [];
                    parasets.push(lst);
                }
                lst.push(inputList[i][1]);
            }
            lastTitle = title;
            lastID = id;
        }
        for (i = 0, ilen = parasets.length; i < ilen; i += 1) {
            lst = parasets[i];
            if (lst.length < 2) {
                continue;
            }
            var locatorInLastPosition = lst.slice(-1)[0].locator;
            if (locatorInLastPosition) {
                for (var j = 0, jlen = lst.length - 1; j < jlen; j += 1) {
                    if (lst[j].locator) {
                        locatorInLastPosition = false;
                    }
                }
            }
            if (locatorInLastPosition) {
                lst[0].locator = locatorInLastPosition;
                delete lst.slice(-1)[0].locator;
                lst[0].label = lst.slice(-1)[0].label;
                if (lst.slice(-1)[0].label) {
                    delete lst.slice(-1)[0].label;
                }
            }
        }
    }
    myparams = [];
    len = inputList.length;
    if (inputList[0] && inputList[0][1]) {
        if (authorOnly) {
            delete inputList[0][1]["suppress-author"];
            inputList[0][1]["author-only"] = true;
        } else if (suppressAuthor) {
            delete inputList[0][1]["author-only"];
            inputList[0][1]["suppress-author"] = true;
        }
    }
    if (this.opt.parallel.enable) {
        this.parallel.StartCitation(inputList);
    }
    for (pos = 0; pos < len; pos += 1) {
        this.tmp.cite_index = pos;
        Item = inputList[pos][0];
        item = inputList[pos][1];
        item = CSL.parseLocator.call(this, item);
        last_collapsed = this.tmp.have_collapsed;
        var last_locator = false;
        if (pos > 0 && inputList[pos - 1][1]) {
            last_locator = !!inputList[pos - 1][1].locator;
        }
        params = {};
        this.tmp.shadow_numbers = {};
        if (!this.tmp.just_looking && this.opt.hasPlaceholderTerm) {
            var output = this.output;
            this.output = new CSL.Output.Queue(this);
            this.output.adjust = new CSL.Output.Queue.adjust;
            CSL.getAmbiguousCite.call(this, Item, null, false, item);
            this.output = output;
        }
        this.tmp.in_cite_predecessor = false;
        if (pos > 0) {
            CSL.getCite.call(this, Item, item, "" + inputList[pos - 1][0].id, true);
        } else {
            this.tmp.term_predecessor = false;
            CSL.getCite.call(this, Item, item, null, true);
        }
        if (!this.tmp.cite_renders_content) {
            error_object = {
                citationID: "" + this.tmp.citation_id,
                index: this.tmp.citation_pos,
                noteIndex: this.tmp.citation_note_index,
                itemID: "" + Item.id,
                citationItems_pos: pos,
                error_code: CSL.ERROR_NO_RENDERED_FORM
            };
            this.tmp.citation_errors.push(error_object);
        }
        params.splice_delimiter = CSL.getSpliceDelimiter.call(this, last_locator, last_collapsed, pos);
        if (item && item["author-only"]) {
            this.tmp.suppress_decorations = true;
        }
        if (pos > 0) {
            preceding_item = inputList[pos - 1][1];
            var precedingEndsInPeriodOrComma = preceding_item.suffix && [ ";", ".", "," ].indexOf(preceding_item.suffix.slice(-1)) > -1;
            var currentStartsWithPeriodOrComma = !preceding_item.suffix && item.prefix && [ ";", ".", "," ].indexOf(item.prefix.slice(0, 1)) > -1;
            if (precedingEndsInPeriodOrComma || currentStartsWithPeriodOrComma) {
                var spaceidx = params.splice_delimiter.indexOf(" ");
                if (spaceidx > -1 && !currentStartsWithPeriodOrComma) {
                    params.splice_delimiter = params.splice_delimiter.slice(spaceidx);
                } else {
                    params.splice_delimiter = "";
                }
            }
        }
        params.suppress_decorations = this.tmp.suppress_decorations;
        params.have_collapsed = this.tmp.have_collapsed;
        myparams.push(params);
        if (item["author-only"]) {
            break;
        }
    }
    myblobs = this.output.queue.slice();
    var citation_suffix = "";
    if (citation) {
        citation_suffix = CSL.checkSuffixSpacePrepend(this, citation.properties.suffix);
    }
    var suffix = this.citation.opt.layout_suffix;
    var last_locale = this.tmp.cite_locales[this.tmp.cite_locales.length - 1];
    if (last_locale && this.tmp.cite_affixes[this.tmp.area][last_locale] && this.tmp.cite_affixes[this.tmp.area][last_locale].suffix) {
        suffix = this.tmp.cite_affixes[this.tmp.area][last_locale].suffix;
    }
    if (CSL.TERMINAL_PUNCTUATION.slice(0, -1).indexOf(suffix.slice(0, 1)) > -1) {
        suffix = suffix.slice(0, 1);
    }
    suffix = this.output.checkNestedBrace.update(citation_suffix + suffix);
    for (var i = 0, ilen = this.output.queue.length; i < ilen; i += 1) {
        CSL.Output.Queue.purgeEmptyBlobs(this.output.queue[i]);
    }
    if (!this.tmp.suppress_decorations && this.output.queue.length) {
        if (!(this.opt.development_extensions.apply_citation_wrapper && this.sys.wrapCitationEntry && !this.tmp.just_looking && this.tmp.area === "citation")) {
            if (!suppressTrailingPunctuation) {
                this.output.queue[this.output.queue.length - 1].strings.suffix = suffix;
            }
            this.output.queue[0].strings.prefix = use_layout_prefix;
        }
    }
    if (this.opt.development_extensions.clean_up_csl_flaws) {
        for (var j = 0, jlen = this.output.queue.length; j < jlen; j += 1) {
            this.output.adjust.upward(this.output.queue[j]);
            this.output.adjust.leftward(this.output.queue[j]);
            this.output.adjust.downward(this.output.queue[j]);
            this.tmp.last_chr = this.output.adjust.fix(this.output.queue[j]);
        }
    }
    for (pos = 0, len = myblobs.length; pos < len; pos += 1) {
        var buffer = [];
        this.output.queue = [ myblobs[pos] ];
        this.tmp.suppress_decorations = myparams[pos].suppress_decorations;
        this.tmp.splice_delimiter = myparams[pos].splice_delimiter;
        if (myblobs[pos].parallel_delimiter) {
            this.tmp.splice_delimiter = myblobs[pos].parallel_delimiter;
        }
        this.tmp.have_collapsed = myparams[pos].have_collapsed;
        composite = this.output.string(this, this.output.queue);
        this.tmp.suppress_decorations = false;
        if ("string" === typeof composite) {
            this.tmp.suppress_decorations = false;
            if (!composite) {
                if (this.opt.development_extensions.throw_on_empty) {
                    CSL.error("Citation would render no content");
                } else {
                    composite = "[NO_PRINTED_FORM]";
                }
            }
            return composite;
        }
        if ("object" === typeof composite && composite.length === 0 && !item["suppress-author"]) {
            if (pos === 0) {
                var errStr = "[CSL STYLE ERROR: reference with no printed form.]";
                var preStr = pos === 0 ? txt_esc(this.citation.opt.layout_prefix) : "";
                var sufStr = pos === myblobs.length - 1 ? txt_esc(this.citation.opt.layout_suffix) : "";
                composite.push(preStr + errStr + sufStr);
            } else if (pos === myblobs.length - 1) {
                var tmpobj = objects[objects.length - 1];
                if (typeof tmpobj === "string") {
                    objects[objects.length - 1] += txt_esc(this.citation.opt.layout_suffix);
                } else if (typeof tmpobj === "object") {
                    tmpobj.strings.suffix += txt_esc(this.citation.opt.layout_suffix);
                }
            }
        }
        if (buffer.length && "string" === typeof composite[0]) {
            composite.reverse();
            var tmpstr = composite.pop();
            if (tmpstr && tmpstr.slice(0, 1) === ",") {
                buffer.push(tmpstr);
            } else if ("string" == typeof buffer.slice(-1)[0] && buffer.slice(-1)[0].slice(-1) === ",") {
                buffer.push(" " + tmpstr);
            } else if (tmpstr) {
                buffer.push(txt_esc(this.tmp.splice_delimiter) + tmpstr);
            }
        } else {
            composite.reverse();
            compie = composite.pop();
            if ("undefined" !== typeof compie) {
                if (buffer.length && "string" === typeof buffer[buffer.length - 1]) {
                    buffer[buffer.length - 1] += compie.successor_prefix;
                }
                buffer.push(compie);
            }
        }
        llen = composite.length;
        for (ppos = 0; ppos < llen; ppos += 1) {
            obj = composite[ppos];
            if ("string" === typeof obj) {
                buffer.push(txt_esc(this.tmp.splice_delimiter) + obj);
                continue;
            }
            compie = composite.pop();
            if ("undefined" !== typeof compie) {
                buffer.push(compie);
            }
        }
        if (buffer.length === 0 && !inputList[pos][1]["suppress-author"]) ;
        if (buffer.length > 1 && typeof buffer[0] !== "string") {
            buffer = [ this.output.renderBlobs(buffer) ];
        }
        if (buffer.length) {
            if ("string" === typeof buffer[0]) {
                if (pos > 0) {
                    buffer[0] = txt_esc(this.tmp.splice_delimiter) + buffer[0];
                }
            } else {
                if (pos > 0) {
                    buffer[0].splice_prefix = this.tmp.splice_delimiter;
                } else {
                    buffer[0].splice_prefix = "";
                }
            }
        }
        objects = objects.concat(buffer);
    }
    result += this.output.renderBlobs(objects);
    if (result) {
        if (!this.tmp.suppress_decorations) {
            len = this.citation.opt.layout_decorations.length;
            for (pos = 0; pos < len; pos += 1) {
                params = this.citation.opt.layout_decorations[pos];
                if (params[1] === "normal") {
                    continue;
                }
                if (!item || !item["author-only"]) {
                    result = this.fun.decorate[params[0]][params[1]](this, result);
                }
            }
        }
    }
    this.tmp.suppress_decorations = false;
    if (!result) {
        if (this.opt.development_extensions.throw_on_empty) {
            CSL.error("Citation would render no content");
        } else {
            result = "[NO_PRINTED_FORM]";
        }
    }
    return result;
};

CSL.getCite = function(Item, item, prevItemID, blockShadowNumberReset) {
    var next, error_object;
    var areaOrig = this.tmp.area;
    if (item && item["author-only"] && this.intext && this.intext.tokens.length > 0) {
        this.tmp.area = "intext";
    }
    this.tmp.cite_renders_content = false;
    this.tmp.probably_rendered_something = false;
    this.tmp.prevItemID = prevItemID;
    CSL.citeStart.call(this, Item, item, blockShadowNumberReset);
    next = 0;
    this.tmp.name_node = {};
    this.nameOutput = new CSL.NameOutput(this, Item, item);
    while (next < this[this.tmp.area].tokens.length) {
        next = CSL.tokenExec.call(this, this[this.tmp.area].tokens[next], Item, item);
    }
    CSL.citeEnd.call(this, Item, item);
    if (!this.tmp.cite_renders_content && !this.tmp.just_looking) {
        if (this.tmp.area === "bibliography") {
            error_object = {
                index: this.tmp.bibliography_pos,
                itemID: "" + Item.id,
                error_code: CSL.ERROR_NO_RENDERED_FORM
            };
            this.tmp.bibliography_errors.push(error_object);
        }
    }
    this.tmp.area = areaOrig;
    return "" + Item.id;
};

CSL.citeStart = function(Item, item, blockShadowNumberReset) {
    this.tmp.lang_array = [];
    if (Item.language) {
        var m = Item.language.match(/^([a-zA-Z]+).*/);
        if (m) {
            this.tmp.lang_array.push(m[1].toLowerCase());
        }
    }
    this.tmp.lang_array.push(this.opt.lang);
    if (!blockShadowNumberReset) {
        this.tmp.shadow_numbers = {};
    }
    this.tmp.disambiguate_count = 0;
    this.tmp.disambiguate_maxMax = 0;
    this.tmp.same_author_as_previous_cite = false;
    if (!this.tmp.suppress_decorations) {
        this.tmp.subsequent_author_substitute_ok = true;
    } else {
        this.tmp.subsequent_author_substitute_ok = false;
    }
    this.tmp.lastchr = "";
    if (this.tmp.area === "citation" && this.citation.opt.collapse && this.citation.opt.collapse.length) {
        this.tmp.have_collapsed = true;
    } else {
        this.tmp.have_collapsed = false;
    }
    this.tmp.render_seen = false;
    if (this.tmp.disambig_request && !this.tmp.disambig_override) {
        this.tmp.disambig_settings = this.tmp.disambig_request;
    } else if (this.registry.registry[Item.id] && !this.tmp.disambig_override) {
        this.tmp.disambig_request = this.registry.registry[Item.id].disambig;
        this.tmp.disambig_settings = this.registry.registry[Item.id].disambig;
    } else {
        this.tmp.disambig_settings = new CSL.AmbigConfig;
    }
    if (this.tmp.area !== "citation") {
        if (!this.registry.registry[Item.id]) {
            this.tmp.disambig_restore = new CSL.AmbigConfig;
        } else {
            this.tmp.disambig_restore = CSL.cloneAmbigConfig(this.registry.registry[Item.id].disambig);
            if (this.tmp.area === "bibliography" && this.tmp.disambig_settings && this.tmp.disambig_override) {
                if (this.opt["disambiguate-add-names"]) {
                    this.tmp.disambig_settings.names = this.registry.registry[Item.id].disambig.names.slice();
                    if (this.tmp.disambig_request) {
                        this.tmp.disambig_request.names = this.registry.registry[Item.id].disambig.names.slice();
                    }
                }
                if (this.opt["disambiguate-add-givenname"]) {
                    this.tmp.disambig_request = this.tmp.disambig_settings;
                    this.tmp.disambig_settings.givens = this.registry.registry[Item.id].disambig.givens.slice();
                    this.tmp.disambig_request.givens = this.registry.registry[Item.id].disambig.givens.slice();
                    for (var i = 0, ilen = this.tmp.disambig_settings.givens.length; i < ilen; i += 1) {
                        this.tmp.disambig_settings.givens[i] = this.registry.registry[Item.id].disambig.givens[i].slice();
                    }
                    for (var i = 0, ilen = this.tmp.disambig_request.givens.length; i < ilen; i += 1) {
                        this.tmp.disambig_request.givens[i] = this.registry.registry[Item.id].disambig.givens[i].slice();
                    }
                }
            }
        }
    }
    this.tmp.names_used = [];
    this.tmp.nameset_counter = 0;
    this.tmp.years_used = [];
    this.tmp.names_max.clear();
    if (!this.tmp.just_looking) {
        if (!item || item.parallel === "first" || !item.parallel) {
            this.tmp.abbrev_trimmer = {
                QUASHES: {}
            };
        }
    }
    this.tmp.splice_delimiter = this[this.tmp.area].opt.layout_delimiter;
    this.bibliography_sort.keys = [];
    this.citation_sort.keys = [];
    this.tmp.has_done_year_suffix = false;
    this.tmp.last_cite_locale = false;
    if (!this.tmp.just_looking && item && !item.position && this.registry.registry[Item.id]) {
        this.tmp.disambig_restore = CSL.cloneAmbigConfig(this.registry.registry[Item.id].disambig);
    }
    this.tmp.first_name_string = false;
    this.tmp.authority_stop_last = 0;
};

CSL.citeEnd = function(Item, item) {
    if (this.tmp.disambig_restore && this.registry.registry[Item.id]) {
        this.registry.registry[Item.id].disambig.names = this.tmp.disambig_restore.names.slice();
        this.registry.registry[Item.id].disambig.givens = this.tmp.disambig_restore.givens.slice();
        for (var i = 0, ilen = this.registry.registry[Item.id].disambig.givens.length; i < ilen; i += 1) {
            this.registry.registry[Item.id].disambig.givens[i] = this.tmp.disambig_restore.givens[i].slice();
        }
    }
    this.tmp.disambig_restore = false;
    if (item && item.suffix) {
        this.tmp.last_suffix_used = item.suffix;
    } else {
        this.tmp.last_suffix_used = "";
    }
    this.tmp.last_years_used = this.tmp.years_used.slice();
    this.tmp.last_names_used = this.tmp.names_used.slice();
    this.tmp.cut_var = false;
    this.tmp.disambig_request = false;
    this.tmp.cite_locales.push(this.tmp.last_cite_locale);
    if (this.tmp.issued_date && this.tmp.renders_collection_number) {
        var buf = [];
        for (var i = this.tmp.issued_date.list.length - 1; i > this.tmp.issued_date.pos; i += -1) {
            buf.push(this.tmp.issued_date.list.pop());
        }
        this.tmp.issued_date.list.pop();
        for (i = buf.length - 1; i > -1; i += -1) {
            this.tmp.issued_date.list.push(buf.pop());
        }
    }
    this.tmp.issued_date = false;
    this.tmp.renders_collection_number = false;
};

CSL.Engine.prototype.makeBibliography = function(bibsection) {
    var debug, ret, params, item, len, pos, tok, entry_ids, entry_strings;
    debug = false;
    if (!bibsection && (this.bibliography.opt.exclude_types || this.bibliography.opt.exclude_with_fields)) {
        bibsection = {
            exclude: []
        };
        if (this.bibliography.opt.exclude_types) {
            for (var i in this.bibliography.opt.exclude_types) {
                var val = this.bibliography.opt.exclude_types[i];
                bibsection.exclude.push({
                    field: "type",
                    value: val
                });
            }
        }
        if (this.bibliography.opt.exclude_with_fields) {
            for (var i in this.bibliography.opt.exclude_with_fields) {
                var field = this.bibliography.opt.exclude_with_fields[i];
                bibsection.exclude.push({
                    field: field,
                    value: true
                });
            }
        }
    }
    if (!this.bibliography.tokens.length) {
        return false;
    }
    if ("string" === typeof bibsection) {
        this.opt.citation_number_slug = bibsection;
        bibsection = false;
    }
    if (debug) {
        len = this.bibliography.tokens.length;
        for (pos = 0; pos < len; pos += 1) {
            tok = this.bibliography.tokens[pos];
            CSL.debug("bibtok: " + tok.name);
        }
        CSL.debug("---");
        len = this.citation.tokens.length;
        for (pos = 0; pos < len; pos += 1) {
            this.citation.tokens[pos];
            CSL.debug("cittok: " + tok.name);
        }
        CSL.debug("---");
        len = this.bibliography_sort.tokens.length;
        for (pos = 0; pos < len; pos += 1) {
            this.bibliography_sort.tokens[pos];
            CSL.debug("bibsorttok: " + tok.name);
        }
    }
    ret = CSL.getBibliographyEntries.call(this, bibsection);
    entry_ids = ret[0];
    entry_strings = ret[1];
    var done = ret[2];
    params = {
        maxoffset: 0,
        entryspacing: this.bibliography.opt["entry-spacing"],
        linespacing: this.bibliography.opt["line-spacing"],
        "second-field-align": false,
        entry_ids: entry_ids,
        bibliography_errors: this.tmp.bibliography_errors.slice(),
        done: done
    };
    if (this.bibliography.opt["second-field-align"]) {
        params["second-field-align"] = this.bibliography.opt["second-field-align"];
    }
    len = this.registry.reflist.length;
    for (pos = 0; pos < len; pos += 1) {
        item = this.registry.reflist[pos];
        if (item.offset > params.maxoffset) {
            params.maxoffset = item.offset;
        }
    }
    if (this.bibliography.opt.hangingindent) {
        params.hangingindent = this.bibliography.opt.hangingindent;
    }
    params.bibstart = this.fun.decorate.bibstart;
    params.bibend = this.fun.decorate.bibend;
    this.opt.citation_number_slug = false;
    return [ params, entry_strings ];
};

CSL.getBibliographyEntries = function(bibsection) {
    var ret, input, include, anymatch, allmatch, bib_entry, res, item, spec, lllen, pppos, topblobs, entry_item_ids, i, ilen, siblings, skips, sortedItems, entry_item_data, j, jlen;
    ret = [];
    entry_item_data = [];
    this.tmp.area = "bibliography";
    this.tmp.root = "bibliography";
    this.tmp.last_rendered_name = false;
    this.tmp.bibliography_errors = [];
    this.tmp.bibliography_pos = 0;
    if (bibsection && bibsection.page_start && bibsection.page_length) {
        input = this.registry.getSortedIds();
    } else {
        input = this.refetchItems(this.registry.getSortedIds());
    }
    this.tmp.disambig_override = true;
    function eval_string(a, b) {
        if (a === b) {
            return true;
        }
        return false;
    }
    function eval_list(a, lst) {
        lllen = lst.length;
        for (pppos = 0; pppos < lllen; pppos += 1) {
            if (eval_string(a, lst[pppos])) {
                return true;
            }
        }
        return false;
    }
    function eval_spec(a, b) {
        if ("boolean" === typeof a || !a) {
            if (a) {
                return !!b;
            } else {
                return !b;
            }
        } else {
            if ("string" === typeof b) {
                return eval_string(a, b);
            } else if (!b) {
                return false;
            } else {
                return eval_list(a, b);
            }
        }
    }
    skips = {};
    var page_item_count;
    if (bibsection && bibsection.page_start && bibsection.page_length) {
        page_item_count = 0;
        if (bibsection.page_start !== true) {
            for (i = 0, ilen = input.length; i < ilen; i += 1) {
                skips[input[i]] = true;
                if (bibsection.page_start == input[i]) {
                    break;
                }
            }
        }
    }
    var processed_item_ids = [];
    var consolidatedIDs = {};
    this.tmp.container_item_count = {};
    input = input.filter(o => {
        var ret = o;
        if (o.legislation_id) {
            if (consolidatedIDs[o.legislation_id]) {
                ret = false;
            } else {
                consolidatedIDs[o.legislation_id] = true;
            }
        } else if (o.container_id) {
            if (!this.tmp.container_item_count[o.container_id]) {
                this.tmp.container_item_count[o.container_id] = 0;
            }
            this.tmp.container_item_count[o.container_id]++;
            if (this.bibliography.opt.consolidate_containers.indexOf(o.type) > -1) {
                if (consolidatedIDs[o.container_id]) {
                    ret = false;
                } else {
                    consolidatedIDs[o.container_id] = true;
                }
            }
        }
        return ret;
    });
    this.tmp.container_item_pos = {};
    for (i = 0, ilen = input.length; i < ilen; i += 1) {
        if (bibsection && bibsection.page_start && bibsection.page_length) {
            if (skips[input[i]]) {
                continue;
            }
            item = this.refetchItem(input[i]);
            if (page_item_count === bibsection.page_length) {
                break;
            }
        } else {
            item = input[i];
            if (skips[item.id]) {
                continue;
            }
        }
        if (bibsection) {
            include = true;
            if (bibsection.include) {
                include = false;
                for (j = 0, jlen = bibsection.include.length; j < jlen; j += 1) {
                    spec = bibsection.include[j];
                    if (eval_spec(spec.value, item[spec.field])) {
                        include = true;
                        break;
                    }
                }
            } else if (bibsection.exclude) {
                anymatch = false;
                for (j = 0, jlen = bibsection.exclude.length; j < jlen; j += 1) {
                    spec = bibsection.exclude[j];
                    if (eval_spec(spec.value, item[spec.field])) {
                        anymatch = true;
                        break;
                    }
                }
                if (anymatch) {
                    include = false;
                }
            } else if (bibsection.select) {
                include = false;
                allmatch = true;
                for (j = 0, jlen = bibsection.select.length; j < jlen; j += 1) {
                    spec = bibsection.select[j];
                    if (!eval_spec(spec.value, item[spec.field])) {
                        allmatch = false;
                    }
                }
                if (allmatch) {
                    include = true;
                }
            }
            if (bibsection.quash) {
                allmatch = true;
                for (j = 0, jlen = bibsection.quash.length; j < jlen; j += 1) {
                    spec = bibsection.quash[j];
                    if (!eval_spec(spec.value, item[spec.field])) {
                        allmatch = false;
                    }
                }
                if (allmatch) {
                    include = false;
                }
            }
            if (!include) {
                continue;
            }
        }
        if (item.container_id) {
            if (!this.tmp.container_item_pos[item.container_id]) {
                this.tmp.container_item_pos[item.container_id] = 0;
            }
            this.tmp.container_item_pos[item.container_id]++;
        }
        bib_entry = new CSL.Token("group", CSL.START);
        bib_entry.decorations = [ [ "@bibliography", "entry" ] ].concat(this.bibliography.opt.layout_decorations);
        this.output.startTag("bib_entry", bib_entry);
        if (item.system_id && this.sys.embedBibliographyEntry) {
            this.output.current.value().item_id = item.system_id;
        } else {
            this.output.current.value().system_id = item.id;
        }
        entry_item_ids = [];
        if (this.registry.registry[item.id].master && !(bibsection && bibsection.page_start && bibsection.page_length)) {
            sortedItems = [ [ item, {
                id: item.id
            } ] ];
            siblings = this.registry.registry[item.id].siblings;
            for (var j = 0, jlen = siblings.length; j < jlen; j++) {
                sortedItems.push([ this.refetchItem(siblings[j]), {
                    id: siblings[j]
                } ]);
            }
            this.parallel.StartCitation(sortedItems);
            if (this.registry.registry[item.id].parallel_delimiter_override) {
                this.output.queue[0].strings.delimiter = this.registry.registry[item.id].parallel_delimiter_override;
            } else {
                this.output.queue[0].strings.delimiter = ", ";
            }
            this.tmp.term_predecessor = false;
            this.tmp.cite_index = 0;
            for (j = 0, jlen = sortedItems.length; j < jlen; j += 1) {
                if (j < sortedItems.length - 1) {
                    this.tmp.parallel_and_not_last = true;
                } else {
                    delete this.tmp.parallel_and_not_last;
                }
                entry_item_ids.push("" + CSL.getCite.call(this, sortedItems[j][0], sortedItems[j][1]));
                this.tmp.cite_index++;
                skips[sortedItems[j][0].id] = true;
            }
        } else if (!this.registry.registry[item.id].siblings) {
            this.tmp.term_predecessor = false;
            this.tmp.cite_index = 0;
            entry_item_ids.push("" + CSL.getCite.call(this, item));
            if (bibsection && bibsection.page_start && bibsection.page_length) {
                page_item_count += 1;
            }
        }
        entry_item_data.push("");
        this.tmp.bibliography_pos += 1;
        processed_item_ids.push(entry_item_ids);
        this.output.endTag("bib_entry");
        if (this.output.queue[0].blobs.length && this.output.queue[0].blobs[0].blobs.length) {
            if (!this.output.queue[0].blobs[0].blobs[0].strings) {
                topblobs = this.output.queue[0].blobs;
            } else {
                topblobs = this.output.queue[0].blobs[0].blobs;
            }
            topblobs[0].strings.prefix = this.bibliography.opt.layout_prefix + topblobs[0].strings.prefix;
        }
        for (j = 0, jlen = this.output.queue.length; j < jlen; j += 1) {
            CSL.Output.Queue.purgeEmptyBlobs(this.output.queue[j]);
        }
        for (j = 0, jlen = this.output.queue.length; j < jlen; j += 1) {
            this.output.adjust.upward(this.output.queue[j]);
            this.output.adjust.leftward(this.output.queue[j]);
            this.output.adjust.downward(this.output.queue[j], true);
            this.output.adjust.fix(this.output.queue[j]);
        }
        res = this.output.string(this, this.output.queue)[0];
        if (!res && this.opt.update_mode === CSL.NUMERIC) {
            var err = ret.length + 1 + ". [CSL STYLE ERROR: reference with no printed form.]";
            res = CSL.Output.Formats[this.opt.mode]["@bibliography/entry"](this, err);
        }
        if (res) {
            ret.push(res);
        }
    }
    var done = false;
    if (bibsection && bibsection.page_start && bibsection.page_length) {
        var last_expected_id = input.slice(-1)[0];
        var last_seen_id = processed_item_ids.slice(-1)[0];
        if (!last_expected_id || !last_seen_id || last_expected_id == last_seen_id) {
            done = true;
        }
    }
    this.tmp.disambig_override = false;
    return [ processed_item_ids, ret, done ];
};

CSL.Engine.prototype.setCitationId = function(citation, force) {
    var ret, id, direction;
    ret = false;
    if (!citation.citationID || force) {
        id = Math.floor(Math.random() * 1e14);
        while (true) {
            direction = 0;
            if (!this.registry.citationreg.citationById[id]) {
                citation.citationID = "a" + id.toString(32);
                break;
            } else if (!direction && id < 5e13) {
                direction = 1;
            } else {
                direction = -1;
            }
            if (direction === 1) {
                id += 1;
            } else {
                id += -1;
            }
        }
        ret = "" + id;
    }
    this.registry.citationreg.citationById[citation.citationID] = citation;
    return ret;
};

CSL.Engine.prototype.rebuildProcessorState = function(citations, mode, uncitedItemIDs) {
    if (!citations) {
        citations = [];
    }
    if (!mode) {
        mode = "html";
    }
    var doneIDs = {};
    var itemIDs = [];
    for (var i = 0, ilen = citations.length; i < ilen; i += 1) {
        for (var j = 0, jlen = citations[i].citationItems.length; j < jlen; j += 1) {
            var itemID = "" + citations[i].citationItems[j].id;
            if (!doneIDs[itemID]) {
                itemIDs.push(itemID);
            }
            doneIDs[itemID] = true;
        }
    }
    this.updateItems(itemIDs);
    var pre = [];
    var post = [];
    var ret = [];
    var oldMode = this.opt.mode;
    this.setOutputFormat(mode);
    for (var i = 0, ilen = citations.length; i < ilen; i += 1) {
        var res = this.processCitationCluster(citations[i], pre, post, CSL.ASSUME_ALL_ITEMS_REGISTERED);
        pre.push([ citations[i].citationID, citations[i].properties.noteIndex ]);
        for (var j = 0, jlen = res[1].length; j < jlen; j += 1) {
            var index = res[1][j][0];
            ret[index] = [ pre[index][0], pre[index][1], res[1][j][1] ];
        }
    }
    this.updateUncitedItems(uncitedItemIDs);
    this.setOutputFormat(oldMode);
    return ret;
};

CSL.Engine.prototype.restoreProcessorState = function(citations) {
    var i, ilen, j, jlen, item, Item, newitem, citationList, itemList, sortedItems;
    citationList = [];
    itemList = [];
    if (!citations) {
        citations = [];
    }
    var indexNumbers = [];
    var citationIds = {};
    for (i = 0, ilen = citations.length; i < ilen; i += 1) {
        if (citationIds[citations[i].citationID]) {
            this.setCitationId(citations[i], true);
        }
        citationIds[citations[i].citationID] = true;
        indexNumbers.push(citations[i].properties.index);
    }
    var oldCitations = citations.slice();
    oldCitations.sort(function(a, b) {
        if (a.properties.index < b.properties.index) {
            return -1;
        } else if (a.properties.index > b.properties.index) {
            return 1;
        } else {
            return 0;
        }
    });
    for (i = 0, ilen = oldCitations.length; i < ilen; i += 1) {
        oldCitations[i].properties.index = i;
    }
    for (i = 0, ilen = oldCitations.length; i < ilen; i += 1) {
        sortedItems = [];
        for (j = 0, jlen = oldCitations[i].citationItems.length; j < jlen; j += 1) {
            item = oldCitations[i].citationItems[j];
            if ("undefined" === typeof item.sortkeys) {
                item.sortkeys = [];
            }
            Item = this.retrieveItem("" + item.id);
            newitem = [ Item, item ];
            sortedItems.push(newitem);
            oldCitations[i].citationItems[j].item = Item;
            itemList.push("" + item.id);
        }
        if (!oldCitations[i].properties.unsorted) {
            sortedItems.sort(this.citation.srt.compareCompositeKeys);
        }
        oldCitations[i].sortedItems = sortedItems;
        this.registry.citationreg.citationById[oldCitations[i].citationID] = oldCitations[i];
    }
    this.updateItems(itemList);
    for (i = 0, ilen = citations.length; i < ilen; i += 1) {
        citationList.push([ "" + citations[i].citationID, citations[i].properties.noteIndex ]);
    }
    var ret = [];
    if (citations && citations.length) {
        ret = this.processCitationCluster(citations[0], [], citationList.slice(1));
    } else {
        this.registry = new CSL.Registry(this);
        this.tmp = new CSL.Engine.Tmp;
        this.disambiguate = new CSL.Disambiguation(this);
    }
    return ret;
};

CSL.Engine.prototype.updateItems = function(idList, nosort, rerun_ambigs, implicitUpdate) {
    var oldArea = this.tmp.area;
    var oldRoot = this.tmp.root;
    var oldExtension = this.tmp.extension;
    if (this.bibliography_sort.tokens.length === 0) {
        nosort = true;
    }
    this.tmp.area = "citation";
    this.tmp.root = "citation";
    this.tmp.extension = "";
    if (!implicitUpdate) {
        this.tmp.loadedItemIDs = {};
    }
    this.registry.init(idList);
    if (rerun_ambigs) {
        for (var ambig in this.registry.ambigcites) {
            this.registry.ambigsTouched[ambig] = true;
        }
    }
    this.registry.dodeletes(this.registry.myhash);
    this.registry.doinserts(this.registry.mylist);
    this.registry.dorefreshes();
    this.registry.rebuildlist(nosort);
    this.registry.setsortkeys();
    this.registry.setdisambigs();
    this.registry.sorttokens(nosort);
    this.registry.renumber();
    this.tmp.extension = oldExtension;
    this.tmp.area = oldArea;
    this.tmp.root = oldRoot;
    return this.registry.getSortedIds();
};

CSL.Engine.prototype.updateUncitedItems = function(idList, nosort) {
    var idHash;
    var oldArea = this.tmp.area;
    var oldRoot = this.tmp.root;
    var oldExtension = this.tmp.extension;
    if (this.bibliography_sort.tokens.length === 0) {
        nosort = true;
    }
    this.tmp.area = "citation";
    this.tmp.root = "citation";
    this.tmp.extension = "";
    this.tmp.loadedItemIDs = {};
    if (!idList) {
        idList = [];
    }
    if ("object" == typeof idList) {
        if ("undefined" == typeof idList.length) {
            idHash = idList;
            idList = [];
            for (var key in idHash) {
                idList.push(key);
            }
        } else if ("number" == typeof idList.length) {
            idHash = {};
            for (var i = 0, ilen = idList.length; i < ilen; i += 1) {
                idHash[idList[i]] = true;
            }
        }
    }
    this.registry.init(idList, true);
    this.registry.dopurge(idHash);
    this.registry.doinserts(this.registry.mylist);
    this.registry.dorefreshes();
    this.registry.rebuildlist(nosort);
    this.registry.setsortkeys();
    this.registry.setdisambigs();
    this.registry.sorttokens(nosort);
    this.registry.renumber();
    this.tmp.extension = oldExtension;
    this.tmp.area = oldArea;
    this.tmp.root = oldRoot;
    return this.registry.getSortedIds();
};

CSL.localeResolve = function(langstr, defaultLocale) {
    var ret, langlst;
    if (!defaultLocale) {
        defaultLocale = "en-US";
    }
    if (!langstr) {
        langstr = defaultLocale;
    }
    ret = {};
    langlst = langstr.split(/[\-_]/);
    ret.base = CSL.LANG_BASES[langlst[0]];
    if ("undefined" === typeof ret.base) {
        return {
            base: defaultLocale,
            best: langstr,
            bare: langlst[0]
        };
    }
    if (langlst.length === 1) {
        ret.generic = true;
    }
    if (langlst.length === 1 || langlst[1] === "x") {
        ret.best = ret.base.replace("_", "-");
    } else {
        ret.best = langlst.slice(0, 2).join("-");
    }
    ret.base = ret.base.replace("_", "-");
    ret.bare = langlst[0];
    return ret;
};

CSL.Engine.prototype.localeConfigure = function(langspec, beShy) {
    var localexml;
    if (beShy && this.locale[langspec.best]) {
        return;
    }
    if (langspec.best === "en-US") {
        localexml = CSL.setupXml(this.sys.retrieveLocale("en-US"));
        this.localeSet(localexml, "en-US", langspec.best);
    } else if (langspec.best !== "en-US") {
        if (langspec.base !== langspec.best) {
            localexml = CSL.setupXml(this.sys.retrieveLocale(langspec.base));
            this.localeSet(localexml, langspec.base, langspec.best);
        }
        localexml = CSL.setupXml(this.sys.retrieveLocale(langspec.best));
        this.localeSet(localexml, langspec.best, langspec.best);
    }
    this.localeSet(this.cslXml, "", langspec.best);
    this.localeSet(this.cslXml, langspec.bare, langspec.best);
    if (langspec.base !== langspec.best) {
        this.localeSet(this.cslXml, langspec.base, langspec.best);
    }
    this.localeSet(this.cslXml, langspec.best, langspec.best);
    if ("undefined" === typeof this.locale[langspec.best].terms["page-range-delimiter"]) {
        if ([ "fr", "pt" ].indexOf(langspec.best.slice(0, 2).toLowerCase()) > -1) {
            this.locale[langspec.best].terms["page-range-delimiter"] = "-";
        } else {
            this.locale[langspec.best].terms["page-range-delimiter"] = "–";
        }
    }
    if ("undefined" === typeof this.locale[langspec.best].terms["year-range-delimiter"]) {
        this.locale[langspec.best].terms["year-range-delimiter"] = "–";
    }
    if ("undefined" === typeof this.locale[langspec.best].terms["citation-range-delimiter"]) {
        this.locale[langspec.best].terms["citation-range-delimiter"] = "–";
    }
    if (this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
        var localeLists = [ "default-locale", "locale-sort", "locale-translit", "locale-translat" ];
        for (var i = 0, ilen = localeLists.length; i < ilen; i += 1) {
            for (var j = 0, jlen = this.opt[localeLists[i]].length; j < jlen; j += 1) {
                this.opt[localeLists[i]][j] = this.opt[localeLists[i]][j].toLowerCase();
            }
        }
        this.opt.lang = this.opt.lang.toLowerCase();
    }
};

CSL.Engine.prototype.localeSet = function(myxml, lang_in, lang_out) {
    var blob, locale, nodes, attributes, pos, term, form, termname, styleopts, date, attrname, len, genderform, target, i, ilen;
    lang_in = lang_in.replace("_", "-");
    lang_out = lang_out.replace("_", "-");
    if (this.opt.development_extensions.normalize_lang_keys_to_lowercase) {
        lang_in = lang_in.toLowerCase();
        lang_out = lang_out.toLowerCase();
    }
    if (!this.locale[lang_out]) {
        this.locale[lang_out] = {};
        this.locale[lang_out].terms = {};
        this.locale[lang_out].opts = {};
        this.locale[lang_out].opts["skip-words"] = CSL.SKIP_WORDS;
        if (!this.locale[lang_out].opts["leading-noise-words"]) {
            this.locale[lang_out].opts["leading-noise-words"] = [];
        }
        this.locale[lang_out].dates = {};
        this.locale[lang_out].ord = {
            "1.0.1": false,
            keys: {}
        };
        this.locale[lang_out]["noun-genders"] = {};
    }
    locale = myxml.makeXml();
    if (myxml.nodeNameIs(myxml.dataObj, "locale")) {
        locale = myxml.dataObj;
    } else {
        nodes = myxml.getNodesByName(myxml.dataObj, "locale");
        var foundLocale = false;
        for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
            blob = nodes[pos];
            if (!foundLocale && myxml.getAttributeValue(blob, "lang", "xml") === lang_in) {
                locale = blob;
                foundLocale = true;
            } else {
                var lang = myxml.getAttributeValue(blob, "lang", "xml");
                var style_options = myxml.getNodesByName(blob, "style-options");
                if (lang && style_options && style_options.length) {
                    var jurispref = myxml.getAttributeValue(style_options[0], "jurisdiction-preference");
                    if (jurispref) {
                        if (!this.locale[lang]) {
                            this.locale[lang] = {
                                opts: {}
                            };
                        }
                        this.locale[lang].opts["jurisdiction-preference"] = jurispref.split(/\s+/);
                    }
                }
            }
        }
    }
    nodes = myxml.getNodesByName(locale, "type");
    for (i = 0, ilen = myxml.numberofnodes(nodes); i < ilen; i += 1) {
        var typenode = nodes[i];
        var type = myxml.getAttributeValue(typenode, "name");
        var gender = myxml.getAttributeValue(typenode, "gender");
        this.opt.gender[type] = gender;
    }
    var hasCslOrdinals101 = myxml.getNodesByName(locale, "term", "ordinal").length;
    if (hasCslOrdinals101) {
        for (var key in this.locale[lang_out].ord.keys) {
            delete this.locale[lang_out].terms[key];
        }
        this.locale[lang_out].ord = {
            "1.0.1": false,
            keys: {}
        };
    }
    nodes = myxml.getNodesByName(locale, "term");
    var ordinals101 = {
        "last-digit": {},
        "last-two-digits": {},
        "whole-number": {}
    };
    var ordinals101_toggle = false;
    var genderized_terms = {};
    for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
        term = nodes[pos];
        termname = myxml.getAttributeValue(term, "name");
        if (termname === "sub verbo") {
            termname = "sub-verbo";
        }
        if (termname.slice(0, 7) === "ordinal") {
            if (termname === "ordinal") {
                ordinals101_toggle = true;
            } else {
                var match = myxml.getAttributeValue(term, "match");
                var termstub = termname.slice(8);
                var genderform = myxml.getAttributeValue(term, "gender-form");
                if (!genderform) {
                    genderform = "neuter";
                }
                if (!match) {
                    match = "last-two-digits";
                    if (termstub.slice(0, 1) === "0") {
                        match = "last-digit";
                    }
                }
                if (termstub.slice(0, 1) === "0") {
                    termstub = termstub.slice(1);
                }
                if (!ordinals101[match][termstub]) {
                    ordinals101[match][termstub] = {};
                }
                ordinals101[match][termstub][genderform] = termname;
            }
            this.locale[lang_out].ord.keys[termname] = true;
        }
        if ("undefined" === typeof this.locale[lang_out].terms[termname]) {
            this.locale[lang_out].terms[termname] = {};
        }
        form = "long";
        genderform = false;
        if (myxml.getAttributeValue(term, "form")) {
            form = myxml.getAttributeValue(term, "form");
        }
        if (myxml.getAttributeValue(term, "gender-form")) {
            genderform = myxml.getAttributeValue(term, "gender-form");
        }
        if (myxml.getAttributeValue(term, "gender")) {
            this.locale[lang_out]["noun-genders"][termname] = myxml.getAttributeValue(term, "gender");
        }
        if (genderform) {
            this.locale[lang_out].terms[termname][genderform] = {};
            this.locale[lang_out].terms[termname][genderform][form] = [];
            target = this.locale[lang_out].terms[termname][genderform];
            genderized_terms[termname] = true;
        } else {
            this.locale[lang_out].terms[termname][form] = [];
            target = this.locale[lang_out].terms[termname];
        }
        if (myxml.numberofnodes(myxml.getNodesByName(term, "multiple"))) {
            target[form][0] = myxml.getNodeValue(term, "single");
            if (target[form][0].indexOf("%s") > -1) {
                this.opt.hasPlaceholderTerm = true;
            }
            target[form][1] = myxml.getNodeValue(term, "multiple");
            if (target[form][1].indexOf("%s") > -1) {
                this.opt.hasPlaceholderTerm = true;
            }
        } else {
            target[form] = myxml.getNodeValue(term);
            if (target[form].indexOf("%s") > -1) {
                this.opt.hasPlaceholderTerm = true;
            }
        }
    }
    if (!this.locale[lang_out].terms.supplement) {
        this.locale[lang_out].terms.supplement = {};
    }
    if (!this.locale[lang_out].terms.supplement["long"]) {
        this.locale[lang_out].terms.supplement["long"] = [ "supplement", "supplements" ];
    }
    if (ordinals101_toggle) {
        for (var ikey in genderized_terms) {
            var gender_segments = {};
            var form_segments = 0;
            for (var jkey in this.locale[lang_out].terms[ikey]) {
                if ([ "masculine", "feminine" ].indexOf(jkey) > -1) {
                    gender_segments[jkey] = this.locale[lang_out].terms[ikey][jkey];
                } else {
                    form_segments += 1;
                }
            }
            if (!form_segments) {
                if (gender_segments.feminine) {
                    for (var jkey in gender_segments.feminine) {
                        this.locale[lang_out].terms[ikey][jkey] = gender_segments.feminine[jkey];
                    }
                } else if (gender_segments.masculine) {
                    for (var jkey in gender_segments.masculine) {
                        this.locale[lang_out].terms[ikey][jkey] = gender_segments.masculine[jkey];
                    }
                }
            }
        }
        this.locale[lang_out].ord["1.0.1"] = ordinals101;
    }
    for (termname in this.locale[lang_out].terms) {
        for (i = 0, ilen = 2; i < ilen; i += 1) {
            genderform = CSL.GENDERS[i];
            if (this.locale[lang_out].terms[termname][genderform]) {
                for (form in this.locale[lang_out].terms[termname]) {
                    if (!this.locale[lang_out].terms[termname][genderform][form]) {
                        this.locale[lang_out].terms[termname][genderform][form] = this.locale[lang_out].terms[termname][form];
                    }
                }
            }
        }
    }
    nodes = myxml.getNodesByName(locale, "style-options");
    for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
        {
            styleopts = nodes[pos];
            attributes = myxml.attributes(styleopts);
            for (attrname in attributes) {
                if (attributes.hasOwnProperty(attrname)) {
                    if (attrname === "@punctuation-in-quote" || attrname === "@limit-day-ordinals-to-day-1") {
                        if (attributes[attrname] === "true") {
                            this.locale[lang_out].opts[attrname.slice(1)] = true;
                        } else {
                            this.locale[lang_out].opts[attrname.slice(1)] = false;
                        }
                    } else if (attrname === "@jurisdiction-preference") {
                        var jurisdiction_preference = attributes[attrname].split(/\s+/);
                        this.locale[lang_out].opts[attrname.slice(1)] = jurisdiction_preference;
                    } else if (attrname === "@skip-words") {
                        var skip_words = attributes[attrname].split(/\s*,\s*/);
                        this.locale[lang_out].opts[attrname.slice(1)] = skip_words;
                    } else if (attrname === "@leading-noise-words") {
                        var val = attributes[attrname].split(/\s*,\s*/);
                        this.locale[lang_out].opts["leading-noise-words"] = val;
                    } else if (attrname === "@name-as-sort-order") {
                        this.locale[lang_out].opts["name-as-sort-order"] = {};
                        var lst = attributes[attrname].split(/\s+/);
                        for (var i = 0, ilen = lst.length; i < ilen; i += 1) {
                            this.locale[lang_out].opts["name-as-sort-order"][lst[i]] = true;
                        }
                    } else if (attrname === "@name-as-reverse-order") {
                        this.locale[lang_out].opts["name-as-reverse-order"] = {};
                        var lst = attributes[attrname].split(/\s+/);
                        for (var i = 0, ilen = lst.length; i < ilen; i += 1) {
                            this.locale[lang_out].opts["name-as-reverse-order"][lst[i]] = true;
                        }
                    } else if (attrname === "@name-never-short") {
                        this.locale[lang_out].opts["name-never-short"] = {};
                        var lst = attributes[attrname].split(/\s+/);
                        for (var i = 0, ilen = lst.length; i < ilen; i += 1) {
                            this.locale[lang_out].opts["name-never-short"][lst[i]] = true;
                        }
                    }
                }
            }
        }
    }
    nodes = myxml.getNodesByName(locale, "date");
    for (pos = 0, len = myxml.numberofnodes(nodes); pos < len; pos += 1) {
        {
            var date = nodes[pos];
            this.locale[lang_out].dates[myxml.getAttributeValue(date, "form")] = date;
        }
    }
    CSL.SET_COURT_CLASSES(this, lang_out, myxml, locale);
};

CSL.getLocaleNames = function(myxml, preferredLocale) {
    var stylexml = CSL.setupXml(myxml);
    function extendLocaleList(localeList, locale) {
        var forms = [ "base", "best" ];
        if (locale) {
            var normalizedLocale = CSL.localeResolve(locale);
            for (var i = 0, ilen = forms.length; i < ilen; i++) {
                if (normalizedLocale[forms[i]] && localeList.indexOf(normalizedLocale[forms[i]]) === -1) {
                    localeList.push(normalizedLocale[forms[i]]);
                }
            }
        }
    }
    var localeIDs = [ "en-US" ];
    function sniffLocaleOnOneNodeName(nodeName) {
        var nodes = stylexml.getNodesByName(stylexml.dataObj, nodeName);
        for (var i = 0, ilen = nodes.length; i < ilen; i++) {
            var nodeLocales = stylexml.getAttributeValue(nodes[i], "locale");
            if (nodeLocales) {
                nodeLocales = nodeLocales.split(/ +/);
                for (var j = 0, jlen = nodeLocales.length; j < jlen; j++) {
                    this.extendLocaleList(localeIDs, nodeLocales[j]);
                }
            }
        }
    }
    extendLocaleList(localeIDs, preferredLocale);
    var styleNode = stylexml.getNodesByName(stylexml.dataObj, "style")[0];
    var defaultLocale = stylexml.getAttributeValue(styleNode, "default-locale");
    extendLocaleList(localeIDs, defaultLocale);
    var nodeNames = [ "layout", "if", "else-if", "condition" ];
    for (var i = 0, ilen = nodeNames.length; i < ilen; i++) {
        sniffLocaleOnOneNodeName(stylexml);
    }
    return localeIDs;
};

CSL.Node = {};

CSL.Node.bibliography = {
    build: function build(state, target) {
        if (this.tokentype === CSL.START) {
            state.build.area = "bibliography";
            state.build.root = "bibliography";
            state.build.extension = "";
            var func = function func(state) {
                state.tmp.area = "bibliography";
                state.tmp.root = "bibliography";
                state.tmp.extension = "";
            };
            this.execs.push(func);
        }
        target.push(this);
    }
};

CSL.Node.choose = {
    build: function build(state, target) {
        var func;
        if (this.tokentype === CSL.START) {
            func = function func(state) {
                state.tmp.jump.push(undefined, CSL.LITERAL);
            };
        }
        if (this.tokentype === CSL.END) {
            func = function func(state) {
                state.tmp.jump.pop();
            };
        }
        this.execs.push(func);
        target.push(this);
    },
    configure: function configure(state, pos) {
        if (this.tokentype === CSL.END) {
            state.configure.fail.push(pos);
            state.configure.succeed.push(pos);
        } else {
            state.configure.fail.pop();
            state.configure.succeed.pop();
        }
    }
};

CSL.Node.citation = {
    build: function build(state, target) {
        if (this.tokentype === CSL.START) {
            state.build.area = "citation";
            state.build.root = "citation";
            state.build.extension = "";
            var func = function func(state) {
                state.tmp.area = "citation";
                state.tmp.root = "citation";
                state.tmp.extension = "";
            };
            this.execs.push(func);
        }
        if (this.tokentype === CSL.END) {
            state.opt.grouped_sort = state.opt.xclass === "in-text" && state.citation.opt.collapse && state.citation.opt.collapse.length || state.citation.opt.cite_group_delimiter && state.citation.opt.cite_group_delimiter.length && state.opt.update_mode !== CSL.POSITION && state.opt.update_mode !== CSL.NUMERIC;
            if (state.opt.grouped_sort && state.citation_sort.opt.sort_directions.length) {
                var firstkey = state.citation_sort.opt.sort_directions[0].slice();
                state.citation_sort.opt.sort_directions = [ firstkey ].concat(state.citation_sort.opt.sort_directions);
            }
            state.citation.srt = new CSL.Registry.Comparifier(state, "citation_sort");
        }
        target.push(this);
    }
};

CSL.Node["#comment"] = {
    build: function build() {}
};

CSL.Node.date = {
    build: function build(state, target) {
        var func, date_obj, len, pos, part, dpx, parts, mypos, start, end;
        if (this.tokentype === CSL.START || this.tokentype === CSL.SINGLETON) {
            state.dateput.string(state, state.dateput.queue);
            state.tmp.date_token = CSL.Util.cloneToken(this);
            state.tmp.date_token.strings.prefix = "";
            state.tmp.date_token.strings.suffix = "";
            state.dateput.openLevel(this);
            state.build.date_parts = [];
            state.build.date_variables = this.variables;
            if (!state.build.extension) {
                CSL.Util.substituteStart.call(this, state, target);
            }
            if (state.build.extension) {
                func = CSL.dateMacroAsSortKey;
            } else {
                func = function func(state, Item, item) {
                    var dp;
                    state.tmp.element_rendered_ok = false;
                    state.tmp.donesies = [];
                    state.tmp.dateparts = [];
                    dp = [];
                    if (this.variables.length && !(state.tmp.just_looking && this.variables[0] === "accessed")) {
                        date_obj = Item[this.variables[0]];
                        if ("undefined" === typeof date_obj) {
                            date_obj = {
                                "date-parts": [ [ 0 ] ]
                            };
                            if (state.opt.development_extensions.locator_date_and_revision) {
                                if (item && this.variables[0] === "locator-date" && item["locator-date"]) {
                                    date_obj = item["locator-date"];
                                }
                            }
                        }
                        state.tmp.date_object = date_obj;
                        len = this.dateparts.length;
                        for (pos = 0; pos < len; pos += 1) {
                            part = this.dateparts[pos];
                            if ("undefined" !== typeof state.tmp.date_object[part + "_end"]) {
                                dp.push(part);
                            } else if (part === "month" && "undefined" !== typeof state.tmp.date_object.season_end) {
                                dp.push(part);
                            }
                        }
                        dpx = [];
                        parts = [ "year", "month", "day" ];
                        len = parts.length;
                        for (pos = 0; pos < len; pos += 1) {
                            if (dp.indexOf(parts[pos]) > -1) {
                                dpx.push(parts[pos]);
                            }
                        }
                        dp = dpx.slice();
                        mypos = 2;
                        len = dp.length;
                        for (pos = 0; pos < len; pos += 1) {
                            part = dp[pos];
                            start = state.tmp.date_object[part];
                            end = state.tmp.date_object[part + "_end"];
                            if (start !== end) {
                                mypos = pos;
                                break;
                            }
                        }
                        state.tmp.date_collapse_at = dp.slice(mypos);
                    } else {
                        state.tmp.date_object = false;
                    }
                };
            }
            this.execs.push(func);
            func = function func(state, Item) {
                if (!Item[this.variables[0]]) {
                    return;
                }
                state.output.startTag("date", this);
                if (this.variables[0] === "issued" && (Item.type === "legal_case" || Item.type === "legislation") && state.opt.disable_duplicate_year_suppression.indexOf(Item.country) === -1 && !state.tmp.extension && "" + Item["collection-number"] === "" + state.tmp.date_object.year && this.dateparts.length === 1 && this.dateparts[0] === "year") {
                    for (var key in state.tmp.date_object) {
                        if (state.tmp.date_object.hasOwnProperty(key)) {
                            if (key.slice(0, 4) === "year") {
                                state.tmp.issued_date = {};
                                var lst = state.output.current.mystack.slice(-2)[0].blobs;
                                state.tmp.issued_date.list = lst;
                                state.tmp.issued_date.pos = lst.length - 1;
                            }
                        }
                    }
                }
            };
            this.execs.push(func);
        }
        if (!state.build.extension && (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON)) {
            func = function func(state, Item) {
                if (!Item[this.variables[0]]) {
                    return;
                }
                state.output.endTag();
            };
            this.execs.push(func);
        }
        target.push(this);
        if (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON) {
            if (!state.build.extension) {
                CSL.Util.substituteEnd.call(this, state, target);
            }
        }
    }
};

CSL.Node["date-part"] = {
    build: function build(state, target) {
        var func, pos, len, first_date, value, value_end, real, have_collapsed, invoked, precondition, known_year, bc, ad, ready, curr, dcurr, number, num, formatter, item, blob;
        if (!this.strings.form) {
            this.strings.form = "long";
        }
        state.build.date_parts.push(this.strings.name);
        var date_variable = state.build.date_variables[0];
        function formatAndStrip(myform, gender, val) {
            if (!val) {
                return val;
            }
            val = "" + CSL.Util.Dates[this.strings.name][myform](state, val, gender, this.default_locale);
            if ("month" === this.strings.name) {
                if (state.tmp.strip_periods) {
                    val = val.replace(/\./g, "");
                } else {
                    for (var i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
                        if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                            val = val.replace(/\./g, "");
                            break;
                        }
                    }
                }
            }
            return val;
        }
        func = function func(state, Item) {
            if (!state.tmp.date_object) {
                return;
            } else {
                state.tmp.probably_rendered_something = true;
            }
            var last_string_output = "";
            first_date = true;
            value = "";
            value_end = "";
            state.tmp.donesies.push(this.strings.name);
            if (state.tmp.date_object.literal && "year" === this.strings.name) {
                last_string_output = state.tmp.date_object.literal;
                state.output.append(state.tmp.date_object.literal, this);
            }
            if (state.tmp.date_object) {
                value = state.tmp.date_object[this.strings.name];
                value_end = state.tmp.date_object[this.strings.name + "_end"];
            }
            if ("year" === this.strings.name && value === 0 && !state.tmp.suppress_decorations) {
                value = false;
            }
            real = !state.tmp.suppress_decorations;
            have_collapsed = state.tmp.have_collapsed;
            invoked = state[state.tmp.area].opt.collapse === "year-suffix" || state[state.tmp.area].opt.collapse === "year-suffix-ranged";
            precondition = state.opt["disambiguate-add-year-suffix"];
            if (real && precondition && invoked) {
                state.tmp.years_used.push(value);
                known_year = state.tmp.last_years_used.length >= state.tmp.years_used.length;
                if (known_year && have_collapsed) {
                    if (state.tmp.last_years_used[state.tmp.years_used.length - 1] === value) {
                        value = false;
                    }
                }
            }
            if ("undefined" !== typeof value) {
                bc = false;
                ad = false;
                if ("year" === this.strings.name) {
                    if (parseInt(value, 10) < 500 && parseInt(value, 10) > 0) {
                        ad = state.getTerm("ad");
                    }
                    if (parseInt(value, 10) < 0) {
                        bc = state.getTerm("bc");
                        value = parseInt(value, 10) * -1;
                    }
                    if (value_end) {
                        if (parseInt(value_end, 10) < 500 && parseInt(value_end, 10) > 0) {
                            state.getTerm("ad");
                        }
                        if (parseInt(value_end, 10) < 0) {
                            state.getTerm("bc");
                            value_end = parseInt(value_end, 10) * -1;
                        }
                    }
                }
                var monthnameid = "" + state.tmp.date_object.month;
                while (monthnameid.length < 2) {
                    monthnameid = "0" + monthnameid;
                }
                monthnameid = "month-" + monthnameid;
                var gender = state.locale[state.opt.lang]["noun-genders"][monthnameid];
                if (this.strings.form) {
                    var myform = this.strings.form;
                    var myform_end = this.strings.form;
                    if (this.strings.name === "day") {
                        if (myform === "ordinal" && state.locale[state.opt.lang].opts["limit-day-ordinals-to-day-1"]) {
                            if (value != 1) {
                                myform = "numeric";
                            }
                            if (value_end != 1) {
                                myform_end = "numeric";
                            }
                        }
                    }
                    value = formatAndStrip.call(this, myform, gender, value);
                    value_end = formatAndStrip.call(this, myform_end, gender, value_end);
                }
                state.output.openLevel("empty");
                if (state.tmp.date_collapse_at.length) {
                    ready = true;
                    len = state.tmp.date_collapse_at.length;
                    for (pos = 0; pos < len; pos += 1) {
                        item = state.tmp.date_collapse_at[pos];
                        if (state.tmp.donesies.indexOf(item) === -1) {
                            ready = false;
                            break;
                        }
                    }
                    if (ready) {
                        if ("" + value_end !== "0") {
                            if (state.dateput.queue.length === 0) {
                                first_date = true;
                            }
                            if (state.opt["year-range-format"] && state.opt["year-range-format"] !== "expanded" && !state.tmp.date_object.day && !state.tmp.date_object.month && !state.tmp.date_object.season && this.strings.name === "year" && value && value_end) {
                                value_end = state.fun.year_mangler(value + "-" + value_end, true);
                                var range_delimiter = state.getTerm("year-range-delimiter");
                                value_end = value_end.slice(value_end.indexOf(range_delimiter) + 1);
                            }
                            last_string_output = value_end;
                            state.dateput.append(value_end, this);
                            if (first_date) {
                                blob = state.dateput.current.value().blobs[0];
                                if (blob) {
                                    blob.strings.prefix = "";
                                }
                            }
                        }
                        last_string_output = value;
                        state.output.append(value, this);
                        curr = state.output.current.value();
                        blob = curr.blobs[curr.blobs.length - 1];
                        if (blob) {
                            blob.strings.suffix = "";
                        }
                        if (this.strings["range-delimiter"]) {
                            state.output.append(this.strings["range-delimiter"]);
                        } else {
                            state.output.append(state.getTerm("year-range-delimiter"), "empty");
                        }
                        state.dateput.closeLevel();
                        dcurr = state.dateput.current.value();
                        curr.blobs = curr.blobs.concat(dcurr);
                        state.dateput.string(state, state.dateput.queue);
                        state.dateput.openLevel(state.tmp.date_token);
                        state.tmp.date_collapse_at = [];
                    } else {
                        last_string_output = value;
                        state.output.append(value, this);
                        if (state.tmp.date_collapse_at.indexOf(this.strings.name) > -1) {
                            if ("" + value_end !== "0") {
                                if (state.dateput.queue.length === 0) {
                                    first_date = true;
                                }
                                state.dateput.openLevel("empty");
                                last_string_output = value_end;
                                state.dateput.append(value_end, this);
                                if (first_date) {
                                    blob = state.dateput.current.value().blobs[0];
                                    if (blob) {
                                        blob.strings.prefix = "";
                                    }
                                }
                                if (bc) {
                                    last_string_output = bc;
                                    state.dateput.append(bc);
                                }
                                if (ad) {
                                    last_string_output = ad;
                                    state.dateput.append(ad);
                                }
                                state.dateput.closeLevel();
                            }
                        }
                    }
                } else {
                    last_string_output = value;
                    state.output.append(value, this);
                }
                if (bc) {
                    last_string_output = bc;
                    state.output.append(bc);
                }
                if (ad) {
                    last_string_output = ad;
                    state.output.append(ad);
                }
                state.output.closeLevel();
            } else if ("month" === this.strings.name) {
                if (state.tmp.date_object.season) {
                    value = "" + state.tmp.date_object.season;
                    if (value && value.match(/^[1-4]$/)) {
                        state.tmp.group_context.tip.variable_success = true;
                        last_string_output = "winter";
                        state.output.append(state.getTerm("season-0" + value), this);
                    } else if (value) {
                        last_string_output = value;
                        state.output.append(value, this);
                    }
                }
            }
            state.tmp.value = [];
            if (Item[date_variable] && (value || state.tmp.have_collapsed) && !state.opt.has_year_suffix && "year" === this.strings.name && !state.tmp.just_looking) {
                if (state.registry.registry[Item.id] && state.registry.registry[Item.id].disambig.year_suffix !== false && !state.tmp.has_done_year_suffix) {
                    state.tmp.has_done_year_suffix = true;
                    last_string_output = "x";
                    num = parseInt(state.registry.registry[Item.id].disambig.year_suffix, 10);
                    number = new CSL.NumericBlob(state, false, num, this, Item.id);
                    this.successor_prefix = state[state.build.area].opt.layout_delimiter;
                    this.splice_prefix = state[state.build.area].opt.layout_delimiter;
                    formatter = new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);
                    number.setFormatter(formatter);
                    if (state[state.tmp.area].opt.collapse === "year-suffix-ranged") {
                        number.range_prefix = state.getTerm("citation-range-delimiter");
                    }
                    if (state[state.tmp.area].opt.cite_group_delimiter) {
                        number.successor_prefix = state[state.tmp.area].opt.cite_group_delimiter;
                    } else if (state[state.tmp.area].opt["year-suffix-delimiter"]) {
                        number.successor_prefix = state[state.tmp.area].opt["year-suffix-delimiter"];
                    } else {
                        number.successor_prefix = state[state.tmp.area].opt.layout_delimiter;
                    }
                    number.UGLY_DELIMITER_SUPPRESS_HACK = true;
                    state.output.append(number, "literal");
                }
            }
            if (last_string_output && !state.tmp.group_context.tip.condition) {
                state.tmp.just_did_number = last_string_output.match(/[0-9]$/);
                if (state.output.current.tip.strings.suffix) {
                    state.tmp.just_did_number = false;
                }
            }
        };
        this.execs.push(func);
        target.push(this);
    }
};

CSL.Node["else-if"] = {
    build: function build(state, target) {
        CSL.Conditions.TopNode.call(this, state, target);
        target.push(this);
    },
    configure: function configure(state, pos) {
        CSL.Conditions.Configure.call(this, state, pos);
    }
};

CSL.Node["else"] = {
    build: function build(state, target) {
        target.push(this);
    },
    configure: function configure(state, pos) {
        if (this.tokentype === CSL.START) {
            state.configure.fail[state.configure.fail.length - 1] = pos;
        }
    }
};

CSL.Node["et-al"] = {
    build: function build(state, target) {
        if (state.build.area === "citation" || state.build.area === "bibliography") {
            var func = function func(state) {
                state.tmp.etal_node = this;
                if ("string" === typeof this.strings.term) {
                    state.tmp.etal_term = this.strings.term;
                }
            };
            this.execs.push(func);
        }
        target.push(this);
    }
};

CSL.Node.group = {
    build: function build(state, target, realGroup) {
        var func, execs;
        this.realGroup = realGroup;
        if (this.tokentype === CSL.START) {
            CSL.Util.substituteStart.call(this, state, target);
            if (state.build.substitute_level.value()) {
                state.build.substitute_level.replace(state.build.substitute_level.value() + 1);
            }
            if (!this.juris) {
                target.push(this);
            }
            func = function func(state) {
                state.output.startTag("group", this);
                if (this.strings.label_form_override) {
                    if (!state.tmp.group_context.tip.label_form) {
                        state.tmp.group_context.tip.label_form = this.strings.label_form_override;
                    }
                }
                if (this.strings.label_capitalize_if_first_override) {
                    if (!state.tmp.group_context.tip.label_capitalize_if_first) {
                        state.tmp.group_context.tip.label_capitalize_if_first = this.strings.label_capitalize_if_first_override;
                    }
                }
                if (this.realGroup) {
                    if (state.tmp.group_context.tip.condition) {
                        CSL.UPDATE_GROUP_CONTEXT_CONDITION(state, this.strings.prefix, null, this);
                    }
                    var condition = false;
                    var force_suppress = false;
                    if (state.tmp.group_context.mystack.length) {
                        state.output.current.value().parent = state.tmp.group_context.tip.output_tip;
                    }
                    var label_form = state.tmp.group_context.tip.label_form;
                    if (!label_form) {
                        label_form = this.strings.label_form_override;
                    }
                    var label_capitalize_if_first = state.tmp.group_context.tip.label_capitalize_if_first;
                    if (!label_capitalize_if_first) {
                        label_capitalize_if_first = this.strings.label_capitalize_if_first;
                    }
                    if (state.tmp.group_context.tip.condition) {
                        condition = state.tmp.group_context.tip.condition;
                        force_suppress = state.tmp.group_context.tip.force_suppress;
                    } else if (this.strings.reject) {
                        condition = {
                            test: this.strings.reject,
                            not: true
                        };
                    } else if (this.strings.require) {
                        condition = {
                            test: this.strings.require,
                            not: false
                        };
                    }
                    var context = {
                        old_term_predecessor: state.tmp.term_predecessor,
                        term_intended: false,
                        variable_attempt: false,
                        variable_success: false,
                        variable_success_parent: state.tmp.group_context.tip.variable_success,
                        output_tip: state.output.current.tip,
                        label_form: label_form,
                        label_static: state.tmp.group_context.tip.label_static,
                        label_capitalize_if_first: label_capitalize_if_first,
                        parallel_delimiter_override: this.strings.set_parallel_delimiter_override,
                        parallel_delimiter_override_on_suppress: this.strings.set_parallel_delimiter_override_on_suppress,
                        condition: condition,
                        force_suppress: force_suppress,
                        done_vars: state.tmp.group_context.tip.done_vars.slice()
                    };
                    if (this.non_parallel) {
                        var non_parallel = state.tmp.group_context.tip.non_parallel;
                        if (!non_parallel) {
                            non_parallel = {};
                        }
                        Object.assign(non_parallel, this.non_parallel);
                        context.non_parallel = non_parallel;
                    }
                    if (this.parallel_first) {
                        var parallel_first = state.tmp.group_context.tip.parallel_first;
                        if (!parallel_first) {
                            parallel_first = {};
                        }
                        Object.assign(parallel_first, this.parallel_first);
                        context.parallel_first = parallel_first;
                    }
                    if (this.parallel_last) {
                        var parallel_last = state.tmp.group_context.tip.parallel_last;
                        if (!parallel_last) {
                            parallel_last = {};
                        }
                        Object.assign(parallel_last, this.parallel_last);
                        context.parallel_last = parallel_last;
                    }
                    if (state.tmp.abbrev_trimmer && state.tmp.abbrev_trimmer.LAST_TO_FIRST && context.parallel_last) {
                        if (!context.parallel_first) {
                            context.parallel_first = {};
                        }
                        for (var varname in state.tmp.abbrev_trimmer.LAST_TO_FIRST) {
                            if (context.parallel_last[varname]) {
                                context.parallel_first[varname] = true;
                                delete context.parallel_last[varname];
                            }
                        }
                    }
                    state.tmp.group_context.push(context);
                    if (state.tmp.abbrev_trimmer && this.parallel_last_to_first) {
                        if (!state.tmp.abbrev_trimmer.LAST_TO_FIRST) {
                            state.tmp.abbrev_trimmer.LAST_TO_FIRST = {};
                        }
                        for (var varname in this.parallel_last_to_first) {
                            state.tmp.abbrev_trimmer.LAST_TO_FIRST[varname] = true;
                        }
                    }
                }
            };
            execs = [];
            execs.push(func);
            this.execs = execs.concat(this.execs);
            if (this.strings["has-publisher-and-publisher-place"]) {
                state.build["publisher-special"] = true;
                if (this.strings["subgroup-delimiter"]) {
                    func = function func(state, Item) {
                        if (Item.publisher && Item["publisher-place"]) {
                            var publisher_lst = Item.publisher.split(/;\s*/);
                            var publisher_place_lst = Item["publisher-place"].split(/;\s*/);
                            if (publisher_lst.length > 1 && publisher_lst.length === publisher_place_lst.length) {
                                state.publisherOutput = new CSL.PublisherOutput(state, this);
                                state.publisherOutput["publisher-list"] = publisher_lst;
                                state.publisherOutput["publisher-place-list"] = publisher_place_lst;
                            }
                        }
                    };
                    this.execs.push(func);
                }
            }
            if (this.juris) {
                var choose_start = new CSL.Token("choose", CSL.START);
                CSL.Node.choose.build.call(choose_start, state, target);
                var if_start = new CSL.Token("if", CSL.START);
                func = function(macroName) {
                    return function(Item, item) {
                        return CSL.INIT_JURISDICTION_MACROS(state, Item, item, macroName);
                    };
                }(this.juris);
                if_start.tests ? {} : if_start.tests = [];
                if_start.tests.push(func);
                if_start.test = state.fun.match.any(if_start, state, if_start.tests);
                target.push(if_start);
                var text_node = new CSL.Token("text", CSL.SINGLETON);
                func = function func(state, Item, item) {
                    var itemItem = Item;
                    if (item && item["best-jurisdiction"] && this.juris === "juris-locator") {
                        itemItem = item;
                    }
                    var next = 0;
                    if (state.juris[itemItem["best-jurisdiction"]][this.juris]) {
                        while (next < state.juris[itemItem["best-jurisdiction"]][this.juris].length) {
                            next = CSL.tokenExec.call(state, state.juris[itemItem["best-jurisdiction"]][this.juris][next], Item, item);
                        }
                    }
                };
                text_node.juris = this.juris;
                text_node.execs.push(func);
                target.push(text_node);
                var if_end = new CSL.Token("if", CSL.END);
                CSL.Node["if"].build.call(if_end, state, target);
                var else_start = new CSL.Token("else", CSL.START);
                CSL.Node["else"].build.call(else_start, state, target);
            }
        }
        if (this.tokentype === CSL.END) {
            if (state.build["publisher-special"]) {
                state.build["publisher-special"] = false;
                func = function func(state) {
                    if (state.publisherOutput) {
                        state.publisherOutput.render();
                        state.publisherOutput = false;
                    }
                };
                this.execs.push(func);
            }
            func = function func(state, Item, item) {
                if (!state.tmp.group_context.tip.condition) {
                    if (state.output.current.tip.strings.suffix) {
                        state.tmp.just_did_number = false;
                    }
                }
                state.output.endTag();
                if (this.realGroup) {
                    var flags = state.tmp.group_context.pop();
                    if (flags.parallel_delimiter_override) {
                        state.tmp.group_context.tip.parallel_delimiter_override = flags.parallel_delimiter_override;
                        if (!state.tmp.just_looking && state.registry.registry[Item.id].master) {
                            state.registry.registry[Item.id].parallel_delimiter_override = flags.parallel_delimiter_override;
                        }
                    }
                    if (flags.parallel_delimiter_override_on_suppress) {
                        state.tmp.group_context.tip.parallel_delimiter_override_on_suppress = flags.parallel_delimiter_override_on_suppress;
                    }
                    if (state.tmp.area === "bibliography_sort") {
                        var citationNumberIdx = flags.done_vars.indexOf("citation-number");
                        if (this.strings.sort_direction && citationNumberIdx > -1 && state.tmp.group_context.length() == 1) {
                            if (this.strings.sort_direction === CSL.DESCENDING) {
                                state.bibliography_sort.opt.citation_number_sort_direction = CSL.DESCENDING;
                            } else {
                                state.bibliography_sort.opt.citation_number_sort_direction = CSL.ASCENDING;
                            }
                            flags.done_vars = flags.done_vars.slice(0, citationNumberIdx).concat(flags.done_vars.slice(citationNumberIdx + 1));
                        }
                    }
                    if (flags.condition) {
                        flags.force_suppress = CSL.EVALUATE_GROUP_CONDITION(state, flags);
                    }
                    if (state.tmp.group_context.tip.condition) {
                        state.tmp.group_context.tip.force_suppress = flags.force_suppress;
                    }
                    if (!flags.force_suppress && (flags.variable_success || flags.term_intended && !flags.variable_attempt)) {
                        if (!this.isJurisLocatorLabel) {
                            state.tmp.group_context.tip.variable_success = true;
                        }
                        var blobs = state.output.current.value().blobs;
                        state.output.current.value().blobs.length - 1;
                        if (!state.tmp.just_looking && (flags.non_parallel || flags.parallel_last || flags.parallel_first || flags.parallel_delimiter_override || flags.parallel_delimiter_override_on_suppress)) {
                            var hasRepeat = state.parallel.checkRepeats(flags);
                            if (hasRepeat) {
                                if (blobs) {
                                    blobs.pop();
                                }
                            }
                            if (state.tmp.cite_index > 0 && (hasRepeat || !flags.parallel_first && !flags.parallel_last && !flags.non_parallel)) {
                                var info = state.tmp.suppress_repeats[state.tmp.cite_index - 1];
                                if (hasRepeat && flags.parallel_delimiter_override_on_suppress && (info.SIBLING || info.ORPHAN)) {
                                    state.output.queue.slice(-1)[0].parallel_delimiter = flags.parallel_delimiter_override_on_suppress;
                                } else if (flags.parallel_delimiter_override && info.SIBLING) {
                                    state.output.queue.slice(-1)[0].parallel_delimiter = flags.parallel_delimiter_override;
                                }
                            }
                        }
                    } else {
                        state.tmp.term_predecessor = flags.old_term_predecessor;
                        state.tmp.group_context.tip.variable_attempt = flags.variable_attempt;
                        if (flags.force_suppress && !state.tmp.group_context.tip.condition) {
                            state.tmp.group_context.tip.variable_attempt = true;
                            state.tmp.group_context.tip.variable_success = flags.variable_success_parent;
                        }
                        if (flags.force_suppress) {
                            for (var i = 0, ilen = flags.done_vars.length; i < ilen; i++) {
                                var doneVar = flags.done_vars[i];
                                for (var j = 0, jlen = state.tmp.done_vars.length; j < jlen; j++) {
                                    if (state.tmp.done_vars[j] === doneVar) {
                                        state.tmp.done_vars = state.tmp.done_vars.slice(0, j).concat(state.tmp.done_vars.slice(j + 1));
                                    }
                                }
                            }
                        }
                        if (state.output.current.value().blobs) {
                            state.output.current.value().blobs.pop();
                        }
                    }
                }
            };
            this.execs.push(func);
            if (this.juris) {
                var else_end = new CSL.Token("else", CSL.END);
                CSL.Node["else"].build.call(else_end, state, target);
                var choose_end = new CSL.Token("choose", CSL.END);
                CSL.Node.choose.build.call(choose_end, state, target);
            }
        }
        if (this.tokentype === CSL.END) {
            if (!this.juris) {
                target.push(this);
            }
            if (state.build.substitute_level.value()) {
                state.build.substitute_level.replace(state.build.substitute_level.value() - 1);
            }
            CSL.Util.substituteEnd.call(this, state, target);
        }
    }
};

CSL.Node["if"] = {
    build: function build(state, target) {
        CSL.Conditions.TopNode.call(this, state, target);
        target.push(this);
    },
    configure: function configure(state, pos) {
        CSL.Conditions.Configure.call(this, state, pos);
    }
};

CSL.Node["conditions"] = {
    build: function build(state) {
        if (this.tokentype === CSL.START) {
            state.tmp.conditions.addMatch(this.match);
        }
        if (this.tokentype === CSL.END) {
            state.tmp.conditions.matchCombine();
        }
    }
};

CSL.Node["condition"] = {
    build: function build(state) {
        if (this.tokentype === CSL.SINGLETON) {
            var test = state.fun.match[this.match](this, state, this.tests);
            state.tmp.conditions.addTest(test);
        }
    }
};

CSL.Conditions = {};

CSL.Conditions.TopNode = function(state) {
    var func;
    if (this.tokentype === CSL.START || this.tokentype === CSL.SINGLETON) {
        if (this.locale) {
            state.opt.lang = this.locale;
        }
        if (!this.tests || !this.tests.length) {
            state.tmp.conditions = new CSL.Conditions.Engine(state, this);
        } else {
            this.test = state.fun.match[this.match](this, state, this.tests);
        }
        if (state.build.substitute_level.value() === 0) {
            func = function func(state) {
                state.tmp.condition_counter++;
            };
            this.execs.push(func);
        }
    }
    if (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON) {
        if (state.build.substitute_level.value() === 0) {
            func = function func(state) {
                state.tmp.condition_counter--;
                if (state.tmp.condition_lang_counter_arr.length > 0) {
                    var counter = state.tmp.condition_lang_counter_arr.slice(-1)[0];
                    if (counter === state.tmp.condition_counter) {
                        state.opt.lang = state.tmp.condition_lang_val_arr.pop();
                        state.tmp.condition_lang_counter_arr.pop();
                    }
                }
                if (this.locale_default) {
                    state.output.current.value().old_locale = this.locale_default;
                    state.output.closeLevel("empty");
                    state.opt.lang = this.locale_default;
                }
            };
            this.execs.push(func);
        }
        func = function func(state) {
            var next = this[state.tmp.jump.value()];
            return next;
        };
        this.execs.push(func);
        if (this.locale_default) {
            state.opt.lang = this.locale_default;
        }
    }
};

CSL.Conditions.Configure = function(state, pos) {
    if (this.tokentype === CSL.START) {
        this.fail = state.configure.fail.slice(-1)[0];
        this.succeed = this.next;
        state.configure.fail[state.configure.fail.length - 1] = pos;
    } else if (this.tokentype === CSL.SINGLETON) {
        this.fail = this.next;
        this.succeed = state.configure.succeed.slice(-1)[0];
        state.configure.fail[state.configure.fail.length - 1] = pos;
    } else {
        this.succeed = state.configure.succeed.slice(-1)[0];
        this.fail = this.next;
    }
};

CSL.Conditions.Engine = function(state, token) {
    this.token = token;
    this.state = state;
};

CSL.Conditions.Engine.prototype.addTest = function(test) {
    this.token.tests ? {} : this.token.tests = [];
    this.token.tests.push(test);
};

CSL.Conditions.Engine.prototype.addMatch = function(match) {
    this.token.match = match;
};

CSL.Conditions.Engine.prototype.matchCombine = function() {
    this.token.test = this.state.fun.match[this.token.match](this.token, this.state, this.token.tests);
};

CSL.Node.info = {
    build: function build(state) {
        if (this.tokentype === CSL.START) {
            state.build.skip = "info";
        } else {
            state.build.skip = false;
        }
    }
};

CSL.Node.institution = {
    build: function build(state, target) {
        if ([ CSL.SINGLETON, CSL.START ].indexOf(this.tokentype) > -1) {
            var func = function func(state) {
                if ("string" === typeof this.strings.delimiter) {
                    state.tmp.institution_delimiter = this.strings.delimiter;
                } else {
                    state.tmp.institution_delimiter = state.tmp.name_delimiter;
                }
                if ("text" === state.inheritOpt(this, "and")) {
                    this.and_term = state.getTerm("and", "long", 0);
                } else if ("symbol" === state.inheritOpt(this, "and")) {
                    if (state.opt.development_extensions.expect_and_symbol_form) {
                        this.and_term = state.getTerm("and", "symbol", 0);
                    } else {
                        this.and_term = "&";
                    }
                } else if ("none" === state.inheritOpt(this, "and")) {
                    this.and_term = state.tmp.institution_delimiter;
                }
                if ("undefined" === typeof this.and_term && state.tmp.and_term) {
                    this.and_term = state.tmp.and_term;
                }
                if (CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)) {
                    this.and_prefix_single = " ";
                    this.and_prefix_multiple = ", ";
                    if ("string" === typeof state.tmp.institution_delimiter) {
                        this.and_prefix_multiple = state.tmp.institution_delimiter;
                    }
                    this.and_suffix = " ";
                } else {
                    this.and_prefix_single = "";
                    this.and_prefix_multiple = "";
                    this.and_suffix = "";
                }
                if (state.inheritOpt(this, "delimiter-precedes-last") === "always") {
                    this.and_prefix_single = state.tmp.institution_delimiter;
                } else if (state.inheritOpt(this, "delimiter-precedes-last") === "never") {
                    if (this.and_prefix_multiple) {
                        this.and_prefix_multiple = " ";
                    }
                }
                this.and = {};
                if ("undefined" !== typeof this.and_term) {
                    state.output.append(this.and_term, "empty", true);
                    this.and.single = state.output.pop();
                    this.and.single.strings.prefix = this.and_prefix_single;
                    this.and.single.strings.suffix = this.and_suffix;
                    state.output.append(this.and_term, "empty", true);
                    this.and.multiple = state.output.pop();
                    this.and.multiple.strings.prefix = this.and_prefix_multiple;
                    this.and.multiple.strings.suffix = this.and_suffix;
                } else if ("undefined" !== this.strings.delimiter) {
                    this.and.single = new CSL.Blob(state.tmp.institution_delimiter);
                    this.and.single.strings.prefix = "";
                    this.and.single.strings.suffix = "";
                    this.and.multiple = new CSL.Blob(state.tmp.institution_delimiter);
                    this.and.multiple.strings.prefix = "";
                    this.and.multiple.strings.suffix = "";
                }
                state.nameOutput.institution = this;
            };
            this.execs.push(func);
        }
        target.push(this);
    },
    configure: function configure(state) {
        if ([ CSL.SINGLETON, CSL.START ].indexOf(this.tokentype) > -1) {
            state.build.has_institution = true;
        }
    }
};

CSL.Node["institution-part"] = {
    build: function build(state, target) {
        var func;
        if ("long" === this.strings.name) {
            if (this.strings["if-short"]) {
                func = function func(state) {
                    state.nameOutput.institutionpart["long-with-short"] = this;
                };
            } else {
                func = function func(state) {
                    state.nameOutput.institutionpart["long"] = this;
                };
            }
        } else if ("short" === this.strings.name) {
            func = function func(state) {
                state.nameOutput.institutionpart["short"] = this;
            };
        }
        this.execs.push(func);
        target.push(this);
    }
};

CSL.Node.key = {
    build: function build(state, target) {
        target = state[state.build.root + "_sort"].tokens;
        var func;
        var start_key = new CSL.Token("key", CSL.START);
        state.tmp.root = state.build.root;
        start_key.strings["et-al-min"] = state.inheritOpt(this, "et-al-min");
        start_key.strings["et-al-use-first"] = state.inheritOpt(this, "et-al-use-first");
        start_key.strings["et-al-use-last"] = state.inheritOpt(this, "et-al-use-last");
        func = function func(state) {
            state.tmp.done_vars = [];
        };
        start_key.execs.push(func);
        func = function func(state) {
            state.output.openLevel("empty");
        };
        start_key.execs.push(func);
        var sort_direction = [];
        if (this.strings.sort_direction === CSL.DESCENDING) {
            sort_direction.push(1);
            sort_direction.push(-1);
        } else {
            sort_direction.push(-1);
            sort_direction.push(1);
        }
        state[state.build.area].opt.sort_directions.push(sort_direction);
        if (CSL.DATE_VARIABLES.indexOf(this.variables[0]) > -1) {
            state.build.date_key = true;
        }
        func = function func(state) {
            state.tmp.sort_key_flag = true;
            if (state.inheritOpt(this, "et-al-min")) {
                state.tmp["et-al-min"] = state.inheritOpt(this, "et-al-min");
            }
            if (state.inheritOpt(this, "et-al-use-first")) {
                state.tmp["et-al-use-first"] = state.inheritOpt(this, "et-al-use-first");
            }
            if ("boolean" === typeof state.inheritOpt(this, "et-al-use-last")) {
                state.tmp["et-al-use-last"] = state.inheritOpt(this, "et-al-use-last");
            }
        };
        start_key.execs.push(func);
        target.push(start_key);
        if (this.variables.length) {
            var variable = this.variables[0];
            if (CSL.NAME_VARIABLES.indexOf(variable) > -1) {
                var names_start_token = new CSL.Token("names", CSL.START);
                names_start_token.tokentype = CSL.START;
                names_start_token.variables = this.variables;
                CSL.Node.names.build.call(names_start_token, state, target);
                var name_token = new CSL.Token("name", CSL.SINGLETON);
                name_token.tokentype = CSL.SINGLETON;
                name_token.strings["name-as-sort-order"] = "all";
                name_token.strings["sort-separator"] = " ";
                name_token.strings["et-al-use-last"] = state.inheritOpt(this, "et-al-use-last");
                name_token.strings["et-al-min"] = state.inheritOpt(this, "et-al-min");
                name_token.strings["et-al-use-first"] = state.inheritOpt(this, "et-al-use-first");
                CSL.Node.name.build.call(name_token, state, target);
                var institution_token = new CSL.Token("institution", CSL.SINGLETON);
                institution_token.tokentype = CSL.SINGLETON;
                CSL.Node.institution.build.call(institution_token, state, target);
                var names_end_token = new CSL.Token("names", CSL.END);
                names_end_token.tokentype = CSL.END;
                CSL.Node.names.build.call(names_end_token, state, target);
            } else {
                var single_text = new CSL.Token("text", CSL.SINGLETON);
                single_text.strings.sort_direction = this.strings.sort_direction;
                single_text.dateparts = this.dateparts;
                if (CSL.NUMERIC_VARIABLES.indexOf(variable) > -1) {
                    if (variable === "citation-number") {
                        func = function func(state, Item) {
                            if (state.tmp.area === "bibliography_sort") {
                                if (this.strings.sort_direction === CSL.DESCENDING) {
                                    state.bibliography_sort.opt.citation_number_sort_direction = CSL.DESCENDING;
                                } else {
                                    state.bibliography_sort.opt.citation_number_sort_direction = CSL.ASCENDING;
                                }
                            }
                            if (state.tmp.area === "citation_sort" && state.bibliography_sort.tmp.citation_number_map) {
                                var num = state.bibliography_sort.tmp.citation_number_map[state.registry.registry[Item.id].seq];
                            } else {
                                var num = state.registry.registry[Item.id].seq;
                            }
                            if (num) {
                                num = CSL.Util.padding("" + num);
                            }
                            state.output.append(num, this);
                        };
                    } else {
                        func = function func(state, Item) {
                            var num = false;
                            num = Item[variable];
                            if (num) {
                                num = CSL.Util.padding(num);
                            }
                            state.output.append(num, this);
                        };
                    }
                } else if (variable === "citation-label") {
                    func = function func(state, Item) {
                        var trigraph = state.getCitationLabel(Item);
                        state.output.append(trigraph, this);
                    };
                } else if (CSL.DATE_VARIABLES.indexOf(variable) > -1) {
                    func = CSL.dateAsSortKey;
                    single_text.variables = this.variables;
                } else if ("title" === variable) {
                    var abbrevfam = "title";
                    var abbrfall = false;
                    var altvar = false;
                    var transfall = true;
                    func = state.transform.getOutputFunction(this.variables, abbrevfam, abbrfall, altvar, transfall);
                } else if ("court-class" === variable) {
                    func = function func(state, Item, item) {
                        CSL.INIT_JURISDICTION_MACROS(state, Item, item, "juris-main");
                        var cls = CSL.GET_COURT_CLASS(state, Item, true);
                        state.output.append(cls, "empty");
                    };
                } else {
                    func = function func(state, Item) {
                        var varval = Item[variable];
                        state.output.append(varval, "empty");
                    };
                }
                single_text.execs.push(func);
                target.push(single_text);
            }
        } else {
            var token = new CSL.Token("text", CSL.SINGLETON);
            token.strings.sort_direction = this.strings.sort_direction;
            token.postponed_macro = this.postponed_macro;
            CSL.expandMacro.call(state, token, target);
        }
        var end_key = new CSL.Token("key", CSL.END);
        func = function func(state) {
            var keystring = state.output.string(state, state.output.queue);
            if (state.sys.normalizeUnicode) {
                keystring = state.sys.normalizeUnicode(keystring);
            }
            keystring = keystring ? keystring.split(" ").join(state.opt.sort_sep) + state.opt.sort_sep : "";
            if ("" === keystring) {
                keystring = undefined;
            }
            if ("string" !== typeof keystring) {
                keystring = undefined;
            }
            state[state[state.tmp.area].root + "_sort"].keys.push(keystring);
            state.tmp.value = [];
        };
        end_key.execs.push(func);
        if (state.build.date_key) {
            if (state.build.area === "citation" && state.build.extension === "_sort") {
                state[state.build.area].opt.sort_directions.push([ -1, 1 ]);
                func = function func(state, Item) {
                    var year_suffix = state.registry.registry[Item.id].disambig.year_suffix;
                    if (!year_suffix) {
                        year_suffix = 0;
                    }
                    var key = CSL.Util.padding("" + year_suffix);
                    state[state.tmp.area].keys.push(key);
                };
                end_key.execs.push(func);
            }
            state.build.date_key = false;
        }
        func = function func(state) {
            state.tmp["et-al-min"] = undefined;
            state.tmp["et-al-use-first"] = undefined;
            state.tmp["et-al-use-last"] = undefined;
            state.tmp.sort_key_flag = false;
        };
        end_key.execs.push(func);
        target.push(end_key);
    }
};

CSL.Node.label = {
    build: function build(state, target) {
        if (this.strings.term) {
            var func = function func(state, Item, item) {
                var termtxt = CSL.evaluateLabel(this, state, Item, item);
                if (item && this.strings.term === "locator") {
                    item.section_form_override = this.strings.form;
                }
                if (termtxt) {
                    state.tmp.group_context.tip.term_intended = true;
                }
                CSL.UPDATE_GROUP_CONTEXT_CONDITION(state, termtxt, null, this);
                if (termtxt.indexOf("%s") === -1) {
                    if (this.strings.capitalize_if_first) {
                        if (!state.tmp.term_predecessor && !(state.opt["class"] === "in-text" && state.tmp.area === "citation")) {
                            termtxt = CSL.Output.Formatters["capitalize-first"](state, termtxt);
                        }
                    }
                    state.output.append(termtxt, this);
                }
            };
            this.execs.push(func);
        } else {
            if (!this.strings.form) {
                this.strings.form = "long";
            }
            var namevars = state.build.names_variables[state.build.names_variables.length - 1];
            var namelabels = state.build.name_label[state.build.name_label.length - 1];
            for (var i = 0, ilen = namevars.length; i < ilen; i += 1) {
                if (!namelabels[namevars[i]]) {
                    namelabels[namevars[i]] = {};
                }
            }
            if (!state.build.name_flag) {
                for (var i = 0, ilen = namevars.length; i < ilen; i += 1) {
                    namelabels[namevars[i]].before = this;
                }
            } else {
                for (var i = 0, ilen = namevars.length; i < ilen; i += 1) {
                    namelabels[namevars[i]].after = this;
                }
            }
        }
        target.push(this);
    }
};

CSL.Node.layout = {
    build: function build(state, target) {
        var func, prefix_token, suffix_token, tok;
        function setSuffix() {
            if (state.build.area === "bibliography") {
                suffix_token = new CSL.Token("text", CSL.SINGLETON);
                func = function func(state) {
                    if (!state.tmp.parallel_and_not_last) {
                        var suffix;
                        if (state.tmp.cite_affixes[state.tmp.area][state.tmp.last_cite_locale]) {
                            suffix = state.tmp.cite_affixes[state.tmp.area][state.tmp.last_cite_locale].suffix;
                        } else {
                            suffix = state.bibliography.opt.layout_suffix;
                        }
                        var topblob = state.output.current.value();
                        if (state.opt.using_display) {
                            topblob.blobs[topblob.blobs.length - 1].strings.suffix = suffix;
                        } else {
                            topblob.strings.suffix = suffix;
                        }
                    }
                    if (state.bibliography.opt["second-field-align"]) {
                        state.output.endTag("bib_other");
                    }
                };
                suffix_token.execs.push(func);
                target.push(suffix_token);
            }
        }
        if (this.tokentype === CSL.START) {
            if (this.locale_raw) {
                state.build.current_default_locale = this.locale_raw;
            } else {
                state.build.current_default_locale = state.opt["default-locale"];
            }
            func = function func(state, Item, item) {
                if (state.opt.development_extensions.apply_citation_wrapper && state.sys.wrapCitationEntry && !state.tmp.just_looking && Item.system_id && state.tmp.area === "citation") {
                    var cite_entry = new CSL.Token("group", CSL.START);
                    cite_entry.decorations = [ [ "@cite", "entry" ] ];
                    state.output.startTag("cite_entry", cite_entry);
                    state.output.current.value().item_id = Item.system_id;
                    if (item) {
                        state.output.current.value().locator_txt = item.locator_txt;
                        state.output.current.value().suffix_txt = item.suffix_txt;
                    }
                }
            };
            this.execs.push(func);
        }
        if (this.tokentype === CSL.START && !state.tmp.cite_affixes[state.build.area]) {
            func = function func(state, Item, item) {
                state.tmp.done_vars = [];
                if (item && item["author-only"]) {
                    state.tmp.done_vars.push("locator");
                }
                if (state.opt.suppressedJurisdictions[Item["country"]] && Item["country"] && [ "treaty", "patent" ].indexOf(Item.type) === -1) {
                    state.tmp.done_vars.push("country");
                }
                if (!state.tmp.just_looking && state.registry.registry[Item.id] && state.registry.registry[Item.id].parallel) {
                    state.tmp.done_vars.push("first-reference-note-number");
                }
                if (!state.tmp.just_looking && state.tmp.abbrev_trimmer && Item.jurisdiction) {
                    for (var field in state.tmp.abbrev_trimmer.QUASHES[Item.jurisdiction]) {
                        state.tmp.done_vars.push(field);
                    }
                }
                state.tmp.rendered_name = false;
            };
            this.execs.push(func);
            func = function func(state) {
                state.tmp.sort_key_flag = false;
            };
            this.execs.push(func);
            func = function func(state) {
                state.tmp.nameset_counter = 0;
            };
            this.execs.push(func);
            func = function func(state, Item) {
                var tok = new CSL.Token;
                state.output.openLevel(tok);
            };
            this.execs.push(func);
            target.push(this);
            if (state.build.area === "citation") {
                prefix_token = new CSL.Token("text", CSL.SINGLETON);
                func = function func(state, Item, item) {
                    if (item && item.prefix) {
                        var prefix = CSL.checkPrefixSpaceAppend(state, item.prefix);
                        if (!state.tmp.just_looking) {
                            prefix = state.output.checkNestedBrace.update(prefix);
                        }
                        var ignorePredecessor = CSL.checkIgnorePredecessor(state, prefix);
                        state.output.append(prefix, this, false, ignorePredecessor);
                    }
                };
                prefix_token.execs.push(func);
                target.push(prefix_token);
            }
        }
        var my_tok;
        if (this.locale_raw) {
            my_tok = new CSL.Token("dummy", CSL.START);
            my_tok.locale = this.locale_raw;
            my_tok.strings.delimiter = this.strings.delimiter;
            my_tok.strings.suffix = this.strings.suffix;
            if (!state.tmp.cite_affixes[state.build.area]) {
                state.tmp.cite_affixes[state.build.area] = {};
            }
        }
        if (this.tokentype === CSL.START) {
            state.build.layout_flag = true;
            if (!this.locale_raw) {
                state[state.tmp.area].opt.topdecor = [ this.decorations ];
                state[state.tmp.area + "_sort"].opt.topdecor = [ this.decorations ];
                state[state.build.area].opt.layout_prefix = this.strings.prefix;
                state[state.build.area].opt.layout_suffix = this.strings.suffix;
                state[state.build.area].opt.layout_delimiter = this.strings.delimiter;
                state[state.build.area].opt.layout_decorations = this.decorations;
                if (state.tmp.cite_affixes[state.build.area]) {
                    tok = new CSL.Token("else", CSL.START);
                    CSL.Node["else"].build.call(tok, state, target);
                }
            }
            if (this.locale_raw) {
                if (!state.build.layout_locale_flag) {
                    var choose_tok = new CSL.Token("choose", CSL.START);
                    CSL.Node.choose.build.call(choose_tok, state, target);
                    my_tok.name = "if";
                    CSL.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
                    CSL.Node["if"].build.call(my_tok, state, target);
                } else {
                    my_tok.name = "else-if";
                    CSL.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
                    CSL.Node["else-if"].build.call(my_tok, state, target);
                }
                state.tmp.cite_affixes[state.build.area][my_tok.locale] = {};
                state.tmp.cite_affixes[state.build.area][my_tok.locale].delimiter = this.strings.delimiter;
                state.tmp.cite_affixes[state.build.area][my_tok.locale].suffix = this.strings.suffix;
            }
        }
        if (this.tokentype === CSL.END) {
            if (this.locale_raw) {
                setSuffix();
                if (!state.build.layout_locale_flag) {
                    my_tok.name = "if";
                    my_tok.tokentype = CSL.END;
                    CSL.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
                    CSL.Node["if"].build.call(my_tok, state, target);
                    state.build.layout_locale_flag = true;
                } else {
                    my_tok.name = "else-if";
                    my_tok.tokentype = CSL.END;
                    CSL.Attributes["@locale-internal"].call(my_tok, state, this.locale_raw);
                    CSL.Node["else-if"].build.call(my_tok, state, target);
                }
            }
            if (!this.locale_raw) {
                setSuffix();
                if (state.tmp.cite_affixes[state.build.area]) {
                    if (state.build.layout_locale_flag) {
                        tok = new CSL.Token("else", CSL.END);
                        CSL.Node["else"].build.call(tok, state, target);
                        tok = new CSL.Token("choose", CSL.END);
                        CSL.Node.choose.build.call(tok, state, target);
                    }
                }
                state.build_layout_locale_flag = true;
                if (state.build.area === "citation") {
                    suffix_token = new CSL.Token("text", CSL.SINGLETON);
                    func = function func(state, Item, item) {
                        if (item && item.suffix) {
                            var suffix = CSL.checkSuffixSpacePrepend(state, item.suffix);
                            if (!state.tmp.just_looking) {
                                suffix = state.output.checkNestedBrace.update(suffix);
                            }
                            state.output.append(suffix, this);
                        }
                    };
                    suffix_token.execs.push(func);
                    target.push(suffix_token);
                }
                func = function func(state) {
                    state.output.closeLevel();
                };
                this.execs.push(func);
                func = function func(state, Item) {
                    if (state.opt.development_extensions.apply_citation_wrapper && state.sys.wrapCitationEntry && !state.tmp.just_looking && Item.system_id && state.tmp.area === "citation") {
                        state.output.endTag();
                    }
                };
                this.execs.push(func);
                target.push(this);
                state.build.layout_flag = false;
                state.build.layout_locale_flag = false;
            }
        }
    }
};

CSL.Node.macro = {
    build: function build() {}
};

CSL.Node.alternative = {
    build: function build(state, target) {
        if (this.tokentype === CSL.START) {
            var choose_tok = new CSL.Token("choose", CSL.START);
            CSL.Node["choose"].build.call(choose_tok, state, target);
            var if_tok = new CSL.Token("if", CSL.START);
            CSL.Attributes["@alternative-node-internal"].call(if_tok, state);
            CSL.Node["if"].build.call(if_tok, state, target);
            var func = function func(state, Item) {
                state.tmp.oldItem = Item;
                state.tmp.oldLang = state.opt.lang;
                state.tmp.abort_alternative = true;
                if (Item["language-name"] && Item["language-name-original"]) {
                    var newItem = JSON.parse(JSON.stringify(Item));
                    newItem.language = newItem["language-name"];
                    var langspec = CSL.localeResolve(newItem.language, state.opt["default-locale"][0]);
                    if (state.opt.multi_layout) {
                        for (var i in state.opt.multi_layout) {
                            var locale_list = state.opt.multi_layout[i];
                            var gotlang = false;
                            for (var j in locale_list) {
                                var tryspec = locale_list[j];
                                if (langspec.best === tryspec.best || langspec.base === tryspec.base || langspec.bare === tryspec.bare) {
                                    gotlang = locale_list[0].best;
                                    break;
                                }
                            }
                            if (!gotlang) {
                                gotlang = state.opt["default-locale"][0];
                            }
                            state.opt.lang = gotlang;
                        }
                    }
                    for (var key in newItem) {
                        if ([ "id", "type", "language", "multi" ].indexOf(key) === -1 && key.slice(0, 4) !== "alt-") {
                            if (newItem.multi && newItem.multi._keys[key]) {
                                var deleteme = true;
                                for (var lang in newItem.multi._keys[key]) {
                                    if (langspec.bare === lang.replace(/^([a-zA-Z]+).*/, "$1")) {
                                        deleteme = false;
                                        break;
                                    }
                                }
                                if (deleteme) {
                                    delete newItem[key];
                                }
                            } else {
                                delete newItem[key];
                            }
                        }
                    }
                    for (var key in newItem) {
                        if (key.slice(0, 4) === "alt-") {
                            newItem[key.slice(4)] = newItem[key];
                            state.tmp.abort_alternative = false;
                        } else {
                            if (newItem.multi && newItem.multi._keys) {
                                if (!newItem["alt-" + key] && newItem.multi._keys[key]) {
                                    if (newItem.multi._keys[key][langspec.best]) {
                                        newItem[key] = newItem.multi._keys[key][langspec.best];
                                        state.tmp.abort_alternative = false;
                                    } else if (newItem.multi._keys[key][langspec.base]) {
                                        newItem[key] = newItem.multi._keys[key][langspec.base];
                                        state.tmp.abort_alternative = false;
                                    } else if (newItem.multi._keys[key][langspec.bare]) {
                                        newItem[key] = newItem.multi._keys[key][langspec.bare];
                                        state.tmp.abort_alternative = false;
                                    }
                                }
                            }
                        }
                    }
                }
                state.output.openLevel(this);
                state.registry.refhash[Item.id] = newItem;
                state.nameOutput = new CSL.NameOutput(state, newItem);
            };
            this.execs.push(func);
            target.push(this);
            var choose_tok = new CSL.Token("choose", CSL.START);
            CSL.Node["choose"].build.call(choose_tok, state, target);
            var if_tok = new CSL.Token("if", CSL.START);
            CSL.Attributes["@alternative-node-internal"].call(if_tok, state);
            var func = function func(state) {
                state.tmp.abort_alternative = true;
            };
            if_tok.execs.push(func);
            CSL.Node["if"].build.call(if_tok, state, target);
        } else if (this.tokentype === CSL.END) {
            var if_tok = new CSL.Token("if", CSL.END);
            CSL.Node["if"].build.call(if_tok, state, target);
            var choose_tok = new CSL.Token("choose", CSL.END);
            CSL.Node["choose"].build.call(choose_tok, state, target);
            var func = function func(state, Item) {
                state.output.closeLevel();
                state.registry.refhash[Item.id] = state.tmp.oldItem;
                state.opt.lang = state.tmp.oldLang;
                state.nameOutput = new CSL.NameOutput(state, state.tmp.oldItem);
                state.tmp.abort_alternative = false;
            };
            this.execs.push(func);
            target.push(this);
            var if_tok = new CSL.Token("if", CSL.END);
            CSL.Node["if"].build.call(if_tok, state, target);
            var choose_tok = new CSL.Token("choose", CSL.END);
            CSL.Node["choose"].build.call(choose_tok, state, target);
        }
    }
};

CSL.Node["alternative-text"] = {
    build: function build(state, target) {
        if (this.tokentype === CSL.SINGLETON) {
            var func = function func(state, Item) {
                var Item = state.refetchItem(Item.id);
                CSL.getCite.call(state, Item);
            };
            this.execs.push(func);
        }
        target.push(this);
    }
};

CSL.NameOutput = function(state, Item, item) {
    this.debug = false;
    this.state = state;
    if (this.debug) {
        this.state.sys.print("(1)");
    }
    this.Item = Item;
    this.item = item;
    this.nameset_base = 0;
    this.etal_spec = {};
    this._first_creator_variable = false;
    this._please_chop = false;
};

CSL.NameOutput.prototype.init = function(names) {
    this.requireMatch = names.requireMatch;
    if (this.state.tmp.term_predecessor) {
        this.state.tmp.subsequent_author_substitute_ok = false;
    }
    if (this.nameset_offset) {
        this.nameset_base = this.nameset_base + this.nameset_offset;
    }
    this.nameset_offset = 0;
    this.names = names;
    this.variables = names.variables;
    this.state.tmp.value = [];
    this.state.tmp.rendered_name = [];
    this.state.tmp.label_blob = false;
    this.state.tmp.etal_node = false;
    this.state.tmp.etal_term = false;
    for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        if (this.Item[this.variables[i]] && this.Item[this.variables[i]].length) {
            this.state.tmp.value = this.state.tmp.value.concat(this.Item[this.variables[i]]);
        }
    }
    this["et-al"] = undefined;
    this["with"] = undefined;
    this.name = undefined;
    this.institutionpart = {};
    this.state.tmp.group_context.tip.variable_attempt = true;
    this.labelVariable = this.variables[0];
    if (!this.state.tmp.value.length) {
        return;
    }
    var checkCommonTerm = this.checkCommonAuthor(this.requireMatch);
    if (checkCommonTerm) {
        this.state.tmp.can_substitute.pop();
        this.state.tmp.can_substitute.push(true);
        for (var i in this.variables) {
            var idx = this.state.tmp.done_vars.indexOf(this.variables[i]);
            if (idx > -1) {
                this.state.tmp.done_vars = this.state.tmp.done_vars.slice(0, idx).concat(this.state.tmp.done_vars.slice(i + 1));
            }
        }
        this.state.tmp.common_term_match_fail = true;
        this.variables = [];
    }
};

CSL.NameOutput.prototype.reinit = function(names, labelVariable) {
    this.requireMatch = names.requireMatch;
    this.labelVariable = labelVariable;
    if (this.state.tmp.can_substitute.value()) {
        this.nameset_offset = 0;
        this.variables = names.variables;
        var oldval = this.state.tmp.value.slice();
        this.state.tmp.value = [];
        for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
            if (this.Item[this.variables[i]] && this.Item[this.variables[i]].length) {
                this.state.tmp.value = this.state.tmp.value.concat(this.Item[this.variables[i]]);
            }
        }
        if (this.state.tmp.value.length) {
            this.state.tmp.can_substitute.replace(false, CSL.LITERAL);
        }
        this.state.tmp.value = oldval;
    }
    var checkCommonTerm = this.checkCommonAuthor(this.requireMatch);
    if (checkCommonTerm) {
        this.state.tmp.can_substitute.pop();
        this.state.tmp.can_substitute.push(true);
        for (var i in this.variables) {
            var idx = this.state.tmp.done_vars.indexOf(this.variables[i]);
            if (idx > -1) {
                this.state.tmp.done_vars = this.state.tmp.done_vars.slice(0, idx).concat(this.state.tmp.done_vars.slice(i + 1));
            }
        }
        this.variables = [];
    }
};

CSL.NameOutput.prototype.outputNames = function() {
    var i, ilen;
    var variables = this.variables;
    if (this.institution.and) {
        if (!this.institution.and.single.blobs || !this.institution.and.single.blobs.length) {
            this.institution.and.single.blobs = this.name.and.single.blobs;
        }
        if (!this.institution.and.multiple.blobs || !this.institution.and.multiple.blobs.length) {
            this.institution.and.multiple.blobs = this.name.and.multiple.blobs;
        }
    }
    this.variable_offset = {};
    if (this.family) {
        this.family_decor = CSL.Util.cloneToken(this.family);
        this.family_decor.strings.prefix = "";
        this.family_decor.strings.suffix = "";
        for (i = 0, ilen = this.family.execs.length; i < ilen; i += 1) {
            this.family.execs[i].call(this.family_decor, this.state, this.Item);
        }
    } else {
        this.family_decor = false;
    }
    if (this.given) {
        this.given_decor = CSL.Util.cloneToken(this.given);
        this.given_decor.strings.prefix = "";
        this.given_decor.strings.suffix = "";
        for (i = 0, ilen = this.given.execs.length; i < ilen; i += 1) {
            this.given.execs[i].call(this.given_decor, this.state, this.Item);
        }
    } else {
        this.given_decor = false;
    }
    if (this.debug) {
        this.state.sys.print("(2)");
    }
    this.getEtAlConfig();
    if (this.debug) {
        this.state.sys.print("(3)");
    }
    this.divideAndTransliterateNames();
    if (this.debug) {
        this.state.sys.print("(4)");
    }
    this.truncatePersonalNameLists();
    if (this.debug) {
        this.state.sys.print("(5)");
    }
    if (this.debug) {
        this.state.sys.print("(6)");
    }
    this.disambigNames();
    this.constrainNames();
    if (this.debug) {
        this.state.sys.print("(7)");
    }
    if (this.name.strings.form === "count") {
        if (this.state.tmp.extension || this.names_count != 0) {
            this.state.output.append(this.names_count, "empty");
            this.state.tmp.group_context.tip.variable_success = true;
        }
        return;
    }
    if (this.debug) {
        this.state.sys.print("(8)");
    }
    this.setEtAlParameters();
    if (this.debug) {
        this.state.sys.print("(9)");
    }
    this.setCommonTerm(this.requireMatch);
    if (this.debug) {
        this.state.sys.print("(10)");
    }
    this.renderAllNames();
    if (this.debug) {
        this.state.sys.print("(11)");
    }
    var blob_list = [];
    for (i = 0, ilen = variables.length; i < ilen; i += 1) {
        var v = variables[i];
        var institution_sets = [];
        var institutions = false;
        var varblob = null;
        if (!this.state.opt.development_extensions.spoof_institutional_affiliations) {
            varblob = this._join([ this.freeters[v] ], "");
        } else {
            if (this.debug) {
                this.state.sys.print("(11a)");
            }
            for (var j = 0, jlen = this.institutions[v].length; j < jlen; j += 1) {
                institution_sets.push(this.joinPersonsAndInstitutions([ this.persons[v][j], this.institutions[v][j] ]));
            }
            if (this.debug) {
                this.state.sys.print("(11b)");
            }
            if (this.institutions[v].length) {
                var pos = this.nameset_base + this.variable_offset[v];
                if (this.freeters[v].length) {
                    pos += 1;
                }
                institutions = this.joinInstitutionSets(institution_sets, pos);
            }
            if (this.debug) {
                this.state.sys.print("(11c)");
            }
            var varblob = this.joinFreetersAndInstitutionSets([ this.freeters[v], institutions ]);
            if (this.debug) {
                this.state.sys.print("(11d)");
            }
        }
        if (varblob) {
            if (!this.state.tmp.extension) {
                varblob = this._applyLabels(varblob, v);
            }
            blob_list.push(varblob);
        }
        if (this.debug) {
            this.state.sys.print("(11e)");
        }
        if (this.common_term) {
            break;
        }
    }
    if (this.debug) {
        this.state.sys.print("(12)");
    }
    this.state.output.openLevel("empty");
    this.state.output.current.value().strings.delimiter = this.state.inheritOpt(this.names, "delimiter", "names-delimiter");
    if (this.debug) {
        this.state.sys.print("(13)");
    }
    for (i = 0, ilen = blob_list.length; i < ilen; i += 1) {
        this.state.output.append(blob_list[i], "literal", true);
    }
    if (!this.state.tmp.just_looking && blob_list.length > 0) {
        this.state.tmp.probably_rendered_something = true;
    }
    if (this.debug) {
        this.state.sys.print("(14)");
    }
    this.state.output.closeLevel("empty");
    if (this.debug) {
        this.state.sys.print("(15)");
    }
    var blob = this.state.output.pop();
    this.state.tmp.name_node.top = blob;
    if (this.debug) {
        this.state.sys.print("(16)");
    }
    var namesToken = CSL.Util.cloneToken(this.names);
    if (this.state.tmp.group_context.tip.condition) {
        CSL.UPDATE_GROUP_CONTEXT_CONDITION(this.state, this.names.strings.prefix, null, this.names);
    }
    this.state.output.append(blob, namesToken);
    if (this.state.tmp.term_predecessor_name) {
        this.state.tmp.term_predecessor = true;
    }
    if (this.debug) {
        this.state.sys.print("(17)");
    }
    if (this.debug) {
        this.state.sys.print("(18)");
    }
    if (variables[0] !== "authority") {
        var name_node_string = [];
        var nameobjs = this.Item[variables[0]];
        if (nameobjs) {
            for (var i = 0, ilen = nameobjs.length; i < ilen; i += 1) {
                var substring = CSL.Util.Names.getRawName(nameobjs[i]);
                if (substring) {
                    name_node_string.push(substring);
                }
            }
        }
        name_node_string = name_node_string.join(", ");
        if (name_node_string) {
            this.state.tmp.name_node.string = name_node_string;
        }
    }
    if (this.state.tmp.name_node.string && !this.state.tmp.first_name_string) {
        this.state.tmp.first_name_string = this.state.tmp.name_node.string;
    }
    if ("classic" === this.Item.type) {
        if (this.state.tmp.first_name_string) {
            var author_title = [];
            author_title.push(this.state.tmp.first_name_string);
            if (this.Item.title) {
                author_title.push(this.Item.title);
            }
            author_title = author_title.join(", ");
            if (author_title && this.state.sys.getAbbreviation) {
                if (this.state.sys.normalizeAbbrevsKey) {
                    author_title = this.state.sys.normalizeAbbrevsKey("classic", author_title);
                }
                this.state.transform.loadAbbreviation("default", "classic", author_title, this.Item.language);
                if (this.state.transform.abbrevs["default"].classic[author_title]) {
                    this.state.tmp.done_vars.push("title");
                    this.state.output.append(this.state.transform.abbrevs["default"].classic[author_title], "empty", true);
                    blob = this.state.output.pop();
                    this.state.tmp.name_node.top.blobs.pop();
                    this.state.tmp.name_node.top.blobs.push(blob);
                }
            }
        }
    }
    this._collapseAuthor();
    this.variables = [];
    this.state.tmp.authority_stop_last = 0;
    if (this.debug) {
        this.state.sys.print("(19)");
    }
};

CSL.NameOutput.prototype._applyLabels = function(blob, v) {
    var txt;
    if (!this.label || !this.label[this.labelVariable]) {
        return blob;
    }
    var plural = 0;
    var num = this.freeters_count[v] + this.institutions_count[v];
    if (num > 1) {
        plural = 1;
    } else {
        for (var i = 0, ilen = this.persons[v].length; i < ilen; i += 1) {
            num += this.persons_count[v][i];
        }
        if (num > 1) {
            plural = 1;
        }
    }
    if (this.label[this.labelVariable].before) {
        if ("number" === typeof this.label[this.labelVariable].before.strings.plural) {
            plural = this.label[this.labelVariable].before.strings.plural;
        }
        txt = this._buildLabel(v, plural, "before", this.labelVariable);
        this.state.output.openLevel("empty");
        this.state.output.append(txt, this.label[this.labelVariable].before, true);
        this.state.output.append(blob, "literal", true);
        this.state.output.closeLevel("empty");
        blob = this.state.output.pop();
    } else if (this.label[this.labelVariable].after) {
        if ("number" === typeof this.label[this.labelVariable].after.strings.plural) {
            plural = this.label[this.labelVariable].after.strings.plural;
        }
        txt = this._buildLabel(v, plural, "after", this.labelVariable);
        this.state.output.openLevel("empty");
        this.state.output.append(blob, "literal", true);
        this.state.output.append(txt, this.label[this.labelVariable].after, true);
        this.state.tmp.label_blob = this.state.output.pop();
        this.state.output.append(this.state.tmp.label_blob, "literal", true);
        this.state.output.closeLevel("empty");
        blob = this.state.output.pop();
    }
    return blob;
};

CSL.NameOutput.prototype._buildLabel = function(term, plural, position, v) {
    if (this.common_term) {
        term = this.common_term;
    }
    var ret = false;
    var node = this.label[v][position];
    if (node) {
        ret = CSL.castLabel(this.state, node, term, plural, CSL.TOLERANT);
    }
    return ret;
};

CSL.NameOutput.prototype._collapseAuthor = function() {
    var myqueue, mystr, oldchars;
    if (this.state.tmp.name_node.top.blobs.length === 0) {
        return;
    }
    if (this.nameset_base === 0 && this.Item[this.variables[0]] && !this._first_creator_variable) {
        this._first_creator_variable = this.variables[0];
    }
    if (this.state[this.state.tmp.area].opt.collapse && this.state[this.state.tmp.area].opt.collapse.length || this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter.length) {
        if (this.state.tmp.authorstring_request) {
            mystr = "";
            myqueue = this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs;
            oldchars = this.state.tmp.offset_characters;
            if (myqueue) {
                mystr = this.state.output.string(this.state, myqueue, false);
            }
            this.state.tmp.offset_characters = oldchars;
            this.state.registry.authorstrings[this.Item.id] = mystr;
        } else if (!this.state.tmp.just_looking && !this.state.tmp.suppress_decorations && (this.state[this.state.tmp.area].opt.collapse && this.state[this.state.tmp.area].opt.collapse.length || this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter)) {
            mystr = "";
            myqueue = this.state.tmp.name_node.top.blobs.slice(-1)[0].blobs;
            oldchars = this.state.tmp.offset_characters;
            if (myqueue) {
                mystr = this.state.output.string(this.state, myqueue, false);
            }
            if (mystr === this.state.tmp.last_primary_names_string) {
                if (this.item["suppress-author"] || this.state[this.state.tmp.area].opt.collapse && this.state[this.state.tmp.area].opt.collapse.length) {
                    this.state.tmp.name_node.top.blobs.pop();
                    this.state.tmp.name_node.children = [];
                    this.state.tmp.offset_characters = oldchars;
                }
                if (this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter) {
                    this.state.tmp.use_cite_group_delimiter = true;
                }
            } else {
                this.state.tmp.last_primary_names_string = mystr;
                if (this.variables.indexOf(this._first_creator_variable) > -1 && this.item && this.item["suppress-author"] && this.Item.type !== "legal_case") {
                    this.state.tmp.name_node.top.blobs.pop();
                    this.state.tmp.name_node.children = [];
                    this.state.tmp.offset_characters = oldchars;
                    this.state.tmp.term_predecessor = false;
                }
                this.state.tmp.have_collapsed = false;
                if (this.state[this.state.tmp.area].opt.cite_group_delimiter && this.state[this.state.tmp.area].opt.cite_group_delimiter) {
                    this.state.tmp.use_cite_group_delimiter = false;
                }
            }
        }
    }
};

CSL.NameOutput.prototype.isPerson = function(value) {
    if (value.literal || !value.given && value.family && value.isInstitution) {
        return false;
    } else {
        return true;
    }
};

CSL.NameOutput.prototype.truncatePersonalNameLists = function() {
    var v, i, ilen, j, jlen, chopvar;
    this.freeters_count = {};
    this.persons_count = {};
    this.institutions_count = {};
    for (v in this.freeters) {
        if (this.freeters.hasOwnProperty(v)) {
            this.freeters_count[v] = this.freeters[v].length;
            this.freeters[v] = this._truncateNameList(this.freeters, v);
        }
    }
    for (v in this.persons) {
        if (this.persons.hasOwnProperty(v)) {
            this.institutions_count[v] = this.institutions[v].length;
            this._truncateNameList(this.institutions, v);
            this.persons[v] = this.persons[v].slice(0, this.institutions[v].length);
            this.persons_count[v] = [];
            for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
                this.persons_count[v][j] = this.persons[v][j].length;
                this.persons[v][j] = this._truncateNameList(this.persons, v, j);
            }
        }
    }
    if (this.state.opt.development_extensions.etal_min_etal_usefirst_hack && this.etal_min === 1 && this.etal_use_first === 1 && !(this.state.tmp.extension || this.state.tmp.just_looking)) {
        chopvar = v;
    } else {
        chopvar = false;
    }
    if (chopvar || this._please_chop) {
        for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
            v = this.variables[i];
            if (this.freeters[v].length) {
                if (this._please_chop === v) {
                    this.freeters[v] = this.freeters[v].slice(1);
                    this.freeters_count[v] += -1;
                    this._please_chop = false;
                } else if (chopvar && !this._please_chop) {
                    this.freeters[v] = this.freeters[v].slice(0, 1);
                    this.freeters_count[v] = 1;
                    this.institutions[v] = [];
                    this.persons[v] = [];
                    this._please_chop = chopvar;
                }
            }
            for (var j = 0, jlen = this.persons[v].length; j < jlen; j++) {
                if (this.persons[v][j].length) {
                    if (this._please_chop === v) {
                        this.persons[v][j] = this.persons[v][j].slice(1);
                        this.persons_count[v][j] += -1;
                        this._please_chop = false;
                        break;
                    } else if (chopvar && !this._please_chop) {
                        this.freeters[v] = this.persons[v][j].slice(0, 1);
                        this.freeters_count[v] = 1;
                        this.institutions[v] = [];
                        this.persons[v] = [];
                        this._please_chop = chopvar;
                        break;
                    }
                }
            }
            if (this.institutions[v].length) {
                if (this._please_chop === v) {
                    this.institutions[v] = this.institutions[v].slice(1);
                    this.institutions_count[v] += -1;
                    this._please_chop = false;
                } else if (chopvar && !this._please_chop) {
                    this.institutions[v] = this.institutions[v].slice(0, 1);
                    this.institutions_count[v] = 1;
                    this._please_chop = chopvar;
                }
            }
        }
    }
    for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        if (this.institutions[v].length) {
            this.nameset_offset += 1;
        }
        for (var j = 0, jlen = this.persons[v].length; j < jlen; j++) {
            if (this.persons[v][j].length) {
                this.nameset_offset += 1;
            }
        }
    }
};

CSL.NameOutput.prototype._truncateNameList = function(container, variable, index) {
    var lst;
    if ("undefined" === typeof index) {
        lst = container[variable];
    } else {
        lst = container[variable][index];
    }
    if (this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names && lst.length > 50 && lst.length > this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names + 2) {
        var limit = this.state[this.state[this.state.tmp.area].root].opt.max_number_of_names;
        lst = lst.slice(0, limit + 1).concat(lst.slice(-1));
    }
    return lst;
};

CSL.NameOutput.prototype.divideAndTransliterateNames = function() {
    var i, ilen, j, jlen;
    var Item = this.Item;
    var variables = this.variables;
    this.varnames = variables.slice();
    this.freeters = {};
    this.persons = {};
    this.institutions = {};
    for (i = 0, ilen = variables.length; i < ilen; i += 1) {
        var v = variables[i];
        this.variable_offset[v] = this.nameset_offset;
        var values = this._normalizeVariableValue(Item, v);
        if (this.name.strings["suppress-min"] && values.length >= this.name.strings["suppress-min"]) {
            values = [];
        }
        if (this.name.strings["suppress-max"] && values.length <= this.name.strings["suppress-max"]) {
            values = [];
        }
        this._getFreeters(v, values);
        this._getPersonsAndInstitutions(v, values);
        if (this.state.opt.development_extensions.spoof_institutional_affiliations) {
            if (this.name.strings["suppress-min"] === 0) {
                this.freeters[v] = [];
                for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
                    this.persons[v][j] = [];
                }
            } else if (this.institution.strings["suppress-min"] === 0) {
                this.institutions[v] = [];
                this.freeters[v] = this.freeters[v].concat(this.persons[v]);
                for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
                    for (var k = 0, klen = this.persons[v][j].length; k < klen; k += 1) {
                        this.freeters[v].push(this.persons[v][j][k]);
                    }
                }
                this.persons[v] = [];
            }
        }
    }
};

CSL.NameOutput.prototype._normalizeVariableValue = function(Item, variable) {
    var names;
    if ("string" === typeof Item[variable] || "number" === typeof Item[variable]) {
        CSL.debug('name variable "' + variable + '" is string or number, not array. Attempting to fix.');
        names = [ {
            literal: Item[variable] + ""
        } ];
    } else if (!Item[variable]) {
        names = [];
    } else if ("number" !== typeof Item[variable].length) {
        CSL.debug('name variable "' + variable + '" is object, not array. Attempting to fix.');
        Item[variable] = [ Item[variable] ];
        names = Item[variable].slice();
    } else {
        names = Item[variable].slice();
    }
    return names;
};

CSL.NameOutput.prototype._getFreeters = function(v, values) {
    this.freeters[v] = [];
    if (this.state.opt.development_extensions.spoof_institutional_affiliations) {
        for (var i = values.length - 1; i > -1; i--) {
            if (this.isPerson(values[i])) {
                var value = this._checkNickname(values.pop());
                if (value) {
                    this.freeters[v].push(value);
                }
            } else {
                break;
            }
        }
    } else {
        for (var i = values.length - 1; i > -1; i--) {
            var value = values.pop();
            if (this.isPerson(value)) {
                var value = this._checkNickname(value);
            }
            this.freeters[v].push(value);
        }
    }
    this.freeters[v].reverse();
    if (this.freeters[v].length) {
        this.nameset_offset += 1;
    }
};

CSL.NameOutput.prototype._getPersonsAndInstitutions = function(v, values) {
    this.persons[v] = [];
    this.institutions[v] = [];
    if (!this.state.opt.development_extensions.spoof_institutional_affiliations) {
        return;
    }
    var persons = [];
    var has_affiliates = false;
    var first = true;
    for (var i = values.length - 1; i > -1; i += -1) {
        if (this.isPerson(values[i])) {
            var value = this._checkNickname(values[i]);
            if (value) {
                persons.push(value);
            }
        } else {
            has_affiliates = true;
            this.institutions[v].push(values[i]);
            if (!first) {
                persons.reverse();
                this.persons[v].push(persons);
                persons = [];
            }
            first = false;
        }
    }
    if (has_affiliates) {
        persons.reverse();
        this.persons[v].push(persons);
        this.persons[v].reverse();
        this.institutions[v].reverse();
    }
};

CSL.NameOutput.prototype._clearValues = function(values) {
    for (var i = values.length - 1; i > -1; i += -1) {
        values.pop();
    }
};

CSL.NameOutput.prototype._checkNickname = function(name) {
    if ([ "interview", "personal_communication" ].indexOf(this.Item.type) > -1) {
        var author = "";
        author = CSL.Util.Names.getRawName(name);
        if (author && this.state.sys.getAbbreviation && !(this.item && this.item["suppress-author"])) {
            var normalizedKey = author;
            if (this.state.sys.normalizeAbbrevsKey) {
                normalizedKey = this.state.sys.normalizeAbbrevsKey("author", author);
            }
            this.state.transform.loadAbbreviation("default", "nickname", normalizedKey, this.Item.language);
            var myLocalName = this.state.transform.abbrevs["default"].nickname[normalizedKey];
            if (myLocalName) {
                if (myLocalName === "!here>>>") {
                    name = false;
                } else {
                    name = {
                        family: myLocalName,
                        given: ""
                    };
                }
            }
        }
    }
    return name;
};

CSL.NameOutput.prototype._purgeEmptyBlobs = function(blobs) {
    for (var i = blobs.length - 1; i > -1; i += -1) {
        if (!blobs[i] || blobs[i].length === 0 || !blobs[i].blobs.length) {
            blobs = blobs.slice(0, i).concat(blobs.slice(i + 1));
        }
    }
    return blobs;
};

CSL.NameOutput.prototype.joinPersons = function(blobs, pos, j, tokenname) {
    var ret;
    blobs = this._purgeEmptyBlobs(blobs);
    if ("undefined" === typeof j) {
        if (this.etal_spec[pos].freeters === 1) {
            ret = this._joinEtAl(blobs);
        } else if (this.etal_spec[pos].freeters === 2) {
            ret = this._joinEllipsis(blobs);
        } else if (!this.state.tmp.sort_key_flag) {
            ret = this._joinAnd(blobs);
        } else {
            ret = this._join(blobs, this.state.inheritOpt(this.name, "delimiter", "name-delimiter", ", "));
        }
    } else {
        if (this.etal_spec[pos].persons[j] === 1) {
            ret = this._joinEtAl(blobs);
        } else if (this.etal_spec[pos].persons[j] === 2) {
            ret = this._joinEllipsis(blobs);
        } else if (!this.state.tmp.sort_key_flag) {
            ret = this._joinAnd(blobs);
        } else {
            ret = this._join(blobs, this.state.inheritOpt(this.name, "delimiter", "name-delimiter", ", "));
        }
    }
    return ret;
};

CSL.NameOutput.prototype.joinInstitutionSets = function(blobs, pos) {
    var ret;
    blobs = this._purgeEmptyBlobs(blobs);
    if (this.etal_spec[pos].institutions === 1) {
        ret = this._joinEtAl(blobs, "institution");
    } else if (this.etal_spec[pos].institutions === 2) {
        ret = this._joinEllipsis(blobs, "institution");
    } else {
        ret = this._joinAnd(blobs);
    }
    return ret;
};

CSL.NameOutput.prototype.joinPersonsAndInstitutions = function(blobs) {
    blobs = this._purgeEmptyBlobs(blobs);
    var ret = this._join(blobs, this.state.tmp.name_delimiter);
    ret.isInstitution = true;
    return ret;
};

CSL.NameOutput.prototype.joinFreetersAndInstitutionSets = function(blobs) {
    blobs = this._purgeEmptyBlobs(blobs);
    var ret = this._join(blobs, "[never here]", this["with"].single, this["with"].multiple);
    return ret;
};

CSL.NameOutput.prototype._getAfterInvertedName = function(blobs, delimiter, finalJoin) {
    if (finalJoin && blobs.length > 1) {
        if (this.state.inheritOpt(this.name, "delimiter-precedes-last") === "after-inverted-name") {
            var prevBlob = blobs[blobs.length - 2];
            if (prevBlob.blobs.length > 0 && prevBlob.blobs[0].isInverted) {
                finalJoin.strings.prefix = delimiter;
            }
        }
    }
    return finalJoin;
};

CSL.NameOutput.prototype._getAndJoin = function(blobs, delimiter) {
    var finalJoin = false;
    if (blobs.length > 1) {
        var singleOrMultiple = "single";
        if (blobs.length > 2) {
            singleOrMultiple = "multiple";
        }
        if (blobs[blobs.length - 1].isInstitution) {
            finalJoin = this.institution.and[singleOrMultiple];
        } else {
            finalJoin = this.name.and[singleOrMultiple];
        }
        finalJoin = JSON.parse(JSON.stringify(finalJoin));
        finalJoin = this._getAfterInvertedName(blobs, delimiter, finalJoin);
    }
    return finalJoin;
};

CSL.NameOutput.prototype._joinEtAl = function(blobs) {
    var delimiter = this.state.inheritOpt(this.name, "delimiter", "name-delimiter", ", ");
    var blob = this._join(blobs, delimiter);
    this.state.output.openLevel(this._getToken("name"));
    this.state.output.current.value().strings.delimiter = "";
    this.state.output.append(blob, "literal", true);
    if (blobs.length > 1) {
        this.state.output.append(this["et-al"].multiple, "literal", true);
    } else if (blobs.length === 1) {
        this.state.output.append(this["et-al"].single, "literal", true);
    }
    this.state.output.closeLevel();
    return this.state.output.pop();
};

CSL.NameOutput.prototype._joinEllipsis = function(blobs) {
    var delimiter = this.state.inheritOpt(this.name, "delimiter", "name-delimiter", ", ");
    var finalJoin = false;
    if (blobs.length > 1) {
        var singleOrMultiple = "single";
        if (blobs.length > 2) {
            singleOrMultiple = "multiple";
        }
        finalJoin = JSON.parse(JSON.stringify(this.name.ellipsis[singleOrMultiple]));
        finalJoin = this._getAfterInvertedName(blobs, delimiter, finalJoin);
    }
    return this._join(blobs, delimiter, finalJoin);
};

CSL.NameOutput.prototype._joinAnd = function(blobs) {
    var delimiter = this.state.inheritOpt(this.name, "delimiter", "name-delimiter", ", ");
    var finalJoin = this._getAndJoin(blobs, delimiter);
    return this._join(blobs, delimiter, finalJoin);
};

CSL.NameOutput.prototype._join = function(blobs, delimiter, finalJoin) {
    var i, ilen;
    if (!blobs) {
        return false;
    }
    blobs = this._purgeEmptyBlobs(blobs);
    if (!blobs.length) {
        return false;
    }
    if (blobs.length > 1) {
        if (blobs.length === 2) {
            if (!finalJoin) {
                blobs[0].strings.suffix += delimiter;
            } else {
                blobs = [ blobs[0], finalJoin, blobs[1] ];
            }
        } else {
            var offset;
            if (finalJoin) {
                offset = 1;
            } else {
                offset = 0;
            }
            var blob = blobs.pop();
            for (var i = 0, ilen = blobs.length - offset; i < ilen; i++) {
                blobs[i].strings.suffix += delimiter;
            }
            blobs.push(finalJoin);
            blobs.push(blob);
        }
    }
    this.state.output.openLevel();
    for (i = 0, ilen = blobs.length; i < ilen; i += 1) {
        this.state.output.append(blobs[i], false, true);
    }
    this.state.output.closeLevel();
    return this.state.output.pop();
};

CSL.NameOutput.prototype._getToken = function(tokenname) {
    var token = this[tokenname];
    if (tokenname === "institution") {
        var newtoken = new CSL.Token;
        return newtoken;
    }
    return token;
};

CSL.NameOutput.prototype.checkCommonAuthor = function(requireMatch) {
    if (!requireMatch) {
        return false;
    }
    var common_term = false;
    if (this.variables.length === 2) {
        var variables = this.variables;
        var varnames = variables.slice();
        varnames.sort();
        common_term = varnames.join("");
    }
    if (!common_term) {
        return false;
    }
    var has_term = false;
    if (this.state.locale[this.state.opt.lang].terms[common_term]) {
        has_term = true;
    }
    if (!has_term) {
        this.state.tmp.done_vars.push(this.variables[0]);
        this.state.tmp.done_vars.push(this.variables[1]);
        return false;
    }
    var firstSet = this.Item[this.variables[0]];
    var secondSet = this.Item[this.variables[1]];
    var perfectMatch = this._compareNamesets(firstSet, secondSet);
    if (perfectMatch === true) {
        this.state.tmp.done_vars.push(this.variables[0]);
        this.state.tmp.done_vars.push(this.variables[1]);
    }
    return !perfectMatch;
};

CSL.NameOutput.prototype.setCommonTerm = function() {
    var variables = this.variables;
    var varnames = variables.slice();
    varnames.sort();
    this.common_term = varnames.join("");
    if (!this.common_term) {
        return;
    }
    var has_term = false;
    if (this.label && this.label[this.variables[0]]) {
        if (this.label[this.variables[0]].before) {
            has_term = this.state.getTerm(this.common_term, this.label[this.variables[0]].before.strings.form, 0);
        } else if (this.label[this.variables[0]].after) {
            has_term = this.state.getTerm(this.common_term, this.label[this.variables[0]].after.strings.form, 0);
        }
    }
    if (!this.state.locale[this.state.opt.lang].terms[this.common_term] || !has_term || this.variables.length < 2) {
        this.common_term = false;
        return;
    }
    for (var i = 0, ilen = this.variables.length - 1; i < ilen; i += 1) {
        var v = this.variables[i];
        var vv = this.variables[i + 1];
        if (this.freeters[v].length || this.freeters[vv].length) {
            if (this.etal_spec[v].freeters !== this.etal_spec[vv].freeters || !this._compareNamesets(this.freeters[v], this.freeters[vv])) {
                this.common_term = false;
                return;
            }
        }
        if (this.persons[v].length !== this.persons[vv].length) {
            this.common_term = false;
            return;
        }
        for (var j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            if (this.etal_spec[v].persons[j] !== this.etal_spec[vv].persons[j] || !this._compareNamesets(this.persons[v][j], this.persons[vv][j])) {
                this.common_term = false;
                return;
            }
        }
    }
};

CSL.NameOutput.prototype._compareNamesets = function(base_nameset, nameset) {
    if (!base_nameset || !nameset || base_nameset.length !== nameset.length) {
        return false;
    }
    for (var i = 0, ilen = nameset.length; i < ilen; i += 1) {
        for (var j = 0, jlen = CSL.NAME_PARTS.length; j < jlen; j += 1) {
            var part = CSL.NAME_PARTS[j];
            if (!base_nameset[i] || base_nameset[i][part] != nameset[i][part]) {
                return false;
            }
        }
    }
    return true;
};

CSL.NameOutput.prototype.constrainNames = function() {
    this.names_count = 0;
    var pos;
    for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        pos = this.nameset_base + i;
        if (this.freeters[v].length) {
            this.state.tmp.names_max.push(this.freeters[v].length, "literal");
            this._imposeNameConstraints(this.freeters, this.freeters_count, v, pos);
            this.names_count += this.freeters[v].length;
        }
        if (this.institutions[v].length) {
            this.state.tmp.names_max.push(this.institutions[v].length, "literal");
            this._imposeNameConstraints(this.institutions, this.institutions_count, v, pos);
            this.persons[v] = this.persons[v].slice(0, this.institutions[v].length);
            this.names_count += this.institutions[v].length;
        }
        for (var j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            if (this.persons[v][j].length) {
                this.state.tmp.names_max.push(this.persons[v][j].length, "literal");
                this._imposeNameConstraints(this.persons[v], this.persons_count[v], j, pos);
                this.names_count += this.persons[v][j].length;
            }
        }
    }
};

CSL.NameOutput.prototype._imposeNameConstraints = function(lst, count, key, pos) {
    var display_names = lst[key];
    var discretionary_names_length = this.state.tmp["et-al-min"];
    if (this.state.tmp.suppress_decorations) {
        if (this.state.tmp.disambig_request && this.state.tmp.disambig_request.names[pos]) {
            discretionary_names_length = this.state.tmp.disambig_request.names[pos];
        } else if (count[key] >= this.etal_min) {
            discretionary_names_length = this.etal_use_first;
        }
    } else {
        if (this.state.tmp.disambig_request && this.state.tmp.disambig_request.names[pos] > this.etal_use_first) {
            if (count[key] < this.etal_min) {
                discretionary_names_length = count[key];
            } else {
                discretionary_names_length = this.state.tmp.disambig_request.names[pos];
            }
        } else if (count[key] >= this.etal_min) {
            discretionary_names_length = this.etal_use_first;
        }
        if (this.etal_use_last && discretionary_names_length > this.etal_min - 2) {
            discretionary_names_length = this.etal_min - 2;
        }
    }
    var sane = this.etal_min >= this.etal_use_first;
    var overlength = count[key] > discretionary_names_length;
    if (discretionary_names_length > count[key]) {
        discretionary_names_length = display_names.length;
    }
    if (sane && overlength) {
        if (this.etal_use_last) {
            lst[key] = display_names.slice(0, discretionary_names_length).concat(display_names.slice(-1));
        } else {
            lst[key] = display_names.slice(0, discretionary_names_length);
        }
    }
    this.state.tmp.disambig_settings.names[pos] = lst[key].length;
    this.state.disambiguate.padBase(this.state.tmp.disambig_settings);
};

CSL.NameOutput.prototype.disambigNames = function() {
    var pos;
    for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        pos = this.nameset_base + i;
        if (this.freeters[v].length) {
            this._runDisambigNames(this.freeters[v], pos);
        }
        if (this.institutions[v].length) {
            if ("undefined" === typeof this.state.tmp.disambig_settings.givens[pos]) {
                this.state.tmp.disambig_settings.givens[pos] = [];
            }
            for (var j = 0, jlen = this.institutions[v].length; j < jlen; j += 1) {
                if ("undefined" === typeof this.state.tmp.disambig_settings.givens[pos][j]) {
                    this.state.tmp.disambig_settings.givens[pos].push(2);
                }
            }
        }
        for (var j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            if (this.persons[v][j].length) {
                this._runDisambigNames(this.persons[v][j], pos);
            }
        }
    }
};

CSL.NameOutput.prototype._runDisambigNames = function(lst, pos) {
    var chk, myform, myinitials, param, i, ilen, paramx;
    for (i = 0, ilen = lst.length; i < ilen; i += 1) {
        if (!lst[i].given && !lst[i].family) {
            continue;
        }
        myinitials = this.state.inheritOpt(this.name, "initialize-with");
        this.state.registry.namereg.addname("" + this.Item.id, lst[i], i);
        chk = this.state.tmp.disambig_settings.givens[pos];
        if ("undefined" === typeof chk) {
            for (var j = 0, jlen = pos + 1; j < jlen; j += 1) {
                if (!this.state.tmp.disambig_settings.givens[j]) {
                    this.state.tmp.disambig_settings.givens[j] = [];
                }
            }
        }
        chk = this.state.tmp.disambig_settings.givens[pos][i];
        if ("undefined" === typeof chk) {
            myform = this.state.inheritOpt(this.name, "form", "name-form", "long");
            param = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, 0, myform, myinitials);
            this.state.tmp.disambig_settings.givens[pos].push(param);
        }
        myform = this.state.inheritOpt(this.name, "form", "name-form", "long");
        paramx = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, 0, myform, myinitials);
        if (this.state.tmp.disambig_request) {
            var val = this.state.tmp.disambig_settings.givens[pos][i];
            if (val === 1 && this.state.citation.opt["givenname-disambiguation-rule"] === "by-cite" && ("undefined" === typeof this.state.inheritOpt(this.name, "initialize-with") || "undefined" === typeof lst[i].given)) {
                val = 2;
            }
            param = val;
            if (this.state.opt["disambiguate-add-givenname"] && lst[i].given) {
                param = this.state.registry.namereg.evalname("" + this.Item.id, lst[i], i, param, this.state.inheritOpt(this.name, "form", "name-form", "long"), this.state.inheritOpt(this.name, "initialize-with"));
            }
        } else {
            param = paramx;
        }
        if (!this.state.tmp.just_looking && this.item && this.item.position === CSL.POSITION_FIRST) {
            if (paramx > param) {
                param = paramx;
            }
        }
        if (!this.state.tmp.sort_key_flag) {
            this.state.tmp.disambig_settings.givens[pos][i] = param;
            if ("string" === typeof myinitials && ("undefined" === typeof this.name.strings["initialize"] || true === this.name.strings["initialize"])) {
                this.state.tmp.disambig_settings.use_initials = true;
            }
        }
    }
};

CSL.NameOutput.prototype.getEtAlConfig = function() {
    var item = this.item;
    this["et-al"] = {};
    this.state.output.append(this.etal_term, this.etal_style, true);
    this["et-al"].single = this.state.output.pop();
    this["et-al"].single.strings.suffix = this.etal_suffix;
    this["et-al"].single.strings.prefix = this.etal_prefix_single;
    this.state.output.append(this.etal_term, this.etal_style, true);
    this["et-al"].multiple = this.state.output.pop();
    this["et-al"].multiple.strings.suffix = this.etal_suffix;
    this["et-al"].multiple.strings.prefix = this.etal_prefix_multiple;
    if ("undefined" === typeof item) {
        item = {};
    }
    if (item.position) {
        if (this.state.inheritOpt(this.name, "et-al-subsequent-min")) {
            this.etal_min = this.state.inheritOpt(this.name, "et-al-subsequent-min");
        } else {
            this.etal_min = this.state.inheritOpt(this.name, "et-al-min");
        }
        if (this.state.inheritOpt(this.name, "et-al-subsequent-use-first")) {
            this.etal_use_first = this.state.inheritOpt(this.name, "et-al-subsequent-use-first");
        } else {
            this.etal_use_first = this.state.inheritOpt(this.name, "et-al-use-first");
        }
    } else {
        if (this.state.tmp["et-al-min"]) {
            this.etal_min = this.state.tmp["et-al-min"];
        } else {
            this.etal_min = this.state.inheritOpt(this.name, "et-al-min");
        }
        if (this.state.tmp["et-al-use-first"]) {
            this.etal_use_first = this.state.tmp["et-al-use-first"];
        } else {
            this.etal_use_first = this.state.inheritOpt(this.name, "et-al-use-first");
        }
        if ("boolean" === typeof this.state.tmp["et-al-use-last"]) {
            this.etal_use_last = this.state.tmp["et-al-use-last"];
        } else {
            this.etal_use_last = this.state.inheritOpt(this.name, "et-al-use-last");
        }
    }
    if (!this.state.tmp["et-al-min"]) {
        this.state.tmp["et-al-min"] = this.etal_min;
    }
};

CSL.NameOutput.prototype.setEtAlParameters = function() {
    var i, ilen, j, jlen;
    for (i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        if ("undefined" === typeof this.etal_spec[v]) {
            this.etal_spec[v] = {
                freeters: 0,
                institutions: 0,
                persons: []
            };
        }
        this.etal_spec[this.nameset_base + i] = this.etal_spec[v];
        if (this.freeters[v].length) {
            this._setEtAlParameter("freeters", v);
        }
        for (j = 0, jlen = this.persons[v].length; j < jlen; j += 1) {
            if ("undefined" === typeof this.etal_spec[v][j]) {
                this.etal_spec[v].persons[j] = 0;
            }
            this._setEtAlParameter("persons", v, j);
        }
        if (this.institutions[v].length) {
            this._setEtAlParameter("institutions", v);
        }
    }
};

CSL.NameOutput.prototype._setEtAlParameter = function(type, v, j) {
    var lst, count;
    if (type === "persons") {
        lst = this.persons[v][j];
        count = this.persons_count[v][j];
    } else {
        lst = this[type][v];
        count = this[type + "_count"][v];
    }
    if (lst.length < count && !this.state.tmp.sort_key_flag) {
        if (this.etal_use_last) {
            if (type === "persons") {
                this.etal_spec[v].persons[j] = 2;
            } else {
                this.etal_spec[v][type] = 2;
            }
        } else {
            if (type === "persons") {
                this.etal_spec[v].persons[j] = 1;
            } else {
                this.etal_spec[v][type] = 1;
            }
        }
    } else {
        if (type === "persons") {
            this.etal_spec[v].persons[j] = 0;
        } else {
            this.etal_spec[v][type] = 0;
        }
    }
};

CSL.NameOutput.prototype.renderAllNames = function() {
    var pos;
    for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        if (this.freeters[v].length || this.institutions[v].length) {
            if (!this.state.tmp.group_context.tip.condition) {
                this.state.tmp.just_did_number = false;
            }
        }
        pos = this.nameset_base + i;
        if (this.freeters[v].length) {
            this.freeters[v] = this._renderNames(v, this.freeters[v], pos);
        }
        for (var j = 0, jlen = this.institutions[v].length; j < jlen; j += 1) {
            this.persons[v][j] = this._renderNames(v, this.persons[v][j], pos, j);
        }
    }
    this.renderInstitutionNames();
};

CSL.NameOutput.prototype.renderInstitutionNames = function() {
    for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
        var v = this.variables[i];
        for (var j = 0, jlen = this.institutions[v].length; j < jlen; j += 1) {
            var institution;
            var name = this.institutions[v][j];
            var j, jlen, localesets;
            if (this.state.tmp.extension) {
                localesets = [ "sort" ];
            } else if (name.isInstitution || name.literal) {
                localesets = this.state.opt["cite-lang-prefs"].institutions;
            } else {
                localesets = this.state.opt["cite-lang-prefs"].persons;
            }
            var slot = {
                primary: "locale-orig",
                secondary: false,
                tertiary: false
            };
            if (localesets) {
                var slotnames = [ "primary", "secondary", "tertiary" ];
                for (var k = 0, klen = slotnames.length; k < klen; k += 1) {
                    if (localesets.length - 1 < k) {
                        break;
                    }
                    if (localesets[k]) {
                        slot[slotnames[k]] = "locale-" + localesets[k];
                    }
                }
            } else {
                slot.primary = "locale-translat";
            }
            if (this.state.tmp.area !== "bibliography" && !(this.state.tmp.area === "citation" && this.state.opt.xclass === "note" && this.item && !this.item.position)) {
                slot.secondary = false;
                slot.tertiary = false;
            }
            this.setRenderedName(name);
            var institution = this._renderInstitutionName(v, name, slot, j);
            this.institutions[v][j] = institution;
        }
    }
};

CSL.NameOutput.prototype._renderInstitutionName = function(v, name, slot, j) {
    var secondary, tertiary, long_style, short_style, institution, institution_short, institution_long;
    var res = this.getName(name, slot.primary, true);
    var primary = res.name;
    var usedOrig = res.usedOrig;
    if (primary) {
        primary = this.fixupInstitution(primary, v, j);
    }
    secondary = false;
    if (slot.secondary) {
        res = this.getName(name, slot.secondary, false, usedOrig);
        var secondary = res.name;
        usedOrig = res.usedOrig;
        if (secondary) {
            secondary = this.fixupInstitution(secondary, v, j);
        }
    }
    tertiary = false;
    if (slot.tertiary) {
        res = this.getName(name, slot.tertiary, false, usedOrig);
        tertiary = res.name;
        if (tertiary) {
            tertiary = this.fixupInstitution(tertiary, v, j);
        }
    }
    var n = {
        l: {
            pri: false,
            sec: false,
            ter: false
        },
        s: {
            pri: false,
            sec: false,
            ter: false
        }
    };
    if (primary) {
        n.l.pri = primary["long"];
        n.s.pri = primary["short"].length ? primary["short"] : primary["long"];
    }
    if (secondary) {
        n.l.sec = secondary["long"];
        n.s.sec = secondary["short"].length ? secondary["short"] : secondary["long"];
    }
    if (tertiary) {
        n.l.ter = tertiary["long"];
        n.s.ter = tertiary["short"].length ? tertiary["short"] : tertiary["long"];
    }
    switch (this.institution.strings["institution-parts"]) {
      case "short":
        if (primary["short"].length) {
            short_style = this._getShortStyle();
            institution = [ this._composeOneInstitutionPart([ n.s.pri, n.s.sec, n.s.ter ], slot, short_style, v) ];
        } else {
            long_style = this._getLongStyle(primary, v, j);
            institution = [ this._composeOneInstitutionPart([ n.l.pri, n.l.sec, n.l.ter ], slot, long_style, v) ];
        }
        break;

      case "short-long":
        long_style = this._getLongStyle(primary, v, j);
        short_style = this._getShortStyle();
        institution_short = this._renderOneInstitutionPart(primary["short"], short_style);
        institution_long = this._composeOneInstitutionPart([ n.l.pri, n.l.sec, n.l.ter ], slot, long_style, v);
        institution = [ institution_short, institution_long ];
        break;

      case "long-short":
        long_style = this._getLongStyle(primary, v, j);
        short_style = this._getShortStyle();
        institution_short = this._renderOneInstitutionPart(primary["short"], short_style);
        institution_long = this._composeOneInstitutionPart([ n.l.pri, n.l.sec, n.l.ter ], slot, long_style, v);
        institution = [ institution_long, institution_short ];
        break;

      default:
        long_style = this._getLongStyle(primary, v, j);
        institution = [ this._composeOneInstitutionPart([ n.l.pri, n.l.sec, n.l.ter ], slot, long_style, v) ];
        break;
    }
    var blob = this._join(institution, " ");
    if (blob) {
        blob.isInstitution = true;
    }
    this.state.tmp.name_node.children.push(blob);
    return blob;
};

CSL.NameOutput.prototype._composeOneInstitutionPart = function(names, slot, style) {
    var primary = false, secondary = false, tertiary = false, primary_tok, secondary_tok, tertiary_tok;
    if (names[0]) {
        primary_tok = CSL.Util.cloneToken(style);
        if (this.state.opt.citeAffixes[slot.primary]) {
            if ("<i>" === this.state.opt.citeAffixes.institutions[slot.primary].prefix) {
                var hasItalic = false;
                for (var i = 0, ilen = primary_tok.decorations.length; i < ilen; i += 1) {
                    if (style.decorations[i][0] === "@font-style" && primary_tok.decorations[i][1] === "italic") {
                        hasItalic = true;
                    }
                }
                if (!hasItalic) {
                    primary_tok.decorations.push([ "@font-style", "italic" ]);
                }
            }
        }
        primary = this._renderOneInstitutionPart(names[0], primary_tok);
    }
    if (names[1]) {
        secondary = this._renderOneInstitutionPart(names[1], style);
    }
    if (names[2]) {
        tertiary = this._renderOneInstitutionPart(names[2], style);
    }
    var institutionblob;
    if (secondary || tertiary) {
        this.state.output.openLevel("empty");
        this.state.output.append(primary);
        secondary_tok = CSL.Util.cloneToken(style);
        if (slot.secondary) {
            secondary_tok.strings.prefix = this.state.opt.citeAffixes.institutions[slot.secondary].prefix;
            secondary_tok.strings.suffix = this.state.opt.citeAffixes.institutions[slot.secondary].suffix;
            if (!secondary_tok.strings.prefix) {
                secondary_tok.strings.prefix = " ";
            }
        }
        var secondary_outer = new CSL.Token;
        secondary_outer.decorations.push([ "@font-style", "normal" ]);
        secondary_outer.decorations.push([ "@font-weight", "normal" ]);
        this.state.output.openLevel(secondary_outer);
        this.state.output.append(secondary, secondary_tok);
        this.state.output.closeLevel();
        tertiary_tok = CSL.Util.cloneToken(style);
        if (slot.tertiary) {
            tertiary_tok.strings.prefix = this.state.opt.citeAffixes.institutions[slot.tertiary].prefix;
            tertiary_tok.strings.suffix = this.state.opt.citeAffixes.institutions[slot.tertiary].suffix;
            if (!tertiary_tok.strings.prefix) {
                tertiary_tok.strings.prefix = " ";
            }
        }
        var tertiary_outer = new CSL.Token;
        tertiary_outer.decorations.push([ "@font-style", "normal" ]);
        tertiary_outer.decorations.push([ "@font-weight", "normal" ]);
        this.state.output.openLevel(tertiary_outer);
        this.state.output.append(tertiary, tertiary_tok);
        this.state.output.closeLevel();
        this.state.output.closeLevel();
        institutionblob = this.state.output.pop();
    } else {
        institutionblob = primary;
    }
    return institutionblob;
};

CSL.NameOutput.prototype._renderOneInstitutionPart = function(blobs, style) {
    for (var i = 0, ilen = blobs.length; i < ilen; i += 1) {
        if (blobs[i]) {
            var str = blobs[i];
            if (this.state.tmp.strip_periods) {
                str = str.replace(/\./g, "");
            } else {
                for (var j = 0, jlen = style.decorations.length; j < jlen; j += 1) {
                    if ("@strip-periods" === style.decorations[j][0] && "true" === style.decorations[j][1]) {
                        str = str.replace(/\./g, "");
                        break;
                    }
                }
            }
            this.state.tmp.group_context.tip.variable_success = true;
            this.state.tmp.can_substitute.replace(false, CSL.LITERAL);
            if (str === "!here>>>") {
                blobs[i] = false;
            } else {
                this.state.output.append(str, style, true);
                blobs[i] = this.state.output.pop();
            }
        }
    }
    if ("undefined" === typeof this.institution.strings["part-separator"]) {
        this.institution.strings["part-separator"] = this.state.tmp.name_delimiter;
    }
    return this._join(blobs, this.institution.strings["part-separator"]);
};

CSL.NameOutput.prototype._renderNames = function(v, values, pos, j) {
    var ret = false;
    if (values.length) {
        var names = [];
        for (var i = 0, ilen = values.length; i < ilen; i += 1) {
            var name = values[i];
            var ret, localesets;
            if (this.state.tmp.extension) {
                localesets = [ "sort" ];
            } else if (name.isInstitution || name.literal) {
                localesets = this.state.opt["cite-lang-prefs"].institutions;
            } else {
                localesets = this.state.opt["cite-lang-prefs"].persons;
            }
            var slot = {
                primary: "locale-orig",
                secondary: false,
                tertiary: false
            };
            if (localesets) {
                var slotnames = [ "primary", "secondary", "tertiary" ];
                for (var k = 0, klen = slotnames.length; k < klen; k += 1) {
                    if (localesets.length - 1 < k) {
                        break;
                    }
                    slot[slotnames[k]] = "locale-" + localesets[k];
                }
            } else {
                slot.primary = "locale-translat";
            }
            if (this.state.tmp.sort_key_flag || this.state.tmp.area !== "bibliography" && !(this.state.tmp.area === "citation" && this.state.opt.xclass === "note" && this.item && !this.item.position)) {
                slot.secondary = false;
                slot.tertiary = false;
            }
            this.setRenderedName(name);
            if (!name.literal && !name.isInstitution) {
                var nameBlob = this._renderPersonalName(v, name, slot, pos, i, j);
                var nameToken = CSL.Util.cloneToken(this.name);
                this.state.output.append(nameBlob, nameToken, true);
                names.push(this.state.output.pop());
            } else {
                names.push(this._renderInstitutionName(v, name, slot, j));
            }
        }
        ret = this.joinPersons(names, pos, j);
    }
    return ret;
};

CSL.NameOutput.prototype._renderPersonalName = function(v, name, slot, pos, i, j) {
    var res = this.getName(name, slot.primary, true);
    var primary = this._renderOnePersonalName(res.name, pos, i, j);
    var secondary = false;
    if (slot.secondary) {
        res = this.getName(name, slot.secondary, false, res.usedOrig);
        if (res.name) {
            secondary = this._renderOnePersonalName(res.name, pos, i, j);
        }
    }
    var tertiary = false;
    if (slot.tertiary) {
        res = this.getName(name, slot.tertiary, false, res.usedOrig);
        if (res.name) {
            tertiary = this._renderOnePersonalName(res.name, pos, i, j);
        }
    }
    var personblob;
    if (secondary || tertiary) {
        this.state.output.openLevel("empty");
        this.state.output.append(primary);
        var secondary_tok = new CSL.Token;
        if (slot.secondary) {
            secondary_tok.strings.prefix = this.state.opt.citeAffixes.persons[slot.secondary].prefix;
            secondary_tok.strings.suffix = this.state.opt.citeAffixes.persons[slot.secondary].suffix;
            if (!secondary_tok.strings.prefix) {
                secondary_tok.strings.prefix = " ";
            }
        }
        this.state.output.append(secondary, secondary_tok);
        var tertiary_tok = new CSL.Token;
        if (slot.tertiary) {
            tertiary_tok.strings.prefix = this.state.opt.citeAffixes.persons[slot.tertiary].prefix;
            tertiary_tok.strings.suffix = this.state.opt.citeAffixes.persons[slot.tertiary].suffix;
            if (!tertiary_tok.strings.prefix) {
                tertiary_tok.strings.prefix = " ";
            }
        }
        this.state.output.append(tertiary, tertiary_tok);
        this.state.output.closeLevel();
        personblob = this.state.output.pop();
    } else {
        personblob = primary;
    }
    return personblob;
};

CSL.NameOutput.prototype._isRomanesque = function(name) {
    var ret = 2;
    if (!name.family.replace(/\"/g, "").match(CSL.ROMANESQUE_REGEXP)) {
        ret = 0;
    }
    if (!ret && name.given && name.given.match(CSL.STARTSWITH_ROMANESQUE_REGEXP)) {
        ret = 1;
    }
    var top_locale;
    if (ret == 2) {
        if (name.multi && name.multi.main) {
            top_locale = name.multi.main.slice(0, 2);
        } else if (this.Item.language) {
            top_locale = this.Item.language.slice(0, 2);
        }
        if ([ "ja", "zh" ].indexOf(top_locale) > -1) {
            ret = 1;
        }
    }
    return ret;
};

CSL.NameOutput.prototype._renderOnePersonalName = function(value, pos, i, j) {
    var name = value;
    var dropping_particle = this._droppingParticle(name, pos, j);
    var family = this._familyName(name);
    var non_dropping_particle = this._nonDroppingParticle(name);
    var givenInfo = this._givenName(name, pos, i);
    var given = givenInfo.blob;
    var suffix = this._nameSuffix(name);
    if (given === false) {
        dropping_particle = false;
        suffix = false;
    }
    var sort_sep = this.state.inheritOpt(this.name, "sort-separator");
    if (!sort_sep) {
        sort_sep = "";
    }
    var suffix_sep;
    if (name["comma-suffix"]) {
        suffix_sep = ", ";
    } else {
        suffix_sep = " ";
    }
    var romanesque = this._isRomanesque(name);
    function hasJoiningPunctuation(blob) {
        if (!blob) {
            return false;
        } else if ("string" === typeof blob.blobs) {
            if ([ "’", "'", "-", " " ].indexOf(blob.blobs.slice(-1)) > -1) {
                return true;
            } else {
                return false;
            }
        } else {
            return hasJoiningPunctuation(blob.blobs[blob.blobs.length - 1]);
        }
    }
    var has_hyphenated_non_dropping_particle = hasJoiningPunctuation(non_dropping_particle);
    var nbspace;
    if ([ "fr", "ru", "cs" ].indexOf(this.state.opt["default-locale"][0].slice(0, 2)) > -1) {
        nbspace = " ";
    } else {
        nbspace = " ";
    }
    var blob, merged, first, second;
    if (romanesque === 0) {
        blob = this._join([ non_dropping_particle, family, given ], "");
    } else if (romanesque === 1 || name["static-ordering"]) {
        merged = this._join([ non_dropping_particle, family ], nbspace);
        blob = this._join([ merged, given ], " ");
    } else if (name["reverse-ordering"]) {
        merged = this._join([ non_dropping_particle, family ], nbspace);
        blob = this._join([ given, merged ], " ");
    } else if (this.state.tmp.sort_key_flag) {
        if (this.state.opt["demote-non-dropping-particle"] === "never") {
            merged = this._join([ non_dropping_particle, family ], nbspace);
            merged = this._join([ merged, dropping_particle ], " ");
            merged = this._join([ merged, given ], this.state.opt.sort_sep);
            blob = this._join([ merged, suffix ], " ");
        } else {
            second = this._join([ given, dropping_particle, non_dropping_particle ], " ");
            merged = this._join([ family, second ], this.state.opt.sort_sep);
            blob = this._join([ merged, suffix ], " ");
        }
    } else if (this.state.inheritOpt(this.name, "name-as-sort-order") === "all" || this.state.inheritOpt(this.name, "name-as-sort-order") === "first" && i === 0 && (j === 0 || "undefined" === typeof j)) {
        if ([ "Lord", "Lady" ].indexOf(name.given) > -1) {
            sort_sep = ", ";
        }
        if ([ "always", "display-and-sort" ].indexOf(this.state.opt["demote-non-dropping-particle"]) > -1) {
            second = this._join([ given, dropping_particle ], name["comma-dropping-particle"] + " ");
            second = this._join([ second, non_dropping_particle ], " ");
            if (second && this.given) {
                second.strings.prefix = this.given.strings.prefix;
                second.strings.suffix = this.given.strings.suffix;
            }
            if (family && this.family) {
                family.strings.prefix = this.family.strings.prefix;
                family.strings.suffix = this.family.strings.suffix;
            }
            merged = this._join([ family, second ], sort_sep);
            blob = this._join([ merged, suffix ], sort_sep);
        } else {
            if (has_hyphenated_non_dropping_particle) {
                first = this._join([ non_dropping_particle, family ], "");
            } else {
                first = this._join([ non_dropping_particle, family ], nbspace);
            }
            if (first && this.family) {
                first.strings.prefix = this.family.strings.prefix;
                first.strings.suffix = this.family.strings.suffix;
            }
            second = this._join([ given, dropping_particle ], name["comma-dropping-particle"] + " ");
            if (second && this.given) {
                second.strings.prefix = this.given.strings.prefix;
                second.strings.suffix = this.given.strings.suffix;
            }
            merged = this._join([ first, second ], sort_sep);
            blob = this._join([ merged, suffix ], sort_sep);
        }
        blob.isInverted = true;
    } else {
        if (name["dropping-particle"] && name.family && !name["non-dropping-particle"]) {
            var dp = name["dropping-particle"];
            var apostrophes = [ "'", "ʼ", "’", "-" ];
            if (apostrophes.indexOf(dp.slice(-1)) > -1 && dp.slice(0, -1) !== "de") {
                family = this._join([ dropping_particle, family ], "");
                dropping_particle = false;
            }
        }
        if (has_hyphenated_non_dropping_particle) {
            second = this._join([ non_dropping_particle, family ], "");
            second = this._join([ dropping_particle, second ], nbspace);
        } else {
            second = this._join([ dropping_particle, non_dropping_particle, family ], nbspace);
        }
        second = this._join([ second, suffix ], suffix_sep);
        if (second && this.family) {
            second.strings.prefix = this.family.strings.prefix;
            second.strings.suffix = this.family.strings.suffix;
        }
        if (given && this.given) {
            given.strings.prefix = this.given.strings.prefix;
            given.strings.suffix = this.given.strings.suffix;
        }
        if (second.strings.prefix) {
            name["comma-dropping-particle"] = "";
        }
        var space;
        if (this.state.inheritOpt(this.name, "initialize-with") && this.state.inheritOpt(this.name, "initialize-with").match(/[\u00a0\ufeff]/) && givenInfo.initializationLevel === 1) {
            space = nbspace;
        } else {
            space = " ";
        }
        blob = this._join([ given, second ], name["comma-dropping-particle"] + space);
    }
    this.state.tmp.group_context.tip.variable_success = true;
    this.state.tmp.can_substitute.replace(false, CSL.LITERAL);
    this.state.tmp.term_predecessor = true;
    this.state.tmp.name_node.children.push(blob);
    return blob;
};

CSL.NameOutput.prototype._normalizeNameInput = function(value) {
    var name = {
        literal: value.literal,
        family: value.family,
        isInstitution: value.isInstitution,
        given: value.given,
        suffix: value.suffix,
        "comma-suffix": value["comma-suffix"],
        "non-dropping-particle": value["non-dropping-particle"],
        "dropping-particle": value["dropping-particle"],
        "static-ordering": value["static-ordering"],
        "static-particles": value["static-particles"],
        "reverse-ordering": value["reverse-ordering"],
        "full-form-always": value["full-form-always"],
        "parse-names": value["parse-names"],
        "comma-dropping-particle": "",
        block_initialize: value.block_initialize,
        multi: value.multi
    };
    this._parseName(name);
    return name;
};

CSL.NameOutput.prototype._stripPeriods = function(tokname, str) {
    var decor_tok = this[tokname + "_decor"];
    if (str) {
        if (this.state.tmp.strip_periods) {
            str = str.replace(/\./g, "");
        } else if (decor_tok) {
            for (var i = 0, ilen = decor_tok.decorations.length; i < ilen; i += 1) {
                if ("@strip-periods" === decor_tok.decorations[i][0] && "true" === decor_tok.decorations[i][1]) {
                    str = str.replace(/\./g, "");
                    break;
                }
            }
        }
    }
    return str;
};

CSL.NameOutput.prototype._nonDroppingParticle = function(name) {
    var ndp = name["non-dropping-particle"];
    if (ndp && this.state.tmp.sort_key_flag) {
        ndp = ndp.replace(/[\'\u2019]/, "");
    }
    var str = this._stripPeriods("family", ndp);
    if (this.state.output.append(str, this.family_decor, true)) {
        return this.state.output.pop();
    }
    return false;
};

CSL.NameOutput.prototype._droppingParticle = function(name, pos, j) {
    var dp = name["dropping-particle"];
    if (dp && this.state.tmp.sort_key_flag) {
        dp = dp.replace(/[\'\u2019]/, "");
    }
    var str = this._stripPeriods("given", dp);
    if (name["dropping-particle"] && name["dropping-particle"].match(/^et.?al[^a-z]$/)) {
        if (this.state.inheritOpt(this.name, "et-al-use-last")) {
            if ("undefined" === typeof j) {
                this.etal_spec[pos].freeters = 2;
            } else {
                this.etal_spec[pos].persons = 2;
            }
        } else {
            if ("undefined" === typeof j) {
                this.etal_spec[pos].freeters = 1;
            } else {
                this.etal_spec[pos].persons = 1;
            }
        }
        name["comma-dropping-particle"] = "";
    } else if (this.state.output.append(str, this.given_decor, true)) {
        return this.state.output.pop();
    }
    return false;
};

CSL.NameOutput.prototype._familyName = function(name) {
    var str = this._stripPeriods("family", name.family);
    if (this.state.output.append(str, this.family_decor, true)) {
        return this.state.output.pop();
    }
    return false;
};

CSL.NameOutput.prototype._givenName = function(name, pos, i) {
    var ret;
    var formIsShort = this.state.inheritOpt(this.name, "form", "name-form", "long") !== "long";
    var initializeIsTurnedOn = this.state.inheritOpt(this.name, "initialize") !== false;
    var hasInitializeWith = "string" === typeof this.state.inheritOpt(this.name, "initialize-with") && !name.block_initialize;
    var defaultLevel;
    var useLevel;
    if (name["full-form-always"]) {
        useLevel = 2;
    } else {
        if (formIsShort) {
            defaultLevel = 0;
        } else if (hasInitializeWith) {
            defaultLevel = 1;
        } else {
            defaultLevel = 2;
        }
        var requestedLevel = this.state.tmp.disambig_settings.givens[pos][i];
        if (requestedLevel > defaultLevel) {
            useLevel = requestedLevel;
        } else {
            useLevel = defaultLevel;
        }
    }
    var gdropt = this.state.citation.opt["givenname-disambiguation-rule"];
    if (gdropt && gdropt.slice(-14) === "-with-initials") {
        hasInitializeWith = true;
    }
    if (name.family && useLevel === 1) {
        if (hasInitializeWith) {
            var initialize_with = this.state.inheritOpt(this.name, "initialize-with", false, "");
            name.given = CSL.Util.Names.initializeWith(this.state, name.given, initialize_with, !initializeIsTurnedOn);
        } else {
            name.given = CSL.Util.Names.unInitialize(this.state, name.given);
        }
    } else if (useLevel === 0) {
        return {
            blob: false
        };
    } else if (useLevel === 2) {
        name.given = CSL.Util.Names.unInitialize(this.state, name.given);
    }
    var str = this._stripPeriods("given", name.given);
    var rendered = this.state.output.append(str, this.given_decor, true);
    if (rendered) {
        ret = this.state.output.pop();
        return {
            blob: ret,
            initializationLevel: useLevel
        };
    }
    return {
        blob: false
    };
};

CSL.NameOutput.prototype._nameSuffix = function(name) {
    var str = name.suffix, ret;
    if (str && "string" === typeof this.state.inheritOpt(this.name, "initialize-with")) {
        str = CSL.Util.Names.initializeWith(this.state, str, this.state.inheritOpt(this.name, "initialize-with"), true);
    }
    str = this._stripPeriods("family", str);
    var toSuffix = "";
    if (str && str.slice(-1) === ".") {
        str = str.slice(0, -1);
        toSuffix = ".";
    }
    var rendered = this.state.output.append(str, "empty", true);
    if (rendered) {
        ret = this.state.output.pop();
        ret.strings.suffix = toSuffix + ret.strings.suffix;
        return ret;
    }
    return false;
};

CSL.NameOutput.prototype._getLongStyle = function(name) {
    var long_style;
    if (name["short"].length) {
        if (this.institutionpart["long-with-short"]) {
            long_style = this.institutionpart["long-with-short"];
        } else {
            long_style = this.institutionpart["long"];
        }
    } else {
        long_style = this.institutionpart["long"];
    }
    if (!long_style) {
        long_style = new CSL.Token;
    }
    return long_style;
};

CSL.NameOutput.prototype._getShortStyle = function() {
    var short_style;
    if (this.institutionpart["short"]) {
        short_style = this.institutionpart["short"];
    } else {
        short_style = new CSL.Token;
    }
    return short_style;
};

CSL.NameOutput.prototype._parseName = function(name) {
    if (!name["parse-names"] && "undefined" !== typeof name["parse-names"]) {
        return name;
    }
    if (name.family && !name.given && name.isInstitution) {
        name.literal = name.family;
        name.family = undefined;
        name.isInstitution = undefined;
    }
    var noparse;
    if (name.family && name.family.slice(0, 1) === '"' && name.family.slice(-1) === '"' || !name["parse-names"] && "undefined" !== typeof name["parse-names"]) {
        name.family = name.family.slice(1, -1);
        noparse = true;
        name["parse-names"] = 0;
    } else {
        noparse = false;
    }
    if (this.state.opt.development_extensions.parse_names) {
        if (!name["non-dropping-particle"] && name.family && !noparse && name.given) {
            if (!name["static-particles"]) {
                CSL.parseParticles(name, true);
            }
        }
    }
};

CSL.NameOutput.prototype.getName = function(name, slotLocaleset, fallback, stopOrig) {
    if (stopOrig && slotLocaleset === "locale-orig") {
        return {
            name: false,
            usedOrig: stopOrig
        };
    }
    if (!name.family) {
        name.family = "";
    }
    if (!name.given) {
        name.given = "";
    }
    var name_params = {};
    name_params["static-ordering"] = this.getStaticOrder(name);
    var foundTag = true;
    var langTag;
    if (slotLocaleset !== "locale-orig") {
        foundTag = false;
        if (name.multi) {
            var langTags = this.state.opt[slotLocaleset];
            for (var i = 0, ilen = langTags.length; i < ilen; i += 1) {
                langTag = langTags[i];
                if (name.multi._key[langTag]) {
                    foundTag = true;
                    var isInstitution = name.isInstitution;
                    name = name.multi._key[langTag];
                    name.isInstitution = isInstitution;
                    name_params = this.getNameParams(langTag);
                    name_params.transliterated = true;
                    break;
                }
            }
        }
    }
    if (!foundTag) {
        langTag = false;
        if (name.multi && name.multi.main) {
            langTag = name.multi.main;
        } else if (this.Item.language) {
            langTag = this.Item.language;
        }
        if (langTag) {
            name_params = this.getNameParams(langTag);
        }
    }
    if (!fallback && !foundTag) {
        return {
            name: false,
            usedOrig: stopOrig
        };
    }
    if (!name.family) {
        name.family = "";
    }
    if (!name.given) {
        name.given = "";
    }
    if (name.literal) {
        delete name.family;
        delete name.given;
    }
    name = {
        family: name.family,
        given: name.given,
        "non-dropping-particle": name["non-dropping-particle"],
        "dropping-particle": name["dropping-particle"],
        suffix: name.suffix,
        "static-ordering": name_params["static-ordering"],
        "static-particles": name["static-particles"],
        "reverse-ordering": name_params["reverse-ordering"],
        "full-form-always": name_params["full-form-always"],
        "parse-names": name["parse-names"],
        "comma-suffix": name["comma-suffix"],
        "comma-dropping-particle": name["comma-dropping-particle"],
        transliterated: name_params.transliterated,
        block_initialize: name_params["block-initialize"],
        literal: name.literal,
        isInstitution: name.isInstitution,
        multi: name.multi
    };
    if (!name.literal && !name.given && name.family && name.isInstitution) {
        name.literal = name.family;
    }
    if (name.literal) {
        delete name.family;
        delete name.given;
    }
    name = this._normalizeNameInput(name);
    var usedOrig;
    if (stopOrig) {
        usedOrig = stopOrig;
    } else {
        usedOrig = !foundTag;
    }
    return {
        name: name,
        usedOrig: usedOrig
    };
};

CSL.NameOutput.prototype.getNameParams = function(langTag) {
    var ret = {};
    var langspec = CSL.localeResolve(this.Item.language, this.state.opt["default-locale"][0]);
    var try_locale = this.state.locale[langspec.best] ? langspec.best : this.state.opt["default-locale"][0];
    var name_as_sort_order = this.state.locale[try_locale].opts["name-as-sort-order"];
    var name_as_reverse_order = this.state.locale[try_locale].opts["name-as-reverse-order"];
    var name_never_short = this.state.locale[try_locale].opts["name-never-short"];
    var field_lang_bare = langTag.split("-")[0];
    if (name_as_sort_order && name_as_sort_order[field_lang_bare]) {
        ret["static-ordering"] = true;
        ret["reverse-ordering"] = false;
    }
    if (name_as_reverse_order && name_as_reverse_order[field_lang_bare]) {
        ret["reverse-ordering"] = true;
        ret["static-ordering"] = false;
    }
    if (name_never_short && name_never_short[field_lang_bare]) {
        ret["full-form-always"] = true;
    }
    if (ret["static-ordering"]) {
        ret["block-initialize"] = true;
    }
    return ret;
};

CSL.NameOutput.prototype.setRenderedName = function(name) {
    if (this.state.tmp.area === "bibliography") {
        var strname = "";
        for (var j = 0, jlen = CSL.NAME_PARTS.length; j < jlen; j += 1) {
            if (name[CSL.NAME_PARTS[j]]) {
                strname += name[CSL.NAME_PARTS[j]];
            }
        }
        this.state.tmp.rendered_name.push(strname);
    }
};

CSL.NameOutput.prototype.fixupInstitution = function(name, varname, listpos) {
    if (!name.literal && name.family) {
        name.literal = name.family;
        delete name.family;
    }
    var longNameStr = name.literal;
    var shortNameStr = longNameStr;
    var ret = {
        long: longNameStr.split(/\s*\|\s*/),
        short: shortNameStr.split(/\s*\|\s*/)
    };
    if (this.state.sys.getAbbreviation) {
        if (this.institution.strings.form === "short") {
            var jurisdiction = this.Item.jurisdiction;
            jurisdiction = this.state.transform.loadAbbreviation(jurisdiction, "institution-entire", longNameStr, this.Item.language);
            if (this.state.transform.abbrevs[jurisdiction]["institution-entire"][longNameStr]) {
                longNameStr = this.state.transform.abbrevs[jurisdiction]["institution-entire"][longNameStr];
            } else {
                jurisdiction = this.Item.jurisdiction;
                jurisdiction = this.state.transform.loadAbbreviation(jurisdiction, "institution-part", longNameStr, this.Item.language);
                if (this.state.transform.abbrevs[jurisdiction]["institution-part"][longNameStr]) {
                    longNameStr = this.state.transform.abbrevs[jurisdiction]["institution-part"][longNameStr];
                }
            }
            longNameStr = this._quashChecks(jurisdiction, longNameStr);
        }
        if ([ "short", "short-long", "long-short" ].indexOf(this.institution.strings["institution-parts"]) > -1) {
            var _jurisdiction = this.Item.jurisdiction;
            _jurisdiction = this.state.transform.loadAbbreviation(_jurisdiction, "institution-part", shortNameStr, this.Item.language);
            if (this.state.transform.abbrevs[_jurisdiction]["institution-part"][shortNameStr]) {
                shortNameStr = this.state.transform.abbrevs[_jurisdiction]["institution-part"][shortNameStr];
            }
            shortNameStr = this._quashChecks(_jurisdiction, shortNameStr);
            if ([ "short-long", "long-short" ].indexOf(this.institution.strings["institution-parts"]) > -1) {
                if (shortNameStr === longNameStr) {
                    shortNameStr = "";
                }
            }
        }
        ret["long"] = longNameStr.split(/\s*\|\s*/);
        ret["short"] = shortNameStr.split(/\s*\|\s*/);
        if ([ "short", "short-long", "long-short" ].indexOf(this.institution.strings["institution-parts"]) > -1) {
            for (var j = ret["short"].length - 1; j > -1; j--) {
                var _jurisdiction2 = this.Item.jurisdiction;
                var abbrevKey = ret["short"][j];
                _jurisdiction2 = this.state.transform.loadAbbreviation(_jurisdiction2, "institution-part", abbrevKey, this.Item.language);
                if (this.state.transform.abbrevs[_jurisdiction2]["institution-part"][abbrevKey]) {
                    ret["short"][j] = this.state.transform.abbrevs[_jurisdiction2]["institution-part"][abbrevKey];
                }
                if (ret["short"][j].indexOf("|") > -1) {
                    var retShort = ret["short"];
                    var splitShort = retShort[j].split(/\s*\|\s*/);
                    ret["short"] = retShort.slice(0, j).concat(splitShort).concat(retShort.slice(j + 1));
                }
            }
        }
        if (this.state.opt.development_extensions.legacy_institution_name_ordering) {
            ret["short"].reverse();
        }
        ret["short"] = this._trimInstitution(ret["short"]);
        if (this.institution.strings["reverse-order"]) {
            ret["short"].reverse();
        }
        if (!this.state.tmp.just_looking) {
            if (this.Item.jurisdiction) {
                var _jurisdiction3 = this.Item.jurisdiction;
                var trimmer = this.state.tmp.abbrev_trimmer;
                if (trimmer && trimmer[_jurisdiction3] && trimmer[_jurisdiction3][varname]) {
                    for (var i = 0, ilen = ret["short"].length; i < ilen; i++) {
                        var frag = ret["short"][i];
                        ret["short"][i] = frag.replace(trimmer[_jurisdiction3][varname], "").trim();
                    }
                }
            }
        }
    }
    if (this.state.opt.development_extensions.legacy_institution_name_ordering) {
        ret["long"].reverse();
    }
    ret["long"] = this._trimInstitution(ret["long"]);
    if (this.institution.strings["reverse-order"]) {
        ret["long"].reverse();
    }
    return ret;
};

CSL.NameOutput.prototype.getStaticOrder = function(name, refresh) {
    var static_ordering_val = false;
    if (!refresh && name["static-ordering"]) {
        static_ordering_val = true;
    } else if (this._isRomanesque(name) === 0) {
        static_ordering_val = true;
    } else if ((!name.multi || !name.multi.main) && this.Item.language && [ "vi", "hu" ].indexOf(this.Item.language) > -1) {
        static_ordering_val = true;
    } else if (name.multi && name.multi.main && [ "vi", "hu" ].indexOf(name.multi.main.slice(0, 2)) > -1) {
        static_ordering_val = true;
    } else {
        if (this.state.opt["auto-vietnamese-names"] && CSL.VIETNAMESE_NAMES.exec(name.family + " " + name.given) && CSL.VIETNAMESE_SPECIALS.exec(name.family + name.given)) {
            static_ordering_val = true;
        }
    }
    return static_ordering_val;
};

CSL.NameOutput.prototype._quashChecks = function(jurisdiction, str) {
    var str = this.state.transform.quashCheck(jurisdiction, str);
    var lst = str.split(/>>[0-9]{4}>>/);
    var m = str.match(/>>([0-9]{4})>>/);
    str = lst.pop();
    var date = this.Item["original-date"] ? this.Item["original-date"] : this.Item["issued"];
    if (date) {
        date = parseInt(date.year, 10);
        date = isNaN(date) ? false : date;
    }
    if (date) {
        if (lst.length > 0) {
            for (var k = m.length - 1; k > 0; k--) {
                if (date >= parseInt(m[k], 10)) {
                    break;
                }
                str = lst.pop();
            }
        }
        str = str.replace(/\s*\|\s*/g, "|");
    }
    return str;
};

CSL.NameOutput.prototype._trimInstitution = function(subunits) {
    var use_first = false;
    var stop_last = false;
    var use_last = false;
    var stop_first = false;
    var s = subunits.slice();
    if (this.institution) {
        if ("undefined" !== typeof this.institution.strings["use-first"]) {
            use_first = this.institution.strings["use-first"];
        }
        if ("undefined" !== typeof this.institution.strings["use-last"]) {
            use_last = this.institution.strings["use-last"];
        }
        if ("undefined" !== typeof this.institution.strings["stop-first"]) {
            stop_first = this.institution.strings["stop-first"];
        }
        if ("undefined" !== typeof this.institution.strings["stop-last"]) {
            stop_last = this.institution.strings["stop-last"];
        }
        if (use_first) {
            if (stop_last) {
                s = s.slice(0, stop_last * -1);
            }
            s = s.slice(0, use_first);
        }
        if (use_last) {
            var ss = subunits.slice();
            if (use_first) {
                stop_first = use_first;
            } else {
                s = [];
            }
            if (stop_first) {
                ss = ss.slice(stop_first);
            }
            ss = ss.slice(use_last * -1);
            s = s.concat(ss);
        }
        subunits = s;
    }
    return subunits;
};

CSL.PublisherOutput = function(state, group_tok) {
    this.state = state;
    this.group_tok = group_tok;
    this.varlist = [];
};

CSL.PublisherOutput.prototype.render = function() {
    this.clearVars();
    this.composeAndBlob();
    this.composeElements();
    this.composePublishers();
    this.joinPublishers();
};

CSL.PublisherOutput.prototype.composeAndBlob = function() {
    this.and_blob = {};
    var and_term = false;
    if (this.group_tok.strings.and === "text") {
        and_term = this.state.getTerm("and");
    } else if (this.group_tok.strings.and === "symbol") {
        and_term = "&";
    }
    var tok = new CSL.Token;
    tok.strings.suffix = " ";
    tok.strings.prefix = " ";
    this.state.output.append(and_term, tok, true);
    var no_delim = this.state.output.pop();
    tok.strings.prefix = this.group_tok.strings["subgroup-delimiter"];
    this.state.output.append(and_term, tok, true);
    var with_delim = this.state.output.pop();
    this.and_blob.single = false;
    this.and_blob.multiple = false;
    if (and_term) {
        if (this.group_tok.strings["subgroup-delimiter-precedes-last"] === "always") {
            this.and_blob.single = with_delim;
        } else if (this.group_tok.strings["subgroup-delimiter-precedes-last"] === "never") {
            this.and_blob.single = no_delim;
            this.and_blob.multiple = no_delim;
        } else {
            this.and_blob.single = no_delim;
            this.and_blob.multiple = with_delim;
        }
    }
};

CSL.PublisherOutput.prototype.composeElements = function() {
    for (var i = 0, ilen = 2; i < ilen; i += 1) {
        var varname = [ "publisher", "publisher-place" ][i];
        for (var j = 0, jlen = this["publisher-list"].length; j < jlen; j += 1) {
            var str = this[varname + "-list"][j];
            var tok = this[varname + "-token"];
            this.state.output.append(str, tok, true);
            this[varname + "-list"][j] = this.state.output.pop();
        }
    }
};

CSL.PublisherOutput.prototype.composePublishers = function() {
    var blobs;
    for (var i = 0, ilen = this["publisher-list"].length; i < ilen; i += 1) {
        blobs = [ this[this.varlist[0] + "-list"][i], this[this.varlist[1] + "-list"][i] ];
        this["publisher-list"][i] = this._join(blobs, this.group_tok.strings.delimiter);
    }
};

CSL.PublisherOutput.prototype.joinPublishers = function() {
    var blobs = this["publisher-list"];
    var publishers = this._join(blobs, this.group_tok.strings["subgroup-delimiter"], this.and_blob.single, this.and_blob.multiple, this.group_tok);
    this.state.output.append(publishers, "literal");
};

CSL.PublisherOutput.prototype._join = CSL.NameOutput.prototype._join;

CSL.PublisherOutput.prototype._getToken = CSL.NameOutput.prototype._getToken;

CSL.PublisherOutput.prototype.clearVars = function() {
    this.state.tmp["publisher-list"] = false;
    this.state.tmp["publisher-place-list"] = false;
    this.state.tmp["publisher-group-token"] = false;
    this.state.tmp["publisher-token"] = false;
    this.state.tmp["publisher-place-token"] = false;
};

CSL.evaluateLabel = function(node, state, Item, item) {
    var myterm;
    if ("locator" === node.strings.term) {
        if (item && item.label) {
            if (item.label === "sub verbo") {
                myterm = "sub-verbo";
            } else {
                myterm = item.label;
            }
        }
        if (!myterm) {
            myterm = "page";
        }
    } else {
        myterm = node.strings.term;
    }
    var plural = node.strings.plural;
    if ("number" !== typeof plural) {
        var theItem = item && node.strings.term === "locator" ? item : Item;
        if (theItem[node.strings.term]) {
            state.processNumber(false, theItem, node.strings.term, Item.type);
            plural = state.tmp.shadow_numbers[node.strings.term].plural;
            if (!state.tmp.shadow_numbers[node.strings.term].labelForm && !state.tmp.shadow_numbers[node.strings.term].labelDecorations) {
                if (node.strings.form) {
                    state.tmp.shadow_numbers[node.strings.term].labelForm = node.strings.form;
                } else if (state.tmp.group_context.tip.label_form) {
                    state.tmp.shadow_numbers[node.strings.term].labelForm = state.tmp.group_context.tip.label_form;
                }
                state.tmp.shadow_numbers[node.strings.term].labelCapitalizeIfFirst = node.strings.capitalize_if_first;
                state.tmp.shadow_numbers[node.strings.term].labelDecorations = node.decorations.slice();
            }
            if ([ "locator", "number", "page" ].indexOf(node.strings.term) > -1 && state.tmp.shadow_numbers[node.strings.term].label) {
                myterm = state.tmp.shadow_numbers[node.strings.term].label;
            }
            if (node.decorations && state.opt.development_extensions.csl_reverse_lookup_support) {
                node.decorations.reverse();
                node.decorations.push([ "@showid", "true", node.cslid ]);
                node.decorations.reverse();
            }
        }
    }
    return CSL.castLabel(state, node, myterm, plural, CSL.TOLERANT);
};

CSL.castLabel = function(state, node, term, plural, mode) {
    var label_form = node.strings.form;
    var label_capitalize_if_first = node.strings.capitalize_if_first;
    if (state.tmp.group_context.tip.label_form) {
        if (label_form === "static") {
            state.tmp.group_context.tip.label_static = true;
        } else {
            label_form = state.tmp.group_context.tip.label_form;
        }
    }
    if (state.tmp.group_context.tip.label_capitalize_if_first) {
        label_capitalize_if_first = state.tmp.group_context.tip.label_capitalize_if_first;
    }
    var ret = state.getTerm(term, label_form, plural, false, mode, node.default_locale);
    if (label_capitalize_if_first) {
        ret = CSL.Output.Formatters["capitalize-first"](state, ret);
    }
    if (state.tmp.strip_periods) {
        ret = ret.replace(/\./g, "");
    } else {
        for (var i = 0, ilen = node.decorations.length; i < ilen; i += 1) {
            if ("@strip-periods" === node.decorations[i][0] && "true" === node.decorations[i][1]) {
                ret = ret.replace(/\./g, "");
                break;
            }
        }
    }
    return ret;
};

CSL.Node.name = {
    build: function build(state, target) {
        var func;
        if ([ CSL.SINGLETON, CSL.START ].indexOf(this.tokentype) > -1) {
            var oldTmpRoot;
            if ("undefined" === typeof state.tmp.root) {
                oldTmpRoot = undefined;
                state.tmp.root = "citation";
            } else {
                oldTmpRoot = state.tmp.root;
            }
            if (state.inheritOpt(this, "et-al-subsequent-min") && state.inheritOpt(this, "et-al-subsequent-min") !== state.inheritOpt(this, "et-al-min")) {
                state.opt.update_mode = CSL.POSITION;
            }
            if (state.inheritOpt(this, "et-al-subsequent-use-first") && state.inheritOpt(this, "et-al-subsequent-use-first") !== state.inheritOpt(this, "et-al-use-first")) {
                state.opt.update_mode = CSL.POSITION;
            }
            state.tmp.root = oldTmpRoot;
            func = function func(state) {
                state.tmp.etal_term = "et-al";
                state.tmp.name_delimiter = state.inheritOpt(this, "delimiter", "name-delimiter", ", ");
                state.tmp["delimiter-precedes-et-al"] = state.inheritOpt(this, "delimiter-precedes-et-al");
                if ("text" === state.inheritOpt(this, "and")) {
                    this.and_term = state.getTerm("and", "long", 0);
                } else if ("symbol" === state.inheritOpt(this, "and")) {
                    if (state.opt.development_extensions.expect_and_symbol_form) {
                        this.and_term = state.getTerm("and", "symbol", 0);
                    } else {
                        this.and_term = "&";
                    }
                }
                state.tmp.and_term = this.and_term;
                if (CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.and_term)) {
                    this.and_prefix_single = " ";
                    this.and_prefix_multiple = ", ";
                    if ("string" === typeof state.tmp.name_delimiter) {
                        this.and_prefix_multiple = state.tmp.name_delimiter;
                    }
                    this.and_suffix = " ";
                } else {
                    this.and_prefix_single = "";
                    this.and_prefix_multiple = "";
                    this.and_suffix = "";
                }
                if (state.inheritOpt(this, "delimiter-precedes-last") === "always") {
                    this.and_prefix_single = state.tmp.name_delimiter;
                } else if (state.inheritOpt(this, "delimiter-precedes-last") === "never") {
                    if (this.and_prefix_multiple) {
                        this.and_prefix_multiple = " ";
                    }
                } else if (state.inheritOpt(this, "delimiter-precedes-last") === "after-inverted-name") {
                    if (this.and_prefix_single) {
                        this.and_prefix_single = state.tmp.name_delimiter;
                    }
                    if (this.and_prefix_multiple) {
                        this.and_prefix_multiple = " ";
                    }
                }
                this.and = {};
                if (state.inheritOpt(this, "and")) {
                    state.output.append(this.and_term, "empty", true);
                    this.and.single = state.output.pop();
                    this.and.single.strings.prefix = this.and_prefix_single;
                    this.and.single.strings.suffix = this.and_suffix;
                    state.output.append(this.and_term, "empty", true);
                    this.and.multiple = state.output.pop();
                    this.and.multiple.strings.prefix = this.and_prefix_multiple;
                    this.and.multiple.strings.suffix = this.and_suffix;
                } else if (state.tmp.name_delimiter) {
                    this.and.single = new CSL.Blob(state.tmp.name_delimiter);
                    this.and.single.strings.prefix = "";
                    this.and.single.strings.suffix = "";
                    this.and.multiple = new CSL.Blob(state.tmp.name_delimiter);
                    this.and.multiple.strings.prefix = "";
                    this.and.multiple.strings.suffix = "";
                }
                this.ellipsis = {};
                if (state.inheritOpt(this, "et-al-use-last")) {
                    this.ellipsis_term = "…";
                    this.ellipsis_prefix_single = " ";
                    this.ellipsis_prefix_multiple = state.inheritOpt(this, "delimiter", "name-delimiter", ", ");
                    this.ellipsis_suffix = " ";
                    this.ellipsis.single = new CSL.Blob(this.ellipsis_term);
                    this.ellipsis.single.strings.prefix = this.ellipsis_prefix_single;
                    this.ellipsis.single.strings.suffix = this.ellipsis_suffix;
                    this.ellipsis.multiple = new CSL.Blob(this.ellipsis_term);
                    this.ellipsis.multiple.strings.prefix = this.ellipsis_prefix_multiple;
                    this.ellipsis.multiple.strings.suffix = this.ellipsis_suffix;
                }
                if ("undefined" === typeof state.tmp["et-al-min"]) {
                    state.tmp["et-al-min"] = state.inheritOpt(this, "et-al-min");
                }
                if ("undefined" === typeof state.tmp["et-al-use-first"]) {
                    state.tmp["et-al-use-first"] = state.inheritOpt(this, "et-al-use-first");
                }
                if ("undefined" === typeof state.tmp["et-al-use-last"]) {
                    state.tmp["et-al-use-last"] = state.inheritOpt(this, "et-al-use-last");
                }
                state.nameOutput.name = this;
            };
            state.build.name_flag = true;
            this.execs.push(func);
        }
        target.push(this);
    }
};

CSL.Node["name-part"] = {
    build: function build(state) {
        state.build[this.strings.name] = this;
    }
};

CSL.Node.names = {
    build: function build(state, target) {
        var func;
        if (this.tokentype === CSL.START || this.tokentype === CSL.SINGLETON) {
            CSL.Util.substituteStart.call(this, state, target);
            state.build.substitute_level.push(1);
        }
        if (this.tokentype === CSL.SINGLETON) {
            state.build.names_variables[state.build.names_variables.length - 1].concat(this.variables);
            for (var i in this.variables) {
                var variable = this.variables[i];
                var name_labels = state.build.name_label[state.build.name_label.length - 1];
                if (Object.keys(name_labels).length) {
                    name_labels[variable] = name_labels[Object.keys(name_labels)[0]];
                }
            }
            func = function func(state) {
                state.nameOutput.reinit(this, this.variables_real[0]);
            };
            this.execs.push(func);
        }
        if (this.tokentype === CSL.START) {
            state.build.names_flag = true;
            state.build.name_flag = false;
            state.build.names_level += 1;
            state.build.names_variables.push(this.variables);
            state.build.name_label.push({});
            func = function func(state) {
                state.tmp.can_substitute.push(true);
                state.tmp.name_node = {};
                state.tmp.name_node.children = [];
                state.nameOutput.init(this);
            };
            this.execs.push(func);
        }
        if (this.tokentype === CSL.END) {
            for (var i = 0, ilen = 3; i < ilen; i += 1) {
                var key = [ "family", "given", "et-al" ][i];
                this[key] = state.build[key];
                if (state.build.names_level === 1) {
                    state.build[key] = undefined;
                }
            }
            this.label = state.build.name_label[state.build.name_label.length - 1];
            state.build.names_level += -1;
            state.build.names_variables.pop();
            state.build.name_label.pop();
            func = function func(state) {
                if (state.tmp.etal_node) {
                    this.etal_style = state.tmp.etal_node;
                } else {
                    this.etal_style = "empty";
                }
                this.etal_term = state.getTerm(state.tmp.etal_term, "long", 0);
                this.etal_prefix_single = " ";
                this.etal_prefix_multiple = state.tmp.name_delimiter;
                if (state.tmp["delimiter-precedes-et-al"] === "always") {
                    this.etal_prefix_single = state.tmp.name_delimiter;
                } else if (state.tmp["delimiter-precedes-et-al"] === "never") {
                    this.etal_prefix_multiple = " ";
                } else if (state.tmp["delimiter-precedes-et-al"] === "after-inverted-name") {
                    this.etal_prefix_single = state.tmp.name_delimiter;
                    this.etal_prefix_multiple = " ";
                }
                this.etal_suffix = "";
                if (!CSL.STARTSWITH_ROMANESQUE_REGEXP.test(this.etal_term)) {
                    if (this.etal_prefix_single === " ") {
                        this.etal_prefix_single = "";
                    }
                    if (this.etal_prefix_multiple === " ") {
                        this.etal_prefix_multiple = "";
                    }
                    if (this.etal_suffix === " ") {
                        this.etal_suffix = "";
                    }
                }
                for (var i = 0, ilen = 3; i < ilen; i += 1) {
                    var key = [ "family", "given" ][i];
                    state.nameOutput[key] = this[key];
                }
                state.nameOutput["with"] = this["with"];
                var mywith = "with";
                var with_default_prefix = "";
                var with_suffix = "";
                if (CSL.STARTSWITH_ROMANESQUE_REGEXP.test(mywith)) {
                    with_default_prefix = " ";
                    with_suffix = " ";
                }
                var thewith = {};
                thewith.single = new CSL.Blob(mywith);
                thewith.single.strings.suffix = with_suffix;
                thewith.multiple = new CSL.Blob(mywith);
                thewith.multiple.strings.suffix = with_suffix;
                if (state.inheritOpt(state.nameOutput.name, "delimiter-precedes-last") === "always") {
                    thewith.single.strings.prefix = state.inheritOpt(this, "delimiter", "names-delimiter");
                    thewith.multiple.strings.prefix = state.inheritOpt(this, "delimiter", "names-delimiter");
                } else if (state.inheritOpt(state.nameOutput.name, "delimiter-precedes-last") === "contextual") {
                    thewith.single.strings.prefix = with_default_prefix;
                    thewith.multiple.strings.prefix = state.inheritOpt(this, "delimiter", "names-delimiter");
                } else if (state.inheritOpt(state.nameOutput.name, "delimiter-precedes-last") === "after-inverted-name") {
                    thewith.single.strings.prefix = state.inheritOpt(this, "delimiter", "names-delimiter");
                    thewith.multiple.strings.prefix = with_default_prefix;
                } else {
                    thewith.single.strings.prefix = with_default_prefix;
                    thewith.multiple.strings.prefix = with_default_prefix;
                }
                state.nameOutput["with"] = thewith;
                state.nameOutput.label = this.label;
                state.nameOutput.etal_style = this.etal_style;
                state.nameOutput.etal_term = this.etal_term;
                state.nameOutput.etal_prefix_single = this.etal_prefix_single;
                state.nameOutput.etal_prefix_multiple = this.etal_prefix_multiple;
                state.nameOutput.etal_suffix = this.etal_suffix;
                state.nameOutput.outputNames();
                state.tmp["et-al-use-first"] = undefined;
                state.tmp["et-al-min"] = undefined;
                state.tmp["et-al-use-last"] = undefined;
            };
            this.execs.push(func);
            func = function func(state) {
                if (!state.tmp.can_substitute.pop()) {
                    state.tmp.can_substitute.replace(false, CSL.LITERAL);
                }
                if (state.tmp.can_substitute.mystack.length === 1) {
                    state.tmp.can_block_substitute = false;
                }
            };
            this.execs.push(func);
            state.build.name_flag = false;
        }
        target.push(this);
        if (this.tokentype === CSL.END || this.tokentype === CSL.SINGLETON) {
            state.build.substitute_level.pop();
            CSL.Util.substituteEnd.call(this, state, target);
        }
    }
};

CSL.Node.number = {
    build: function build(state, target) {
        var func;
        CSL.Util.substituteStart.call(this, state, target);
        if (this.strings.form === "roman") {
            this.formatter = state.fun.romanizer;
        } else if (this.strings.form === "ordinal") {
            this.formatter = state.fun.ordinalizer;
        } else if (this.strings.form === "long-ordinal") {
            this.formatter = state.fun.long_ordinalizer;
        }
        if ("undefined" === typeof this.successor_prefix) {
            this.successor_prefix = state[state.build.area].opt.layout_delimiter;
        }
        if ("undefined" === typeof this.splice_prefix) {
            this.splice_prefix = state[state.build.area].opt.layout_delimiter;
        }
        func = function func(state, Item, item) {
            if (this.variables.length === 0) {
                return;
            }
            var varname;
            varname = this.variables[0];
            if ("undefined" === typeof item) {
                var item = {};
            }
            if ([ "locator", "locator-extra" ].indexOf(varname) > -1) {
                if (state.tmp.just_looking) {
                    return;
                }
                if (!item[varname]) {
                    return;
                }
            } else {
                if (!Item[varname]) {
                    return;
                }
            }
            if (varname === "collection-number" && Item.type === "legal_case") {
                state.tmp.renders_collection_number = true;
            }
            var node = this;
            if (state.tmp.group_context.tip.force_suppress) {
                return false;
            }
            if ([ "locator", "locator-extra" ].indexOf(varname) > -1) {
                state.processNumber.call(state, node, item, varname, Item.type);
            } else {
                if (!state.tmp.group_context.tip.condition && Item[varname]) {
                    state.tmp.just_did_number = ("" + Item[varname]).match(/[0-9]$/);
                }
                state.processNumber.call(state, node, Item, varname, Item.type);
            }
            if (this.substring) {
                var val = Item[varname].slice(this.substring);
                state.output.append(val, node);
            } else {
                CSL.Util.outputNumericField(state, varname, Item.id);
            }
            if ([ "locator", "locator-extra" ].indexOf(this.variables_real[0]) > -1 && !state.tmp.just_looking) {
                state.tmp.done_vars.push(this.variables_real[0]);
                state.tmp.group_context.tip.done_vars.push(this.variables_real[0]);
            }
        };
        this.execs.push(func);
        target.push(this);
        CSL.Util.substituteEnd.call(this, state, target);
    }
};

CSL.Node.sort = {
    build: function build(state, target) {
        target = state[state.build.root + "_sort"].tokens;
        if (this.tokentype === CSL.START) {
            if (state.build.area === "citation") {
                state.opt.sort_citations = true;
            }
            state.build.area = state.build.root + "_sort";
            state.build.extension = "_sort";
            var func = function func(state, Item) {
                if (state.opt.has_layout_locale) {
                    var langspec = CSL.localeResolve(Item.language, state.opt["default-locale"][0]);
                    var sort_locales = state[state.tmp.area.slice(0, -5)].opt.sort_locales;
                    var langForItem;
                    for (var i = 0, ilen = sort_locales.length; i < ilen; i += 1) {
                        langForItem = sort_locales[i][langspec.bare];
                        if (!langForItem) {
                            langForItem = sort_locales[i][langspec.best];
                        }
                        if (langForItem) {
                            break;
                        }
                    }
                    if (!langForItem) {
                        langForItem = state.opt["default-locale"][0];
                    }
                    state.tmp.lang_sort_hold = state.opt.lang;
                    state.opt.lang = langForItem;
                }
            };
            this.execs.push(func);
        }
        if (this.tokentype === CSL.END) {
            state.build.area = state.build.root;
            state.build.extension = "";
            var func = function func(state) {
                if (state.opt.has_layout_locale) {
                    state.opt.lang = state.tmp.lang_sort_hold;
                    delete state.tmp.lang_sort_hold;
                }
            };
            this.execs.push(func);
        }
        target.push(this);
    }
};

CSL.Node.substitute = {
    build: function build(state, target) {
        var func;
        if (this.tokentype === CSL.START) {
            var choose_start = new CSL.Token("choose", CSL.START);
            CSL.Node.choose.build.call(choose_start, state, target);
            var if_singleton = new CSL.Token("if", CSL.SINGLETON);
            func = function func() {
                if (state.tmp.value.length && !state.tmp.common_term_match_fail) {
                    return true;
                }
                return false;
            };
            if_singleton.tests = [ func ];
            if_singleton.test = state.fun.match.any(if_singleton, state, if_singleton.tests);
            target.push(if_singleton);
            func = function func(state) {
                state.tmp.can_block_substitute = true;
                if (state.tmp.value.length && !state.tmp.common_term_match_fail) {
                    state.tmp.can_substitute.replace(false, CSL.LITERAL);
                }
                state.tmp.common_term_match_fail = false;
            };
            this.execs.push(func);
            target.push(this);
        }
        if (this.tokentype === CSL.END) {
            target.push(this);
            var choose_end = new CSL.Token("choose", CSL.END);
            CSL.Node.choose.build.call(choose_end, state, target);
        }
    }
};

CSL.Node.text = {
    build: function build(state, target) {
        var func, form, plural, id, num, number, formatter, firstoutput, specialdelimiter, label, suffix;
        if (this.postponed_macro) {
            var group_start = CSL.Util.cloneToken(this);
            group_start.name = "group";
            group_start.tokentype = CSL.START;
            CSL.Node.group.build.call(group_start, state, target);
            CSL.expandMacro.call(state, this, target);
            var group_end = CSL.Util.cloneToken(this);
            group_end.name = "group";
            group_end.tokentype = CSL.END;
            if (this.postponed_macro === "juris-locator-label") {
                group_end.isJurisLocatorLabel = true;
            }
            CSL.Node.group.build.call(group_end, state, target);
        } else {
            CSL.Util.substituteStart.call(this, state, target);
            if (!this.variables_real) {
                this.variables_real = [];
            }
            if (!this.variables) {
                this.variables = [];
            }
            form = "long";
            plural = 0;
            if (this.strings.form) {
                form = this.strings.form;
            }
            if (this.strings.plural) {
                plural = this.strings.plural;
            }
            if ("citation-number" === this.variables_real[0] || "year-suffix" === this.variables_real[0] || "citation-label" === this.variables_real[0]) {
                if (this.variables_real[0] === "citation-number") {
                    if (state.build.root === "citation") {
                        state.opt.update_mode = CSL.NUMERIC;
                    }
                    if (state.build.root === "bibliography") {
                        state.opt.bib_mode = CSL.NUMERIC;
                    }
                    if ("citation-number" === state[state.tmp.area].opt.collapse) {
                        this.range_prefix = state.getTerm("citation-range-delimiter");
                    }
                    this.successor_prefix = state[state.build.area].opt.layout_delimiter;
                    this.splice_prefix = state[state.build.area].opt.layout_delimiter;
                    func = function func(state, Item, item) {
                        id = "" + Item.id;
                        if (!state.tmp.just_looking) {
                            if (state.tmp.area.slice(-5) === "_sort" && this.variables[0] === "citation-number") {
                                if (state.tmp.area === "bibliography_sort") {
                                    state.tmp.group_context.tip.done_vars.push("citation-number");
                                }
                                if (state.tmp.area === "citation_sort" && state.bibliography_sort.tmp.citation_number_map) {
                                    var num = state.bibliography_sort.tmp.citation_number_map[state.registry.registry[Item.id].seq];
                                } else {
                                    var num = state.registry.registry[Item.id].seq;
                                }
                                if (num) {
                                    num = CSL.Util.padding("" + num);
                                }
                                state.output.append(num, this);
                                return;
                            }
                            if (item && item["author-only"]) {
                                state.tmp.element_trace.replace("suppress-me");
                            }
                            if (state.tmp.area !== "bibliography_sort" && state.bibliography_sort.tmp.citation_number_map && state.bibliography_sort.opt.citation_number_sort_direction === CSL.DESCENDING) {
                                num = state.bibliography_sort.tmp.citation_number_map[state.registry.registry[id].seq];
                            } else {
                                num = state.registry.registry[id].seq;
                            }
                            if (state.opt.citation_number_slug) {
                                state.output.append(state.opt.citation_number_slug, this);
                            } else {
                                number = new CSL.NumericBlob(state, false, num, this, Item.id);
                                if (state.tmp.in_cite_predecessor) {
                                    number.suppress_splice_prefix = true;
                                }
                                state.output.append(number, "literal");
                            }
                        }
                    };
                    this.execs.push(func);
                } else if (this.variables_real[0] === "year-suffix") {
                    state.opt.has_year_suffix = true;
                    if (state[state.tmp.area].opt.collapse === "year-suffix-ranged") {
                        this.range_prefix = state.getTerm("citation-range-delimiter");
                    }
                    this.successor_prefix = state[state.build.area].opt.layout_delimiter;
                    if (state[state.tmp.area].opt["year-suffix-delimiter"]) {
                        this.successor_prefix = state[state.build.area].opt["year-suffix-delimiter"];
                    }
                    func = function func(state, Item) {
                        if (state.registry.registry[Item.id] && state.registry.registry[Item.id].disambig.year_suffix !== false && !state.tmp.just_looking) {
                            num = parseInt(state.registry.registry[Item.id].disambig.year_suffix, 10);
                            if (state[state.tmp.area].opt.cite_group_delimiter) {
                                this.successor_prefix = state[state.tmp.area].opt.cite_group_delimiter;
                            }
                            number = new CSL.NumericBlob(state, false, num, this, Item.id);
                            formatter = new CSL.Util.Suffixator(CSL.SUFFIX_CHARS);
                            number.setFormatter(formatter);
                            state.output.append(number, "literal");
                            firstoutput = false;
                            for (var i = 0, ilen = state.tmp.group_context.mystack.length; i < ilen; i++) {
                                var flags = state.tmp.group_context.mystack[i];
                                if (!flags.variable_success && (flags.variable_attempt || !flags.variable_attempt && !flags.term_intended)) {
                                    firstoutput = true;
                                    break;
                                }
                            }
                            specialdelimiter = state[state.tmp.area].opt["year-suffix-delimiter"];
                            if (firstoutput && specialdelimiter && !state.tmp.sort_key_flag) {
                                state.tmp.splice_delimiter = state[state.tmp.area].opt["year-suffix-delimiter"];
                            }
                        }
                    };
                    this.execs.push(func);
                } else if (this.variables_real[0] === "citation-label") {
                    if (state.build.root === "bibliography") {
                        state.opt.bib_mode = CSL.TRIGRAPH;
                    }
                    state.opt.has_year_suffix = true;
                    func = function func(state, Item) {
                        label = Item["citation-label"];
                        if (!label) {
                            label = state.getCitationLabel(Item);
                        }
                        if (!state.tmp.just_looking) {
                            suffix = "";
                            if (state.registry.registry[Item.id] && state.registry.registry[Item.id].disambig.year_suffix !== false) {
                                num = parseInt(state.registry.registry[Item.id].disambig.year_suffix, 10);
                                suffix = state.fun.suffixator.format(num);
                            }
                            label += suffix;
                        }
                        state.output.append(label, this);
                    };
                    this.execs.push(func);
                }
            } else {
                if (this.strings.term) {
                    func = function func(state, Item) {
                        var gender = state.opt.gender[Item.type];
                        var term = this.strings.term;
                        term = state.getTerm(term, form, plural, gender, CSL.TOLERANT, this.default_locale);
                        var myterm;
                        if (term !== "") {
                            state.tmp.group_context.tip.term_intended = true;
                        }
                        CSL.UPDATE_GROUP_CONTEXT_CONDITION(state, term, null, this);
                        if (!state.tmp.term_predecessor && !(state.opt["class"] === "in-text" && state.tmp.area === "citation")) {
                            myterm = CSL.Output.Formatters["capitalize-first"](state, term);
                        } else {
                            myterm = term;
                        }
                        if (state.tmp.strip_periods) {
                            myterm = myterm.replace(/\./g, "");
                        } else {
                            for (var i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
                                if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                                    myterm = myterm.replace(/\./g, "");
                                    break;
                                }
                            }
                        }
                        state.output.append(myterm, this);
                        if (state.tmp.can_block_substitute) {
                            state.tmp.can_substitute.replace(false, CSL.LITERAL);
                        }
                    };
                    this.execs.push(func);
                    state.build.term = false;
                    state.build.form = false;
                    state.build.plural = false;
                } else if (this.variables_real.length) {
                    func = function func(state, Item) {
                        if (this.variables_real[0] !== "locator") {
                            state.tmp.have_collapsed = false;
                        }
                        if (!state.tmp.group_context.tip.condition && Item[this.variables[0]]) {
                            state.tmp.just_did_number = false;
                        }
                        var val = Item[this.variables[0]];
                        if (val && !state.tmp.group_context.tip.condition) {
                            if (("" + val).slice(-1).match(/[0-9]/)) {
                                state.tmp.just_did_number = true;
                            } else {
                                state.tmp.just_did_number = false;
                            }
                        }
                    };
                    this.execs.push(func);
                    if (CSL.MULTI_FIELDS.indexOf(this.variables_real[0]) > -1 || this.variables_real[0].indexOf("-main") > -1 || this.variables_real[0].indexOf("-sub") > -1 || [ "language-name", "language-name-original" ].indexOf(this.variables_real[0]) > -1) {
                        var abbrevfam = this.variables[0];
                        var abbrfall = false;
                        var altvar = false;
                        var transfall = false;
                        if (form === "short") {
                            if (this.variables_real[0].slice(-6) !== "-short") {
                                altvar = this.variables_real[0] + "-short";
                            }
                        } else {
                            abbrevfam = false;
                        }
                        if (state.build.extension) {
                            transfall = true;
                        } else {
                            transfall = true;
                            abbrfall = true;
                        }
                        func = state.transform.getOutputFunction(this.variables, abbrevfam, abbrfall, altvar, transfall);
                    } else {
                        if (CSL.CITE_FIELDS.indexOf(this.variables_real[0]) > -1) {
                            func = function func(state, Item, item) {
                                if (item && item[this.variables[0]]) {
                                    state.processNumber(this, item, this.variables[0], Item.type);
                                    CSL.Util.outputNumericField(state, this.variables[0], Item.id);
                                    if ([ "locator", "locator-extra" ].indexOf(this.variables_real[0]) > -1 && !state.tmp.just_looking) {
                                        state.tmp.done_vars.push(this.variables_real[0]);
                                    }
                                }
                            };
                        } else if ([ "page", "page-first", "chapter-number", "collection-number", "edition", "issue", "number", "number-of-pages", "number-of-volumes", "volume" ].indexOf(this.variables_real[0]) > -1) {
                            func = function func(state, Item) {
                                state.processNumber(this, Item, this.variables[0], Item.type);
                                CSL.Util.outputNumericField(state, this.variables[0], Item.id);
                            };
                        } else if ([ "URL", "DOI" ].indexOf(this.variables_real[0]) > -1) {
                            func = function func(state, Item) {
                                var value;
                                if (this.variables[0]) {
                                    value = state.getVariable(Item, this.variables[0], form);
                                    if (value) {
                                        if (this.variables[0] === "URL" && form === "short") {
                                            value = value.replace(/(.*\.[^\/]+)\/.*/, "$1");
                                            if (value.match(/\/\/www\./)) {
                                                value = value.replace(/https?:\/\//, "");
                                            }
                                        }
                                        if (this.variables[0] === "DOI") {
                                            if (!value.match(/^https?:\/\//) && this.strings.prefix && this.strings.prefix.match(/^.*https:\/\/doi\.org\/$/)) {
                                                value = CSL.Util.encodeDoiForUrl(value);
                                            }
                                        }
                                        if (state.opt.development_extensions.wrap_url_and_doi) {
                                            if (!this.decorations.length || this.decorations[0][0] !== "@" + this.variables[0]) {
                                                var clonetoken = CSL.Util.cloneToken(this);
                                                var groupblob = new CSL.Blob(null, null, "url-wrapper");
                                                groupblob.decorations.push([ "@DOI", "true" ]);
                                                if (this.variables_real[0] === "DOI") {
                                                    var prefix;
                                                    if (this.strings.prefix && this.strings.prefix.match(/^.*https:\/\/doi\.org\/$/)) {
                                                        if (value.match(/^https?:\/\/doi\.org\//)) {
                                                            value = value.replace(/^https?:\/\/doi\.org\//, "");
                                                            value = decodeURIComponent(value);
                                                        }
                                                        if (value.match(/^https?:\/\//)) {
                                                            prefix = "";
                                                        } else {
                                                            prefix = "https://doi.org/";
                                                        }
                                                        clonetoken.strings.prefix = this.strings.prefix.slice(0, clonetoken.strings.prefix.length - 16);
                                                    }
                                                    if (!value.match(/^https?:\/\//)) {
                                                        value = CSL.Util.encodeDoiForUrl(value);
                                                    }
                                                    var prefixblob = new CSL.Blob(prefix);
                                                    var valueblob = new CSL.Blob(value);
                                                    groupblob.push(prefixblob);
                                                    groupblob.push(valueblob);
                                                    state.output.append(groupblob, clonetoken, false, false, true);
                                                } else {
                                                    var valueblob = new CSL.Blob(value);
                                                    groupblob.push(valueblob);
                                                    state.output.append(groupblob, clonetoken, false, false, true);
                                                }
                                            } else {
                                                state.output.append(value, this, false, false, true);
                                            }
                                        } else {
                                            if (this.decorations.length) {
                                                for (var i = this.decorations.length - 1; i > -1; i--) {
                                                    if (this.decorations[i][0] === "@" + this.variables[0]) {
                                                        this.decorations = this.decorations.slice(0, i).concat(this.decorations.slice(i + 1));
                                                    }
                                                }
                                            }
                                            state.output.append(value, this, false, false, true);
                                        }
                                    }
                                }
                            };
                        } else if (this.variables_real[0] === "section") {
                            func = function func(state, Item) {
                                var value;
                                value = state.getVariable(Item, this.variables[0], form);
                                if (value) {
                                    state.output.append(value, this);
                                }
                            };
                        } else if (this.variables_real[0] === "hereinafter") {
                            func = function func(state, Item) {
                                var value = state.transform.abbrevs["default"]["hereinafter"][Item.id];
                                if (value) {
                                    state.output.append(value, this);
                                    state.tmp.group_context.tip.variable_success = true;
                                }
                            };
                        } else {
                            func = function func(state, Item) {
                                var value;
                                if (this.variables[0]) {
                                    value = state.getVariable(Item, this.variables[0], form);
                                    if (value) {
                                        value = "" + value;
                                        value = value.split("\\").join("");
                                        state.output.append(value, this);
                                    }
                                }
                            };
                        }
                    }
                    this.execs.push(func);
                } else if (this.strings.value) {
                    func = function func(state) {
                        state.tmp.group_context.tip.term_intended = true;
                        CSL.UPDATE_GROUP_CONTEXT_CONDITION(state, this.strings.value, true, this);
                        state.output.append(this.strings.value, this);
                        if (state.tmp.can_block_substitute) {
                            state.tmp.can_substitute.replace(false, CSL.LITERAL);
                        }
                    };
                    this.execs.push(func);
                }
            }
            target.push(this);
            CSL.Util.substituteEnd.call(this, state, target);
        }
    }
};

CSL.Node.intext = {
    build: function build(state, target) {
        if (this.tokentype === CSL.START) {
            state.build.area = "intext";
            state.build.root = "intext";
            state.build.extension = "";
            var func = function func(state, Item) {
                state.tmp.area = "intext";
                state.tmp.root = "intext";
                state.tmp.extension = "";
            };
            this.execs.push(func);
        }
        if (this.tokentype === CSL.END) {
            state.intext_sort = {
                opt: {
                    sort_directions: state.citation_sort.opt.sort_directions
                }
            };
            state.intext.srt = state.citation.srt;
        }
        target.push(this);
    }
};

CSL.Attributes = {};

CSL.Attributes["@disambiguate"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    if (arg === "true") {
        state.opt.has_disambiguate = true;
        var func = function func(Item) {
            if (state.tmp.area === "bibliography") {
                if (state.tmp.disambiguate_count < state.registry.registry[Item.id].disambig.disambiguate) {
                    state.tmp.disambiguate_count += 1;
                    return true;
                }
            } else {
                state.tmp.disambiguate_maxMax += 1;
                if (state.tmp.disambig_settings.disambiguate && state.tmp.disambiguate_count < state.tmp.disambig_settings.disambiguate) {
                    state.tmp.disambiguate_count += 1;
                    return true;
                }
            }
            return false;
        };
        this.tests.push(func);
    } else if (arg === "check-ambiguity-and-backreference") {
        var func = function func(Item) {
            if (state.registry.registry[Item.id].disambig.disambiguate && state.registry.registry[Item.id]["citation-count"] > 1) {
                return true;
            }
            return false;
        };
        this.tests.push(func);
    }
};

CSL.Attributes["@is-numeric"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var variables = arg.split(/\s+/);
    var maketest = function maketest(variable) {
        return function(Item, item) {
            var myitem = Item;
            if (item && [ "locator", "locator-extra" ].indexOf(variable) > -1) {
                myitem = item;
            }
            if (!myitem[variable]) {
                return false;
            }
            if (CSL.NUMERIC_VARIABLES.indexOf(variable) > -1) {
                if (!state.tmp.shadow_numbers[variable]) {
                    state.processNumber(false, myitem, variable, Item.type);
                }
                if (state.tmp.shadow_numbers[variable].numeric) {
                    return true;
                }
            } else if ([ "title", "version" ].indexOf(variable) > -1) {
                if (myitem[variable].slice(-1) === "" + parseInt(myitem[variable].slice(-1), 10)) {
                    return true;
                }
            }
            return false;
        };
    };
    for (var i = 0; i < variables.length; i += 1) {
        this.tests.push(maketest(variables[i]));
    }
};

CSL.Attributes["@is-uncertain-date"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var variables = arg.split(/\s+/);
    var maketest = function maketest(myvariable) {
        return function(Item) {
            if (Item[myvariable] && Item[myvariable].circa) {
                return true;
            } else {
                return false;
            }
        };
    };
    for (var i = 0, ilen = variables.length; i < ilen; i += 1) {
        this.tests.push(maketest(variables[i]));
    }
};

CSL.Attributes["@locator"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var trylabels = arg.replace("sub verbo", "sub-verbo");
    trylabels = trylabels.split(/\s+/);
    var maketest = function maketest(trylabel) {
        return function(Item, item) {
            var label;
            state.processNumber(false, item, "locator");
            label = state.tmp.shadow_numbers.locator.label;
            if (label && trylabel === label) {
                return true;
            } else {
                return false;
            }
        };
    };
    for (var i = 0, ilen = trylabels.length; i < ilen; i += 1) {
        this.tests.push(maketest(trylabels[i]));
    }
};

CSL.Attributes["@position"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var tryposition;
    state.opt.update_mode = CSL.POSITION;
    var trypositions = arg.split(/\s+/);
    var testSubsequentNear = function testSubsequentNear(Item, item) {
        if (item && CSL.POSITION_MAP[item.position] >= CSL.POSITION_MAP[CSL.POSITION_SUBSEQUENT] && item["near-note"]) {
            return true;
        }
        return false;
    };
    var testSubsequentNotNear = function testSubsequentNotNear(Item, item) {
        if (item && CSL.POSITION_MAP[item.position] == CSL.POSITION_MAP[CSL.POSITION_SUBSEQUENT] && !item["near-note"]) {
            return true;
        }
        return false;
    };
    var maketest = function maketest(tryposition) {
        return function(Item, item) {
            if (state.tmp.area === "bibliography") {
                return false;
            }
            if (item && "undefined" === typeof item.position) {
                item.position = 0;
            }
            if (item && typeof item.position === "number") {
                if (item.position === 0 && tryposition === 0) {
                    return true;
                } else if (tryposition > 0 && CSL.POSITION_MAP[item.position] >= CSL.POSITION_MAP[tryposition]) {
                    return true;
                }
            } else if (tryposition === 0) {
                return true;
            }
            return false;
        };
    };
    for (var i = 0, ilen = trypositions.length; i < ilen; i += 1) {
        var tryposition = trypositions[i];
        if (tryposition === "first") {
            tryposition = CSL.POSITION_FIRST;
        } else if (tryposition === "container-subsequent") {
            tryposition = CSL.POSITION_CONTAINER_SUBSEQUENT;
        } else if (tryposition === "subsequent") {
            tryposition = CSL.POSITION_SUBSEQUENT;
        } else if (tryposition === "ibid") {
            tryposition = CSL.POSITION_IBID;
        } else if (tryposition === "ibid-with-locator") {
            tryposition = CSL.POSITION_IBID_WITH_LOCATOR;
        }
        if ("near-note" === tryposition) {
            this.tests.push(testSubsequentNear);
        } else if ("far-note" === tryposition) {
            this.tests.push(testSubsequentNotNear);
        } else {
            this.tests.push(maketest(tryposition));
        }
    }
};

CSL.Attributes["@type"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var types = arg.split(/\s+/);
    var maketest = function maketest(mytype) {
        return function(Item) {
            var ret = Item.type === mytype;
            if (ret) {
                return true;
            } else {
                return false;
            }
        };
    };
    var tests = [];
    for (var i = 0, ilen = types.length; i < ilen; i += 1) {
        tests.push(maketest(types[i]));
    }
    this.tests.push(state.fun.match.any(this, state, tests));
};

CSL.Attributes["@variable"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var func;
    this.variables = arg.split(/\s+/);
    this.variables_real = this.variables.slice();
    if ("label" === this.name && this.variables[0]) {
        this.strings.term = this.variables[0];
    } else if ([ "names", "date", "text", "number" ].indexOf(this.name) > -1) {
        func = function func(state, Item, item) {
            for (var i = this.variables.length - 1; i > -1; i += -1) {
                this.variables.pop();
            }
            for (var i = 0, ilen = this.variables_real.length; i < ilen; i++) {
                if (state.tmp.done_vars.indexOf(this.variables_real[i]) === -1) {
                    this.variables.push(this.variables_real[i]);
                }
                if (state.tmp.can_block_substitute) {
                    state.tmp.done_vars.push(this.variables_real[i]);
                }
            }
        };
        this.execs.push(func);
        func = function func(state, Item, item) {
            var output = false;
            for (var i = 0, ilen = this.variables.length; i < ilen; i++) {
                var variable = this.variables[i];
                if ([ "authority", "committee" ].indexOf(variable) > -1 && "string" === typeof Item[variable] && "names" === this.name) {
                    var isValid = true;
                    var rawNames = Item[variable].split(/\s*;\s*/);
                    var rawMultiNames = {};
                    if (Item.multi && Item.multi._keys[variable]) {
                        for (var langTag in Item.multi._keys[variable]) {
                            rawMultiNames[langTag] = Item.multi._keys[variable][langTag].split(/\s*;\s*/);
                            if (rawMultiNames[langTag].length !== rawNames.length) {
                                isValid = false;
                                break;
                            }
                        }
                    }
                    if (!isValid) {
                        rawNames = [ Item[variable] ];
                        rawMultiNames = Item.multi._keys[variable];
                    }
                    for (var j = 0, jlen = rawNames.length; j < jlen; j++) {
                        var creatorParent = {
                            literal: rawNames[j],
                            multi: {
                                _key: {}
                            }
                        };
                        for (var langTag in rawMultiNames) {
                            var creatorChild = {
                                literal: rawMultiNames[langTag][j]
                            };
                            creatorParent.multi._key[langTag] = creatorChild;
                        }
                        rawNames[j] = creatorParent;
                    }
                    Item[variable] = rawNames;
                }
                if (this.strings.form === "short" && !Item[variable]) {
                    if (variable === "title") {
                        variable = "title-short";
                    } else if (variable === "container-title") {
                        variable = "container-title-short";
                    }
                }
                if (variable === "year-suffix") {
                    output = true;
                    break;
                } else if (CSL.DATE_VARIABLES.indexOf(variable) > -1) {
                    if (state.opt.development_extensions.locator_date_and_revision && "locator-date" === variable) {
                        output = true;
                        break;
                    }
                    if (Item[variable]) {
                        for (var key in Item[variable]) {
                            if (this.dateparts.indexOf(key) === -1 && "literal" !== key) {
                                continue;
                            }
                            if (Item[variable][key]) {
                                output = true;
                                break;
                            }
                        }
                        if (output) {
                            break;
                        }
                    }
                } else if ("locator" === variable) {
                    if (item && item.locator) {
                        output = true;
                    }
                    break;
                } else if ("locator-extra" === variable) {
                    if (item && item["locator-extra"]) {
                        output = true;
                    }
                    break;
                } else if ([ "citation-number", "citation-label" ].indexOf(variable) > -1) {
                    output = true;
                    break;
                } else if ("first-reference-note-number" === variable) {
                    if (item && item["first-reference-note-number"]) {
                        output = true;
                    }
                    break;
                } else if ("first-container-reference-note-number" === variable) {
                    if (item && item["first-container-reference-note-number"]) {
                        output = true;
                    }
                    break;
                } else if ("hereinafter" === variable) {
                    if (state.transform.abbrevs["default"].hereinafter[Item.id] && state.sys.getAbbreviation && Item.id) {
                        output = true;
                    }
                    break;
                } else if ("object" === typeof Item[variable]) {
                    break;
                } else if ("string" === typeof Item[variable] && Item[variable]) {
                    output = true;
                    break;
                } else if ("number" === typeof Item[variable]) {
                    output = true;
                    break;
                }
                if (output) {
                    break;
                }
            }
            if (output) {
                for (var i = 0, ilen = this.variables_real.length; i < ilen; i++) {
                    var variable = this.variables_real[i];
                    if (variable !== "citation-number" || state.tmp.area !== "bibliography") {
                        state.tmp.cite_renders_content = true;
                    }
                    state.tmp.group_context.tip.variable_success = true;
                    if (state.tmp.can_substitute.value() && state.tmp.area === "bibliography" && "string" === typeof Item[variable]) {
                        state.tmp.name_node.top = state.output.current.value();
                        state.tmp.rendered_name.push(Item[variable]);
                    }
                }
                state.tmp.can_substitute.replace(false, CSL.LITERAL);
            } else {
                state.tmp.group_context.tip.variable_attempt = true;
            }
        };
        this.execs.push(func);
    } else if ([ "if", "else-if", "condition" ].indexOf(this.name) > -1) {
        var maketest = function maketest(variable) {
            return function(Item, item) {
                var myitem = Item;
                if (item && [ "locator", "locator-extra", "first-reference-note-number", "first-container-reference-note-number", "locator-date" ].indexOf(variable) > -1) {
                    myitem = item;
                }
                if (variable === "hereinafter" && state.sys.getAbbreviation && myitem.id) {
                    if (state.transform.abbrevs["default"].hereinafter[myitem.id]) {
                        return true;
                    }
                } else if (myitem[variable]) {
                    if ("number" === typeof myitem[variable] || "string" === typeof myitem[variable]) {
                        return true;
                    } else if ("object" === typeof myitem[variable]) {
                        for (var key in myitem[variable]) {
                            if (myitem[variable][key]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            };
        };
        for (var i = 0, ilen = this.variables.length; i < ilen; i += 1) {
            this.tests.push(maketest(this.variables[i]));
        }
    }
};

CSL.Attributes["@page"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var trylabels = arg.replace("sub verbo", "sub-verbo");
    trylabels = trylabels.split(/\s+/);
    var maketest = function maketest(trylabel) {
        return function(Item) {
            var label;
            state.processNumber(false, Item, "page", Item.type);
            if (!state.tmp.shadow_numbers.page.label) {
                label = "page";
            } else if (state.tmp.shadow_numbers.page.label === "sub verbo") {
                label = "sub-verbo";
            } else {
                label = state.tmp.shadow_numbers.page.label;
            }
            if (state.tmp.shadow_numbers.page.values.length > 0) {
                if (state.tmp.shadow_numbers.page.values[0].gotosleepability) {
                    state.tmp.shadow_numbers.page.values[0].labelVisibility = false;
                }
            }
            if (trylabel === label) {
                return true;
            } else {
                return false;
            }
        };
    };
    for (var i = 0, ilen = trylabels.length; i < ilen; i += 1) {
        this.tests.push(maketest(trylabels[i]));
    }
};

CSL.Attributes["@number"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var trylabels = arg.split(/\s+/);
    var maketest = function maketest(trylabel) {
        return function(Item) {
            var label;
            state.processNumber(false, Item, "number", Item.type);
            if (!state.tmp.shadow_numbers.number.label) {
                label = "number";
            } else {
                label = state.tmp.shadow_numbers.number.label;
            }
            if (trylabel === label) {
                return true;
            } else {
                return false;
            }
        };
    };
    for (var i = 0, ilen = trylabels.length; i < ilen; i += 1) {
        this.tests.push(maketest(trylabels[i]));
    }
};

CSL.Attributes["@jurisdiction"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var tryjurisdictions = arg.split(/\s+/);
    var maketests = function maketests(tryjurisdictions) {
        return function(Item) {
            if (!Item.jurisdiction) {
                return false;
            }
            var jurisdiction = Item.jurisdiction;
            for (var i = 0, ilen = tryjurisdictions.length; i < ilen; i++) {
                if (jurisdiction === tryjurisdictions[i]) {
                    return true;
                }
            }
            return false;
        };
    };
    this.tests.push(maketests(tryjurisdictions));
};

CSL.Attributes["@country"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var trycountries = arg.split(/\s+/);
    var maketests = function maketests(trycountries) {
        return function(Item) {
            if (!Item.country) {
                return false;
            }
            var country = Item.country;
            for (var i = 0, ilen = trycountries.length; i < ilen; i++) {
                if (country === trycountries[i]) {
                    return true;
                }
            }
            return false;
        };
    };
    this.tests.push(maketests(trycountries));
};

CSL.Attributes["@context"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var func = function func() {
        if ([ "bibliography", "citation" ].indexOf(arg) > -1) {
            var area = state.tmp.area.slice(0, arg.length);
            if (area === arg) {
                return true;
            }
            return false;
        } else if ("alternative" === arg) {
            return !!state.tmp.abort_alternative;
        }
    };
    this.tests.push(func);
};

CSL.Attributes["@has-year-only"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var trydates = arg.split(/\s+/);
    var maketest = function maketest(trydate) {
        return function(Item) {
            var date = Item[trydate];
            if (!date || date.month || date.season) {
                return false;
            } else {
                return true;
            }
        };
    };
    for (var i = 0, ilen = trydates.length; i < ilen; i += 1) {
        this.tests.push(maketest(trydates[i]));
    }
};

CSL.Attributes["@has-to-month-or-season"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var trydates = arg.split(/\s+/);
    var maketest = function maketest(trydate) {
        return function(Item) {
            var date = Item[trydate];
            if (!date || !date.month && !date.season || date.day) {
                return false;
            } else {
                return true;
            }
        };
    };
    for (var i = 0, ilen = trydates.length; i < ilen; i += 1) {
        this.tests.push(maketest(trydates[i]));
    }
};

CSL.Attributes["@has-day"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var trydates = arg.split(/\s+/);
    var maketest = function maketest(trydate) {
        return function(Item) {
            var date = Item[trydate];
            if (!date || !date.day) {
                return false;
            } else {
                return true;
            }
        };
    };
    for (var i = 0, ilen = trydates.length; i < ilen; i += 1) {
        this.tests.push(maketest(trydates[i]));
    }
};

CSL.Attributes["@is-plural"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var func = function func(Item) {
        var nameList = Item[arg];
        if (nameList && nameList.length) {
            var persons = 0;
            var institutions = 0;
            var last_is_person = false;
            for (var i = 0, ilen = nameList.length; i < ilen; i += 1) {
                if (state.opt.development_extensions.spoof_institutional_affiliations && (nameList[i].literal || nameList[i].isInstitution && nameList[i].family && !nameList[i].given)) {
                    institutions += 1;
                    last_is_person = false;
                } else {
                    persons += 1;
                    last_is_person = true;
                }
            }
            if (persons > 1) {
                return true;
            } else if (institutions > 1) {
                return true;
            } else if (institutions && last_is_person) {
                return true;
            }
        }
        return false;
    };
    this.tests.push(func);
};

CSL.Attributes["@is-multiple"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var func = function func(Item) {
        var val = "" + Item[arg];
        var lst = val.split(/(?:,\s|\s(?:tot\sen\smet|līdz|oraz|and|bis|έως|και|och|až|do|en|et|in|ir|ja|og|sa|to|un|und|és|și|i|u|y|à|e|a|и|-|–)\s|—|\&)/);
        if (lst.length > 1) {
            return true;
        }
        return false;
    };
    this.tests.push(func);
};

CSL.Attributes["@locale"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var langspec, lang, lst, i, ilen;
    var locale_default = state.opt["default-locale"][0];
    if (this.name === "layout") {
        this.locale_raw = arg;
        if (this.tokentype === CSL.START) {
            if (!state.opt.multi_layout) {
                state.opt.multi_layout = [];
            }
            var locale_data = [];
            var locales = arg.split(/\s+/);
            var sort_locale = {};
            var localeMaster = CSL.localeResolve(locales[0], locale_default);
            locale_data.push(localeMaster);
            if (localeMaster.generic) {
                sort_locale[localeMaster.generic] = localeMaster.best;
            } else {
                sort_locale[localeMaster.best] = localeMaster.best;
            }
            for (var i = 1, ilen = locales.length; i < ilen; i += 1) {
                var localeServant = CSL.localeResolve(locales[i], locale_default);
                locale_data.push(localeServant);
                if (localeServant.generic) {
                    sort_locale[localeServant.generic] = localeMaster.best;
                } else {
                    sort_locale[localeServant.best] = localeMaster.best;
                }
            }
            state[state.build.area].opt.sort_locales.push(sort_locale);
            state.opt.multi_layout.push(locale_data);
        }
        state.opt.has_layout_locale = true;
    } else {
        lst = arg.split(/\s+/);
        var locale_bares = [];
        for (i = 0, ilen = lst.length; i < ilen; i += 1) {
            lang = lst[i];
            langspec = CSL.localeResolve(lang, locale_default);
            if (lst[i].length === 2) {
                locale_bares.push(langspec.bare);
            }
            state.localeConfigure(langspec, true);
            lst[i] = langspec;
        }
        var locale_list = lst.slice();
        var maketest = function maketest(locale_list, locale_default, locale_bares) {
            return function(Item) {
                var res;
                res = false;
                var langspec = false;
                var lang;
                if (!Item.language) {
                    lang = locale_default;
                } else {
                    lang = Item.language;
                }
                langspec = CSL.localeResolve(lang, locale_default);
                for (i = 0, ilen = locale_list.length; i < ilen; i += 1) {
                    if (langspec.best === locale_list[i].best) {
                        state.tmp.condition_lang_counter_arr.push(state.tmp.condition_counter);
                        state.tmp.condition_lang_val_arr.push(state.opt.lang);
                        state.opt.lang = locale_list[0].best;
                        res = true;
                        break;
                    }
                }
                if (!res && locale_bares.indexOf(langspec.bare) > -1) {
                    state.tmp.condition_lang_counter_arr.push(state.tmp.condition_counter);
                    state.tmp.condition_lang_val_arr.push(state.opt.lang);
                    state.opt.lang = locale_list[0].best;
                    res = true;
                }
                return res;
            };
        };
        this.tests.push(maketest(locale_list, locale_default, locale_bares));
    }
};

CSL.Attributes["@alternative-node-internal"] = function(state) {
    if (!this.tests) {
        this.tests = [];
    }
    var maketest = function maketest() {
        return function() {
            return !state.tmp.abort_alternative;
        };
    };
    this.tests.push(maketest());
};

CSL.Attributes["@locale-internal"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var langspec, lang, lst, i, ilen;
    lst = arg.split(/\s+/);
    this.locale_bares = [];
    for (i = 0, ilen = lst.length; i < ilen; i += 1) {
        lang = lst[i];
        langspec = CSL.localeResolve(lang, state.opt["default-locale"][0]);
        if (lst[i].length === 2) {
            this.locale_bares.push(langspec.bare);
        }
        state.localeConfigure(langspec);
        lst[i] = langspec;
    }
    this.locale_default = state.opt["default-locale"][0];
    this.locale = lst[0].best;
    this.locale_list = lst.slice();
    var maketest = function maketest(me) {
        return function(Item) {
            var res;
            res = false;
            var langspec = false;
            if (Item.language) {
                lang = Item.language;
                langspec = CSL.localeResolve(lang, state.opt["default-locale"][0]);
                if (langspec.best === state.opt["default-locale"][0]) {
                    langspec = false;
                }
            }
            if (langspec) {
                for (i = 0, ilen = me.locale_list.length; i < ilen; i += 1) {
                    if (langspec.best === me.locale_list[i].best) {
                        state.opt.lang = me.locale;
                        state.tmp.last_cite_locale = me.locale;
                        state.output.openLevel("empty");
                        state.output.current.value().new_locale = me.locale;
                        res = true;
                        break;
                    }
                }
                if (!res && me.locale_bares.indexOf(langspec.bare) > -1) {
                    state.opt.lang = me.locale;
                    state.tmp.last_cite_locale = me.locale;
                    state.output.openLevel("empty");
                    state.output.current.value().new_locale = me.locale;
                    res = true;
                }
            }
            return res;
        };
    };
    var me = this;
    this.tests.push(maketest(me));
};

CSL.Attributes["@court-class"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var tryclasses = arg.split(/\s+/);
    var maketest = function maketest(tryclass) {
        return function(Item) {
            var cls = CSL.GET_COURT_CLASS(state, Item);
            if (cls === tryclass) {
                return true;
            } else {
                return false;
            }
        };
    };
    for (var i = 0, ilen = tryclasses.length; i < ilen; i++) {
        this.tests.push(maketest(tryclasses[i]));
    }
};

CSL.Attributes["@container-multiple"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var retval = "true" === arg ? true : false;
    var maketest = function maketest(retval) {
        return function(Item) {
            if (!state.tmp.container_item_count[Item.container_id]) {
                return !retval;
            } else if (state.tmp.container_item_count[Item.container_id] > 1) {
                return retval;
            }
            return !retval;
        };
    };
    this.tests.push(maketest(retval));
};

CSL.Attributes["@container-subsequent"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var retval = "true" === arg ? true : false;
    var maketest = function maketest(retval) {
        return function(Item) {
            if (state.tmp.container_item_pos[Item.container_id] > 1) {
                return retval;
            }
            return !retval;
        };
    };
    this.tests.push(maketest(retval));
};

CSL.Attributes["@has-subunit"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var maketest = function maketest(namevar) {
        return function(Item) {
            var subunit_count = 0;
            for (var i in Item[namevar]) {
                var name = Item[namevar][i];
                if (!name.given) {
                    var institution = name.literal ? name.literal : name.family;
                    var length = institution.split("|").length;
                    if (subunit_count === 0 || length < subunit_count) {
                        subunit_count = length;
                    }
                }
            }
            return subunit_count > 1;
        };
    };
    this.tests.push(maketest(arg));
};

CSL.Attributes["@cite-form"] = function(state, arg) {
    if (!this.tests) {
        this.tests = [];
    }
    var maketest = function maketest(citeForm) {
        return function(Item) {
            if (Item["cite-form"] === citeForm) {
                return true;
            }
            return false;
        };
    };
    this.tests.push(maketest(arg));
};

CSL.Attributes["@disable-duplicate-year-suppression"] = function(state, arg) {
    state.opt.disable_duplicate_year_suppression = arg.split(/\s+/);
};

CSL.Attributes["@consolidate-containers"] = function(state, arg) {
    CSL.Attributes["@track-containers"](state, arg);
    var args = arg.split(/\s+/);
    state.bibliography.opt.consolidate_containers = args;
};

CSL.Attributes["@track-containers"] = function(state, arg) {
    var args = arg.split(/\s+/);
    if (!state.bibliography.opt.track_container_items) {
        state.bibliography.opt.track_container_items = [];
    }
    if (!state.bibliography.opt.consolidate_containers) {
        state.bibliography.opt.consolidate_containers = [];
    }
    state.bibliography.opt.track_container_items = state.bibliography.opt.track_container_items.concat(args);
};

CSL.Attributes["@parallel-first"] = function(state, arg) {
    state.opt.parallel.enable = true;
    var vars = arg.split(/\s+/);
    if (!state.opt.track_repeat) {
        state.opt.track_repeat = {};
    }
    this.parallel_first = {};
    for (var i in vars) {
        var v = vars[i];
        this.parallel_first[v] = true;
        state.opt.track_repeat[v] = true;
    }
};

CSL.Attributes["@parallel-last"] = function(state, arg) {
    state.opt.parallel.enable = true;
    var vars = arg.split(/\s+/);
    if (!state.opt.track_repeat) {
        state.opt.track_repeat = {};
    }
    this.parallel_last = {};
    for (var i in vars) {
        var v = vars[i];
        this.parallel_last[v] = true;
        state.opt.track_repeat[v] = true;
    }
};

CSL.Attributes["@parallel-last-to-first"] = function(state, arg) {
    state.opt.parallel.enable = true;
    var vars = arg.split(/\s+/);
    this.parallel_last_to_first = {};
    for (var i = 0, ilen = vars.length; i < ilen; i++) {
        this.parallel_last_to_first[vars[i]] = true;
    }
};

CSL.Attributes["@parallel-delimiter-override"] = function(state, arg) {
    state.opt.parallel.enable = true;
    this.strings.set_parallel_delimiter_override = arg;
};

CSL.Attributes["@parallel-delimiter-override-on-suppress"] = function(state, arg) {
    state.opt.parallel.enable = true;
    this.strings.set_parallel_delimiter_override_on_suppress = arg;
};

CSL.Attributes["@no-repeat"] = function(state, arg) {
    state.opt.parallel.enable = true;
    var vars = arg.split(/\s+/);
    if (!state.opt.track_repeat) {
        state.opt.track_repeat = {};
    }
    this.non_parallel = {};
    for (var i in vars) {
        var v = vars[i];
        this.non_parallel[v] = true;
        state.opt.track_repeat[v] = true;
    }
};

CSL.Attributes["@require"] = function(state, arg) {
    state.opt.use_context_condition = true;
    this.strings.require = arg;
};

CSL.Attributes["@reject"] = function(state, arg) {
    state.opt.use_context_condition = true;
    this.strings.reject = arg;
};

CSL.Attributes["@require-comma-on-symbol"] = function(state, arg) {
    state.opt.require_comma_on_symbol = arg;
};

CSL.Attributes["@gender"] = function(state, arg) {
    this.gender = arg;
};

CSL.Attributes["@cslid"] = function(state, arg) {
    this.cslid = parseInt(arg, 10);
};

CSL.Attributes["@capitalize-if-first"] = function(state, arg) {
    this.strings.capitalize_if_first_override = arg;
};

CSL.Attributes["@label-capitalize-if-first"] = function(state, arg) {
    this.strings.label_capitalize_if_first_override = arg;
};

CSL.Attributes["@label-form"] = function(state, arg) {
    this.strings.label_form_override = arg;
};

CSL.Attributes["@part-separator"] = function(state, arg) {
    this.strings["part-separator"] = arg;
};

CSL.Attributes["@leading-noise-words"] = function(state, arg) {
    this["leading-noise-words"] = arg;
};

CSL.Attributes["@name-never-short"] = function(state, arg) {
    this["name-never-short"] = arg;
};

CSL.Attributes["@class"] = function(state, arg) {
    state.opt["class"] = arg;
};

CSL.Attributes["@version"] = function(state, arg) {
    state.opt.version = arg;
};

CSL.Attributes["@value"] = function(state, arg) {
    this.strings.value = arg;
};

CSL.Attributes["@name"] = function(state, arg) {
    this.strings.name = arg;
};

CSL.Attributes["@form"] = function(state, arg) {
    this.strings.form = arg;
};

CSL.Attributes["@date-parts"] = function(state, arg) {
    this.strings["date-parts"] = arg;
};

CSL.Attributes["@range-delimiter"] = function(state, arg) {
    this.strings["range-delimiter"] = arg;
};

CSL.Attributes["@macro"] = function(state, arg) {
    this.postponed_macro = arg;
};

CSL.Attributes["@term"] = function(state, arg) {
    if (arg === "sub verbo") {
        this.strings.term = "sub-verbo";
    } else {
        this.strings.term = arg;
    }
};

CSL.Attributes["@xmlns"] = function() {};

CSL.Attributes["@lang"] = function(state, arg) {
    if (arg) {
        state.build.lang = arg;
    }
};

CSL.Attributes["@lingo"] = function() {};

CSL.Attributes["@macro-has-date"] = function() {
    this["macro-has-date"] = true;
};

CSL.Attributes["@suffix"] = function(state, arg) {
    this.strings.suffix = arg;
};

CSL.Attributes["@prefix"] = function(state, arg) {
    this.strings.prefix = arg;
};

CSL.Attributes["@delimiter"] = function(state, arg) {
    this.strings.delimiter = arg;
};

CSL.Attributes["@match"] = function(state, arg) {
    this.match = arg;
};

CSL.Attributes["@names-min"] = function(state, arg) {
    var val = parseInt(arg, 10);
    if (state[state.build.area].opt.max_number_of_names < val) {
        state[state.build.area].opt.max_number_of_names = val;
    }
    this.strings["et-al-min"] = val;
};

CSL.Attributes["@names-use-first"] = function(state, arg) {
    this.strings["et-al-use-first"] = parseInt(arg, 10);
};

CSL.Attributes["@names-use-last"] = function(state, arg) {
    if (arg === "true") {
        this.strings["et-al-use-last"] = true;
    } else {
        this.strings["et-al-use-last"] = false;
    }
};

CSL.Attributes["@sort"] = function(state, arg) {
    if (arg === "descending") {
        this.strings.sort_direction = CSL.DESCENDING;
    }
};

CSL.Attributes["@plural"] = function(state, arg) {
    if ("always" === arg || "true" === arg) {
        this.strings.plural = 1;
    } else if ("never" === arg || "false" === arg) {
        this.strings.plural = 0;
    } else if ("contextual" === arg) {
        this.strings.plural = false;
    }
};

CSL.Attributes["@has-publisher-and-publisher-place"] = function() {
    this.strings["has-publisher-and-publisher-place"] = true;
};

CSL.Attributes["@publisher-delimiter-precedes-last"] = function(state, arg) {
    this.strings["publisher-delimiter-precedes-last"] = arg;
};

CSL.Attributes["@publisher-delimiter"] = function(state, arg) {
    this.strings["publisher-delimiter"] = arg;
};

CSL.Attributes["@publisher-and"] = function(state, arg) {
    this.strings["publisher-and"] = arg;
};

CSL.Attributes["@givenname-disambiguation-rule"] = function(state, arg) {
    if (CSL.GIVENNAME_DISAMBIGUATION_RULES.indexOf(arg) > -1) {
        state.citation.opt["givenname-disambiguation-rule"] = arg;
    }
};

CSL.Attributes["@collapse"] = function(state, arg) {
    if (arg) {
        state[this.name].opt.collapse = arg;
    }
};

CSL.Attributes["@cite-group-delimiter"] = function(state, arg) {
    if (arg) {
        state[state.tmp.area].opt.cite_group_delimiter = arg;
    }
};

CSL.Attributes["@names-delimiter"] = function(state, arg) {
    state.setOpt(this, "names-delimiter", arg);
};

CSL.Attributes["@name-form"] = function(state, arg) {
    state.setOpt(this, "name-form", arg);
};

CSL.Attributes["@subgroup-delimiter"] = function(state, arg) {
    this.strings["subgroup-delimiter"] = arg;
};

CSL.Attributes["@subgroup-delimiter-precedes-last"] = function(state, arg) {
    this.strings["subgroup-delimiter-precedes-last"] = arg;
};

CSL.Attributes["@name-delimiter"] = function(state, arg) {
    state.setOpt(this, "name-delimiter", arg);
};

CSL.Attributes["@et-al-min"] = function(state, arg) {
    var val = parseInt(arg, 10);
    if (state[state.build.area].opt.max_number_of_names < val) {
        state[state.build.area].opt.max_number_of_names = val;
    }
    state.setOpt(this, "et-al-min", val);
};

CSL.Attributes["@et-al-use-first"] = function(state, arg) {
    state.setOpt(this, "et-al-use-first", parseInt(arg, 10));
};

CSL.Attributes["@et-al-use-last"] = function(state, arg) {
    if (arg === "true") {
        state.setOpt(this, "et-al-use-last", true);
    } else {
        state.setOpt(this, "et-al-use-last", false);
    }
};

CSL.Attributes["@et-al-subsequent-min"] = function(state, arg) {
    var val = parseInt(arg, 10);
    if (state[state.build.area].opt.max_number_of_names < val) {
        state[state.build.area].opt.max_number_of_names = val;
    }
    state.setOpt(this, "et-al-subsequent-min", val);
};

CSL.Attributes["@et-al-subsequent-use-first"] = function(state, arg) {
    state.setOpt(this, "et-al-subsequent-use-first", parseInt(arg, 10));
};

CSL.Attributes["@suppress-min"] = function(state, arg) {
    this.strings["suppress-min"] = parseInt(arg, 10);
};

CSL.Attributes["@suppress-max"] = function(state, arg) {
    this.strings["suppress-max"] = parseInt(arg, 10);
};

CSL.Attributes["@and"] = function(state, arg) {
    state.setOpt(this, "and", arg);
};

CSL.Attributes["@delimiter-precedes-last"] = function(state, arg) {
    state.setOpt(this, "delimiter-precedes-last", arg);
};

CSL.Attributes["@delimiter-precedes-et-al"] = function(state, arg) {
    state.setOpt(this, "delimiter-precedes-et-al", arg);
};

CSL.Attributes["@initialize-with"] = function(state, arg) {
    state.setOpt(this, "initialize-with", arg);
};

CSL.Attributes["@initialize"] = function(state, arg) {
    if (arg === "false") {
        state.setOpt(this, "initialize", false);
    }
};

CSL.Attributes["@name-as-reverse-order"] = function(state, arg) {
    this["name-as-reverse-order"] = arg;
};

CSL.Attributes["@name-as-sort-order"] = function(state, arg) {
    if (this.name === "style-options") {
        this["name-as-sort-order"] = arg;
    } else {
        state.setOpt(this, "name-as-sort-order", arg);
    }
};

CSL.Attributes["@sort-separator"] = function(state, arg) {
    state.setOpt(this, "sort-separator", arg);
};

CSL.Attributes["@require-match"] = function(state, arg) {
    if (arg === "true") {
        this.requireMatch = true;
    }
};

CSL.Attributes["@exclude-types"] = function(state, arg) {
    state.bibliography.opt.exclude_types = arg.split(/\s+/);
};

CSL.Attributes["@exclude-with-fields"] = function(state, arg) {
    state.bibliography.opt.exclude_with_fields = arg.split(/\s+/);
};

CSL.Attributes["@year-suffix-delimiter"] = function(state, arg) {
    state[this.name].opt["year-suffix-delimiter"] = arg;
};

CSL.Attributes["@after-collapse-delimiter"] = function(state, arg) {
    state[this.name].opt["after-collapse-delimiter"] = arg;
};

CSL.Attributes["@subsequent-author-substitute"] = function(state, arg) {
    state[this.name].opt["subsequent-author-substitute"] = arg;
};

CSL.Attributes["@subsequent-author-substitute-rule"] = function(state, arg) {
    state[this.name].opt["subsequent-author-substitute-rule"] = arg;
};

CSL.Attributes["@disambiguate-add-names"] = function(state, arg) {
    if (arg === "true") {
        state.opt["disambiguate-add-names"] = true;
    }
};

CSL.Attributes["@disambiguate-add-givenname"] = function(state, arg) {
    if (arg === "true") {
        state.opt["disambiguate-add-givenname"] = true;
    }
};

CSL.Attributes["@disambiguate-add-year-suffix"] = function(state, arg) {
    if (arg === "true" && state.opt.xclass !== "numeric") {
        state.opt["disambiguate-add-year-suffix"] = true;
    }
};

CSL.Attributes["@second-field-align"] = function(state, arg) {
    if (arg === "flush" || arg === "margin") {
        state[this.name].opt["second-field-align"] = arg;
    }
};

CSL.Attributes["@hanging-indent"] = function(state, arg) {
    if (arg === "true") {
        if (state.opt.development_extensions.hanging_indent_legacy_number) {
            state[this.name].opt.hangingindent = 2;
        } else {
            state[this.name].opt.hangingindent = true;
        }
    }
};

CSL.Attributes["@line-spacing"] = function(state, arg) {
    if (arg && arg.match(/^[.0-9]+$/)) {
        state[this.name].opt["line-spacing"] = parseFloat(arg, 10);
    }
};

CSL.Attributes["@entry-spacing"] = function(state, arg) {
    if (arg && arg.match(/^[.0-9]+$/)) {
        state[this.name].opt["entry-spacing"] = parseFloat(arg, 10);
    }
};

CSL.Attributes["@near-note-distance"] = function(state, arg) {
    state[this.name].opt["near-note-distance"] = parseInt(arg, 10);
};

CSL.Attributes["@substring"] = function(state, arg) {
    this.substring = parseInt(arg, 10);
};

CSL.Attributes["@text-case"] = function(state, arg) {
    var func = function func(state, Item) {
        if (arg === "normal") {
            this.text_case_normal = true;
        } else {
            this.strings["text-case"] = arg;
            if (arg === "title") {
                if (Item.jurisdiction) {
                    this.strings["text-case"] = "passthrough";
                }
            }
        }
    };
    this.execs.push(func);
};

CSL.Attributes["@page-range-format"] = function(state, arg) {
    state.opt["page-range-format"] = arg;
};

CSL.Attributes["@year-range-format"] = function(state, arg) {
    state.opt["year-range-format"] = arg;
};

CSL.Attributes["@default-locale"] = function(state, arg) {
    if (this.name === "style") {
        var lst, len, pos, m, ret;
        var m = arg.match(/-x-(sort|translit|translat)-/g);
        if (m) {
            for (pos = 0, len = m.length; pos < len; pos += 1) {
                m[pos] = m[pos].replace(/^-x-/, "").replace(/-$/, "");
            }
        }
        lst = arg.split(/-x-(?:sort|translit|translat)-/);
        ret = [ lst[0] ];
        for (pos = 1, len = lst.length; pos < len; pos += 1) {
            ret.push(m[pos - 1]);
            ret.push(lst[pos]);
        }
        lst = ret.slice();
        len = lst.length;
        for (pos = 1; pos < len; pos += 2) {
            state.opt["locale-" + lst[pos]].push(lst[pos + 1].replace(/^\s*/g, "").replace(/\s*$/g, ""));
        }
        if (lst.length) {
            state.opt["default-locale"] = lst.slice(0, 1);
        } else {
            state.opt["default-locale"] = [ "en" ];
        }
    } else if (arg === "true") {
        this.default_locale = true;
    }
};

CSL.Attributes["@default-locale-sort"] = function(state, arg) {
    state.opt["default-locale-sort"] = arg;
};

CSL.Attributes["@demote-non-dropping-particle"] = function(state, arg) {
    state.opt["demote-non-dropping-particle"] = arg;
};

CSL.Attributes["@initialize-with-hyphen"] = function(state, arg) {
    if (arg === "false") {
        state.opt["initialize-with-hyphen"] = false;
    }
};

CSL.Attributes["@institution-parts"] = function(state, arg) {
    this.strings["institution-parts"] = arg;
};

CSL.Attributes["@if-short"] = function(state, arg) {
    if (arg === "true") {
        this.strings["if-short"] = true;
    }
};

CSL.Attributes["@substitute-use-first"] = function(state, arg) {
    this.strings["substitute-use-first"] = parseInt(arg, 10);
};

CSL.Attributes["@use-first"] = function(state, arg) {
    this.strings["use-first"] = parseInt(arg, 10);
};

CSL.Attributes["@use-last"] = function(state, arg) {
    this.strings["use-last"] = parseInt(arg, 10);
};

CSL.Attributes["@stop-first"] = function(state, arg) {
    this.strings["stop-first"] = parseInt(arg, 10);
};

CSL.Attributes["@stop-last"] = function(state, arg) {
    this.strings["stop-last"] = parseInt(arg, 10) * -1;
};

CSL.Attributes["@reverse-order"] = function(state, arg) {
    if ("true" === arg) {
        this.strings["reverse-order"] = true;
    }
};

CSL.Attributes["@display"] = function(state, arg) {
    if (state.bibliography.tokens.length === 2) {
        state.opt.using_display = true;
    }
    this.strings.cls = arg;
};

CSL.Stack = function(val, literal) {
    this.mystack = [];
    if (literal || val) {
        this.mystack.push(val);
    }
    this.tip = this.mystack[0];
};

CSL.Stack.prototype.push = function(val, literal) {
    if (literal || val) {
        this.mystack.push(val);
    } else {
        this.mystack.push("");
    }
    this.tip = this.mystack[this.mystack.length - 1];
};

CSL.Stack.prototype.clear = function() {
    this.mystack = [];
    this.tip = {};
};

CSL.Stack.prototype.replace = function(val, literal) {
    if (this.mystack.length === 0) {
        CSL.error("Internal CSL processor error: attempt to replace nonexistent stack item with " + val);
    }
    if (literal || val) {
        this.mystack[this.mystack.length - 1] = val;
    } else {
        this.mystack[this.mystack.length - 1] = "";
    }
    this.tip = this.mystack[this.mystack.length - 1];
};

CSL.Stack.prototype.pop = function() {
    var ret = this.mystack.pop();
    if (this.mystack.length) {
        this.tip = this.mystack[this.mystack.length - 1];
    } else {
        this.tip = {};
    }
    return ret;
};

CSL.Stack.prototype.value = function() {
    return this.mystack.slice(-1)[0];
};

CSL.Stack.prototype.length = function() {
    return this.mystack.length;
};

CSL.Parallel = function(state) {
    this.state = state;
};

CSL.Parallel.prototype.StartCitation = function(sortedItems, out) {
    this.state.tmp.suppress_repeats = [];
    if (sortedItems.length < 2) return;
    var idxEnd = 0;
    var parallelMatchList = false;
    var siblingRanges = [];
    for (var i = 0, ilen = sortedItems.length - 1; i < ilen; i++) {
        var currItem = sortedItems[i][0];
        var nextItem = sortedItems[i + 1][0];
        var freshMatchList = false;
        var info = {};
        if (sortedItems[i][0].seeAlso && sortedItems[i][0].seeAlso.length > 0 && !parallelMatchList) {
            freshMatchList = true;
            parallelMatchList = [ sortedItems[i][0].id ].concat(sortedItems[i][0].seeAlso);
            var tempMatchList = parallelMatchList.slice();
            var remainder = sortedItems.slice(i);
            remainder[0][1].parallel = "first";
            for (var j = 0, jlen = remainder.length; j < jlen; j++) {
                var itemID = remainder[j][0].id;
                var ididx = tempMatchList.indexOf(itemID);
                idxEnd = false;
                if (ididx === -1) {
                    idxEnd = i + j - 1;
                } else if (i + j === sortedItems.length - 1) {
                    idxEnd = i + j;
                }
                if (idxEnd) {
                    siblingRanges.push([ i, idxEnd ]);
                    break;
                } else {
                    tempMatchList = tempMatchList.slice(0, ididx).concat(tempMatchList.slice(ididx + 1));
                }
            }
        }
        if (i > 0 && freshMatchList) {
            this.state.tmp.suppress_repeats[i - 1].START = true;
            freshMatchList = false;
        }
        for (var varname in this.state.opt.track_repeat) {
            if (!currItem[varname] || !nextItem[varname]) {
                info[varname] = false;
            } else if ("string" === typeof nextItem[varname] || "number" === typeof nextItem[varname]) {
                if (varname === "title" && currItem["title-short"] && nextItem["title-short"]) {
                    var currVal = currItem["title-short"];
                    var nextVal = nextItem["title-short"];
                } else {
                    var currVal = currItem[varname];
                    var nextVal = nextItem[varname];
                }
                if (currVal == nextVal) {
                    info[varname] = true;
                } else {
                    info[varname] = false;
                }
            } else if ("undefined" === typeof currItem[varname].length) {
                info[varname] = false;
                var currYear = currItem[varname].year;
                var nextYear = nextItem[varname].year;
                if (currYear && nextYear) {
                    if (currYear == nextYear) {
                        info[varname] = true;
                    }
                }
            } else {
                var currVal = JSON.stringify(currItem[varname]);
                var nextVal = JSON.stringify(nextItem[varname]);
                if (currVal === nextVal) {
                    info[varname] = true;
                } else {
                    info[varname] = false;
                }
            }
        }
        if (!parallelMatchList) {
            info.ORPHAN = true;
        }
        if (idxEnd === i) {
            info.END = true;
            parallelMatchList = false;
        }
        this.state.tmp.suppress_repeats.push(info);
    }
    for (var j = 0, jlen = siblingRanges.length; j < jlen; j++) {
        var masterID = sortedItems[siblingRanges[j][0]][0].id;
        this.state.registry.registry[masterID].master = true;
        this.state.registry.registry[masterID].siblings = [];
        var start = siblingRanges[j][0];
        var end = siblingRanges[j][1];
        for (var k = start; k < end; k++) {
            this.state.tmp.suppress_repeats[k].SIBLING = true;
            var siblingID = sortedItems[k + 1][0].id;
            sortedItems[k + 1][1].parallel = "other";
            this.state.registry.registry[masterID].siblings.push(siblingID);
        }
    }
};

CSL.Parallel.prototype.checkRepeats = function(params) {
    var idx = this.state.tmp.cite_index;
    if (this.state.tmp.suppress_repeats) {
        if (params.parallel_first && Object.keys(params.parallel_first).length > 0) {
            var arr = [ {} ].concat(this.state.tmp.suppress_repeats);
            var ret = true;
            for (var varname in params.parallel_first) {
                if (!arr[idx][varname] || arr[idx].START) {
                    ret = false;
                }
            }
            return ret;
        }
        if (params.parallel_last && Object.keys(params.parallel_last).length > 0) {
            var arr = this.state.tmp.suppress_repeats.concat([ {} ]);
            var ret = Object.keys(params.parallel_last).length > 0 ? true : false;
            for (var varname in params.parallel_last) {
                if (!arr[idx][varname] || arr[idx].END) {
                    ret = false;
                }
            }
            return ret;
        }
        if (params.non_parallel && Object.keys(params.non_parallel).length > 0) {
            var arr = [ {} ].concat(this.state.tmp.suppress_repeats);
            var ret = true;
            for (var varname in params.non_parallel) {
                if (!arr[idx][varname]) {
                    ret = false;
                }
            }
            return ret;
        }
    }
    return false;
};

CSL.Util = {};

CSL.Util.Match = function() {
    this.any = function(token, state, tests) {
        return function(Item, item) {
            for (var i = 0, ilen = tests.length; i < ilen; i += 1) {
                var result = tests[i](Item, item);
                if (result) {
                    return true;
                }
            }
            return false;
        };
    };
    this.none = function(token, state, tests) {
        return function(Item, item) {
            for (var i = 0, ilen = tests.length; i < ilen; i += 1) {
                var result = tests[i](Item, item);
                if (result) {
                    return false;
                }
            }
            return true;
        };
    };
    this.all = function(token, state, tests) {
        return function(Item, item) {
            for (var i = 0, ilen = tests.length; i < ilen; i += 1) {
                var result = tests[i](Item, item);
                if (!result) {
                    return false;
                }
            }
            return true;
        };
    };
    this[undefined] = this.all;
    this.nand = function(token, state, tests) {
        return function(Item, item) {
            for (var i = 0, ilen = tests.length; i < ilen; i += 1) {
                var result = tests[i](Item, item);
                if (!result) {
                    return true;
                }
            }
            return false;
        };
    };
};

CSL.Util.encodeDoiForUrl = function(doi) {
    return doi.replace(/[\u0000-\u0020"#%<>?[\\\]^`{|}\u007F-\u009F]/g, encodeURIComponent);
};

CSL.Transform = function(state) {
    this.abbrevs = {};
    this.abbrevs["default"] = new state.sys.AbbreviationSegments;
    function getCountryOrJurisdiction(variable, normalizedKey, quashCountry) {
        var value = "";
        if (state.sys.getHumanForm) {
            if (variable === "country") {
                value = state.sys.getHumanForm(normalizedKey.toLowerCase(), false, true);
                value = value.split("|")[0];
            } else if (variable === "jurisdiction") {
                value = state.sys.getHumanForm(normalizedKey.toLowerCase(), false, true);
                if (!quashCountry) {
                    value = value.split("|").slice(1).join(", ");
                } else {
                    value = "";
                }
            }
        }
        return value;
    }
    function abbreviate(state, tok, Item, altvar, basevalue, family_var, use_field) {
        var value = "";
        var myabbrev_family = CSL.FIELD_CATEGORY_REMAP[family_var];
        var preferredJurisdiction;
        if (!myabbrev_family) {
            return basevalue;
        }
        var variable = family_var;
        var normalizedKey = basevalue;
        if (state.sys.normalizeAbbrevsKey) {
            normalizedKey = state.sys.normalizeAbbrevsKey(family_var, basevalue);
        }
        var quashCountry = false;
        if (variable === "jurisdiction" && normalizedKey) {
            quashCountry = normalizedKey.indexOf(":") === -1;
        }
        if ([ "jurisdiction", "country" ].indexOf(family_var) > -1 && basevalue === basevalue.toLowerCase()) {
            normalizedKey = basevalue.toUpperCase();
        }
        if (state.sys.getAbbreviation) {
            if ([ "jurisdiction", "country", "language-name", "language-name-original" ].indexOf(variable) > -1) {
                preferredJurisdiction = "default";
            } else if (Item.jurisdiction) {
                preferredJurisdiction = Item.jurisdiction;
            } else {
                preferredJurisdiction = "default";
            }
            var jurisdiction = state.transform.loadAbbreviation(preferredJurisdiction, myabbrev_family, normalizedKey, Item.language);
            if (state.transform.abbrevs[jurisdiction][myabbrev_family] && normalizedKey) {
                var abbrev = state.transform.abbrevs[jurisdiction][myabbrev_family][normalizedKey];
                if (tok.strings.form === "short" && abbrev) {
                    if (quashCountry) {
                        value = "";
                    } else {
                        value = abbrev;
                    }
                } else {
                    value = getCountryOrJurisdiction(variable, normalizedKey, quashCountry);
                }
            }
        }
        if (!value && (!state.opt.development_extensions.require_explicit_legal_case_title_short || Item.type !== "legal_case") && altvar && Item[altvar] && use_field) {
            value = Item[altvar];
        }
        if (!value && !state.sys.getAbbreviation && state.sys.getHumanForm) {
            value = getCountryOrJurisdiction(variable, normalizedKey, quashCountry);
        }
        if (!value && !quashCountry && (!state.sys.getHumanForm || variable !== "jurisdiction")) {
            value = basevalue;
        }
        if (state.opt.development_extensions.force_title_abbrev_fallback) {
            if (variable === "title" && value === basevalue && Item["title-short"]) {
                value = Item["title-short"];
            }
        }
        return value;
    }
    function getFieldLocale(Item, field) {
        var ret = state.opt["default-locale"][0].slice(0, 2);
        var localeRex;
        if (state.opt.development_extensions.strict_text_case_locales) {
            localeRex = new RegExp("^([a-zA-Z]{2})(?:$|-.*| .*)");
        } else {
            localeRex = new RegExp("^([a-zA-Z]{2})(?:$|-.*|.*)");
        }
        if (Item.language) {
            var m = ("" + Item.language).match(localeRex);
            if (m) {
                ret = m[1];
            } else {
                ret = "tlh";
            }
        }
        if (Item.multi && Item.multi && Item.multi.main && Item.multi.main[field]) {
            ret = Item.multi.main[field];
        }
        if (!state.opt.development_extensions.strict_text_case_locales || state.opt.development_extensions.normalize_lang_keys_to_lowercase) {
            ret = ret.toLowerCase();
        }
        return ret;
    }
    function getTextSubField(Item, field, locale_type, use_default, stopOrig, family_var) {
        var opt, o, ret, opts;
        var usedOrig = stopOrig;
        var usingOrig = false;
        if (!Item[field]) {
            return {
                name: "",
                usedOrig: stopOrig,
                token: CSL.Util.cloneToken(this)
            };
        }
        var stickyLongForm = false;
        if (CSL.VARIABLES_WITH_SHORT_FORM.indexOf(field) > -1 && family_var) {
            field = field + "-short";
            stickyLongForm = true;
        }
        var breakMe = false;
        var firstValue = null;
        var fieldsToTry = [];
        if (field.slice(-6) === "-short") {
            fieldsToTry.push(field);
            fieldsToTry.push(field.slice(0, -6));
        } else {
            fieldsToTry.push(field);
        }
        for (var h = 0, hlen = fieldsToTry.length; h < hlen; h++) {
            var variantMatch = false;
            var field = fieldsToTry[h];
            ret = {
                name: "",
                usedOrig: stopOrig,
                locale: getFieldLocale(Item, field)
            };
            opts = state.opt[locale_type] ? state.opt[locale_type].slice() : [];
            var hasVal = false;
            if (locale_type === "locale-orig") {
                if (!stopOrig) {
                    ret.name = Item[field];
                    ret.usedOrig = false;
                }
                hasVal = true;
                usingOrig = true;
            } else if (use_default && ("undefined" === typeof opts || opts.length === 0)) {
                ret.name = Item[field];
                ret.usedOrig = true;
                hasVal = true;
                usingOrig = true;
            }
            if (!hasVal) {
                for (var i = 0, ilen = opts.length; i < ilen; i += 1) {
                    opt = opts[i];
                    o = opt.split(/[\-_]/)[0];
                    if (opt && Item.multi && Item.multi._keys[field] && Item.multi._keys[field][opt]) {
                        ret.name = Item.multi._keys[field][opt];
                        ret.locale = opt;
                        hasVal = true;
                        variantMatch = true;
                        usingOrig = false;
                        break;
                    } else if (o && Item.multi && Item.multi._keys[field] && Item.multi._keys[field][o]) {
                        ret.name = Item.multi._keys[field][o];
                        ret.locale = o;
                        hasVal = true;
                        variantMatch = true;
                        usingOrig = false;
                        break;
                    }
                }
                if (!ret.name && use_default) {
                    ret = {
                        name: Item[field],
                        usedOrig: true,
                        locale: getFieldLocale(Item, field)
                    };
                    usingOrig = true;
                }
            }
            ret.token = CSL.Util.cloneToken(this);
            if (h === 0) {
                if (variantMatch) {
                    ret.found_variant_ok = true;
                }
                firstValue = ret;
                if (!stickyLongForm && ("undefined" === typeof opts || opts.length === 0)) {
                    breakMe = true;
                }
                if (variantMatch) {
                    breakMe = true;
                }
            } else {
                if (!stickyLongForm && !variantMatch && firstValue) {
                    ret = firstValue;
                    field = fieldsToTry[0];
                } else if (variantMatch) {
                    ret.found_variant_ok = true;
                }
            }
            if ([ "title", "container-title" ].indexOf(field) > -1) {
                if (!usedOrig && (!ret.token.strings["text-case"] || ret.token.strings["text-case"] === "sentence" || ret.token.strings["text-case"] === "normal")) {
                    state.opt.lang;
                    var lang;
                    if (usingOrig) {
                        lang = false;
                    } else {
                        lang = ret.locale;
                    }
                    var seg = field.slice(0, -5);
                    var sentenceCase = ret.token.strings["text-case"] === "sentence" ? true : false;
                    ret.name = CSL.titlecaseSentenceOrNormal(state, Item, seg, lang, sentenceCase);
                    delete ret.token.strings["text-case"];
                }
            }
            if (breakMe) {
                break;
            }
        }
        return ret;
    }
    this.getTextSubField = getTextSubField;
    function loadAbbreviation(jurisdiction, category, orig, lang) {
        if (!jurisdiction) {
            jurisdiction = "default";
        }
        var country = jurisdiction.split(":")[0];
        var domain = CSL.getAbbrevsDomain(state, country, lang);
        if (domain) {
            jurisdiction += "@" + domain;
        }
        if (!orig) {
            if (!state.transform.abbrevs[jurisdiction]) {
                state.transform.abbrevs[jurisdiction] = new state.sys.AbbreviationSegments;
            }
            if (!state.transform.abbrevs[jurisdiction][category]) {
                state.transform.abbrevs[jurisdiction][category] = {};
            }
            return jurisdiction;
        }
        if (state.sys.getAbbreviation) {
            jurisdiction = state.sys.getAbbreviation(state.opt.styleID, state.transform.abbrevs, jurisdiction, category, orig);
            if (!jurisdiction) {
                jurisdiction = "default";
                if (domain) {
                    jurisdiction += "@" + domain;
                }
            }
        }
        return jurisdiction;
    }
    this.loadAbbreviation = loadAbbreviation;
    function publisherCheck(tok, Item, primary, family_var) {
        var varname = tok.variables[0];
        if (state.publisherOutput && primary) {
            if ([ "publisher", "publisher-place" ].indexOf(varname) === -1) {
                return false;
            } else {
                state.publisherOutput[varname + "-token"] = tok;
                state.publisherOutput.varlist.push(varname);
                var lst = primary.split(/;\s*/);
                if (lst.length === state.publisherOutput[varname + "-list"].length) {
                    state.publisherOutput[varname + "-list"] = lst;
                }
                for (var i = 0, ilen = lst.length; i < ilen; i += 1) {
                    lst[i] = abbreviate(state, tok, Item, false, lst[i], family_var, true);
                }
                state.tmp[varname + "-token"] = tok;
                return true;
            }
        }
        return false;
    }
    function citeFormCheck(Item, value) {
        var m = value.match(/^#([0-9]+).*>>>/);
        if (m && m[1]) {
            Item["cite-form"] = m[1];
        }
    }
    function quashCheck(jurisdiction, value) {
        var m = value.match(/^(?:#[0-9]+)*(?:!((?:[-_a-z]+(?:(?:.*)))(?:,(?:[-_a-z]+(?:(?:.*))))*))*>>>/);
        if (m) {
            value = value.slice(m[0].length);
            if (m[1]) {
                var fields = m[1].split(",");
                for (var i = 0, ilen = fields.length; i < ilen; i += 1) {
                    var rawField = fields[i];
                    var mm = rawField.match(/^([-_a-z]+)(?:\:(.*))*$/);
                    var field = mm[1];
                    var trimmer = state.tmp.abbrev_trimmer;
                    if (mm[2]) {
                        if (trimmer && jurisdiction) {
                            if (!trimmer[jurisdiction]) {
                                trimmer[jurisdiction] = {};
                            }
                            trimmer[jurisdiction][field] = mm[2];
                        }
                    } else if (state.tmp.done_vars.indexOf(field) === -1) {
                        if (trimmer && jurisdiction) {
                            if (!trimmer.QUASHES[jurisdiction]) {
                                trimmer.QUASHES[jurisdiction] = {};
                            }
                            trimmer.QUASHES[jurisdiction][field] = true;
                        }
                        state.tmp.done_vars.push(field);
                    }
                }
            }
        }
        return value;
    }
    this.quashCheck = quashCheck;
    function getOutputFunction(variables, family_var, abbreviation_fallback, alternative_varname) {
        var localesets;
        var langPrefs = CSL.LangPrefsMap[variables[0]];
        if (!langPrefs) {
            localesets = false;
        } else {
            localesets = state.opt["cite-lang-prefs"][langPrefs];
        }
        return function(state, Item, item) {
            var primary, primary_locale, secondary, secondary_locale, tertiary, tertiary_locale, primary_tok;
            if (!variables[0] || !Item[variables[0]] && !Item[alternative_varname]) {
                return null;
            }
            if (!state.tmp.just_looking && item && item["suppress-author"]) {
                if (!state.tmp.probably_rendered_something && state.tmp.can_substitute.length() > 1) {
                    return null;
                }
            }
            var slot = {
                primary: false,
                secondary: false,
                tertiary: false
            };
            if (state.tmp.area.slice(-5) === "_sort") {
                slot.primary = "locale-sort";
            } else {
                if (localesets && localesets.length === 1 && localesets[0] === "locale-orig") {
                    slot.primary = "locale-orig";
                    localesets = false;
                } else if (localesets && !state.tmp.multi_layout) {
                    var slotnames = [ "primary", "secondary", "tertiary" ];
                    for (var i = 0, ilen = slotnames.length; i < ilen; i += 1) {
                        if (localesets.length - 1 < i) {
                            break;
                        }
                        if (localesets[i]) {
                            slot[slotnames[i]] = "locale-" + localesets[i];
                        }
                    }
                } else {
                    slot.primary = "locale-orig";
                }
            }
            if (variables[0] === "title-short" || state.tmp.area !== "bibliography" && !(state.tmp.area === "citation" && state.opt.xclass === "note" && item && !item.position)) {
                slot.secondary = false;
                slot.tertiary = false;
            }
            if (state.tmp.multi_layout) {
                slot.secondary = false;
                slot.tertiary = false;
            }
            if (state.tmp["publisher-list"]) {
                if (variables[0] === "publisher") {
                    state.tmp["publisher-token"] = this;
                } else if (variables[0] === "publisher-place") {
                    state.tmp["publisher-place-token"] = this;
                }
                return null;
            }
            var oldLangArray = state.tmp.lang_array.slice();
            var res = getTextSubField.call(this, Item, variables[0], slot.primary, true, null, family_var);
            primary = res.name;
            primary_locale = res.locale;
            var primary_tok = res.token;
            var primaryUsedOrig = res.usedOrig;
            if (family_var && !res.found_variant_ok) {
                primary = abbreviate(state, primary_tok, Item, alternative_varname, primary, family_var, true);
                if (primary) {
                    citeFormCheck(Item, primary);
                    if (!state.tmp.just_looking) {
                        primary = quashCheck(Item.jurisdiction, primary);
                    }
                }
            }
            if (publisherCheck(this, Item, primary, family_var)) {
                state.tmp.lang_array = oldLangArray;
                return null;
            }
            secondary = false;
            tertiary = false;
            var secondary_tok;
            var tertiary_tok;
            if (slot.secondary) {
                res = getTextSubField.call(this, Item, variables[0], slot.secondary, false, res.usedOrig, null, family_var);
                secondary = res.name;
                secondary_locale = res.locale;
                secondary_tok = res.token;
                if (family_var && !res.found_variant_ok) {
                    if (secondary) {
                        secondary = abbreviate(state, secondary_tok, Item, false, secondary, family_var, true);
                    }
                }
            }
            if (slot.tertiary) {
                res = getTextSubField.call(this, Item, variables[0], slot.tertiary, false, res.usedOrig, null, family_var);
                tertiary = res.name;
                tertiary_locale = res.locale;
                tertiary_tok = res.token;
                if (family_var && !res.found_variant_ok) {
                    if (tertiary) {
                        tertiary = abbreviate(state, tertiary_tok, Item, false, tertiary, family_var, true);
                    }
                }
            }
            var primaryPrefix;
            if (slot.primary === "locale-translit") {
                primaryPrefix = state.opt.citeAffixes[langPrefs][slot.primary].prefix;
            }
            if (primaryPrefix === "<i>" && variables[0] === "title" && !primaryUsedOrig) {
                var hasItalic = false;
                for (var i = 0, ilen = primary_tok.decorations.length; i < ilen; i += 1) {
                    if (primary_tok.decorations[i][0] === "@font-style" && primary_tok.decorations[i][1] === "italic") {
                        hasItalic = true;
                    }
                }
                if (!hasItalic) {
                    primary_tok.decorations.push([ "@font-style", "italic" ]);
                }
            }
            if (primary_locale !== "en" && primary_tok.strings["text-case"] === "title") {
                primary_tok.strings["text-case"] = "passthrough";
            }
            if ("title" === variables[0]) {
                primary = CSL.demoteNoiseWords(state, primary, this["leading-noise-words"]);
            }
            if (secondary || tertiary) {
                state.output.openLevel("empty");
                primary_tok.strings.suffix = primary_tok.strings.suffix.replace(/[ .,]+$/, "");
                if (primary_locale) {
                    state.tmp.lang_array = [ primary_locale ].concat(oldLangArray);
                }
                CSL.UPDATE_GROUP_CONTEXT_CONDITION(state, null, null, primary_tok, primary_tok.strings.prefix + primary);
                state.output.append(primary, primary_tok);
                state.tmp.probably_rendered_something = true;
                if (primary === secondary) {
                    secondary = false;
                }
                if (secondary) {
                    secondary_tok.strings.prefix = state.opt.citeAffixes[langPrefs][slot.secondary].prefix;
                    secondary_tok.strings.suffix = state.opt.citeAffixes[langPrefs][slot.secondary].suffix;
                    if (!secondary_tok.strings.prefix) {
                        secondary_tok.strings.prefix = " ";
                    }
                    for (var i = secondary_tok.decorations.length - 1; i > -1; i += -1) {
                        if ([ "@quotes/true", "@font-style/italic", "@font-style/oblique", "@font-weight/bold" ].indexOf(secondary_tok.decorations[i].join("/")) > -1) {
                            secondary_tok.decorations = secondary_tok.decorations.slice(0, i).concat(secondary_tok.decorations.slice(i + 1));
                        }
                    }
                    if (secondary_locale !== "en" && secondary_tok.strings["text-case"] === "title") {
                        secondary_tok.strings["text-case"] = "passthrough";
                    }
                    if (secondary_locale) {
                        state.tmp.lang_array = [ secondary_locale ].concat(oldLangArray);
                    }
                    var secondary_outer = new CSL.Token;
                    secondary_outer.decorations.push([ "@font-style", "normal" ]);
                    secondary_outer.decorations.push([ "@font-weight", "normal" ]);
                    state.output.openLevel(secondary_outer);
                    state.output.append(secondary, secondary_tok);
                    state.output.closeLevel();
                    state.output.current.value();
                    state.output.current.value().blobs.length - 1;
                }
                if (primary === tertiary) {
                    tertiary = false;
                }
                if (tertiary) {
                    tertiary_tok.strings.prefix = state.opt.citeAffixes[langPrefs][slot.tertiary].prefix;
                    tertiary_tok.strings.suffix = state.opt.citeAffixes[langPrefs][slot.tertiary].suffix;
                    if (!tertiary_tok.strings.prefix) {
                        tertiary_tok.strings.prefix = " ";
                    }
                    for (var i = tertiary_tok.decorations.length - 1; i > -1; i += -1) {
                        if ([ "@quotes/true", "@font-style/italic", "@font-style/oblique", "@font-weight/bold" ].indexOf(tertiary_tok.decorations[i].join("/")) > -1) {
                            tertiary_tok.decorations = tertiary_tok.decorations.slice(0, i).concat(tertiary_tok.decorations.slice(i + 1));
                        }
                    }
                    if (tertiary_locale !== "en" && tertiary_tok.strings["text-case"] === "title") {
                        tertiary_tok.strings["text-case"] = "passthrough";
                    }
                    if (tertiary_locale) {
                        state.tmp.lang_array = [ tertiary_locale ].concat(oldLangArray);
                    }
                    var tertiary_outer = new CSL.Token;
                    tertiary_outer.decorations.push([ "@font-style", "normal" ]);
                    tertiary_outer.decorations.push([ "@font-weight", "normal" ]);
                    state.output.openLevel(tertiary_outer);
                    state.output.append(tertiary, tertiary_tok);
                    state.output.closeLevel();
                    state.output.current.value();
                    state.output.current.value().blobs.length - 1;
                }
                state.output.closeLevel();
            } else {
                if (primary_locale) {
                    state.tmp.lang_array = [ primary_locale ].concat(oldLangArray);
                }
                CSL.UPDATE_GROUP_CONTEXT_CONDITION(state, null, null, primary_tok, primary_tok.strings.prefix + primary);
                state.output.append(primary, primary_tok);
                state.tmp.probably_rendered_something = true;
            }
            state.tmp.lang_array = oldLangArray;
            if (state.tmp.can_block_substitute) {
                state.tmp.name_node.children.push(state.output.current.value());
            }
            return null;
        };
    }
    this.getOutputFunction = getOutputFunction;
};

CSL.Token = function(name, tokentype, conditional) {
    this.name = name;
    this.strings = {};
    this.strings.delimiter = undefined;
    this.strings.prefix = "";
    this.strings.suffix = "";
    this.decorations = [];
    this.variables = [];
    this.execs = [];
    this.tokentype = tokentype;
};

CSL.Util.cloneToken = function(token) {
    var newtok, key, pos, len;
    if ("string" === typeof token) {
        return token;
    }
    newtok = new CSL.Token(token.name, token.tokentype);
    for (var key in token.strings) {
        if (token.strings.hasOwnProperty(key)) {
            newtok.strings[key] = token.strings[key];
        }
    }
    if (token.decorations) {
        newtok.decorations = [];
        for (pos = 0, len = token.decorations.length; pos < len; pos += 1) {
            newtok.decorations.push(token.decorations[pos].slice());
        }
    }
    if (token.variables) {
        newtok.variables = token.variables.slice();
    }
    if (token.execs) {
        newtok.execs = token.execs.slice();
        if (token.tests) {
            newtok.tests = token.tests.slice();
        }
    }
    return newtok;
};

CSL.AmbigConfig = function() {
    this.maxvals = [];
    this.minval = 1;
    this.names = [];
    this.givens = [];
    this.year_suffix = false;
    this.disambiguate = 0;
};

CSL.Blob = function(str, token, levelname) {
    var len, pos, key;
    this.levelname = levelname;
    if (token) {
        this.strings = {
            prefix: "",
            suffix: ""
        };
        for (var key in token.strings) {
            if (token.strings.hasOwnProperty(key)) {
                this.strings[key] = token.strings[key];
            }
        }
        this.decorations = [];
        if (token.decorations === undefined) {
            len = 0;
        } else {
            len = token.decorations.length;
        }
        for (pos = 0; pos < len; pos += 1) {
            this.decorations.push(token.decorations[pos].slice());
        }
    } else {
        this.strings = {};
        this.strings.prefix = "";
        this.strings.suffix = "";
        this.strings.delimiter = "";
        this.decorations = [];
    }
    if ("string" === typeof str) {
        this.blobs = str;
    } else if (str) {
        this.blobs = [ str ];
    } else {
        this.blobs = [];
    }
    this.alldecor = [ this.decorations ];
};

CSL.Blob.prototype.push = function(blob) {
    if ("string" === typeof this.blobs) {
        CSL.error("Attempt to push blob onto string object");
    } else if (false !== blob) {
        blob.alldecor = blob.alldecor.concat(this.alldecor);
        this.blobs.push(blob);
    }
};

CSL.NumericBlob = function(state, particle, num, mother_token, id) {
    this.id = id;
    this.alldecor = [];
    this.num = num;
    this.particle = particle;
    this.blobs = num.toString();
    this.status = CSL.START;
    this.strings = {};
    if (mother_token) {
        if (mother_token.strings["text-case"]) {
            var textCase = mother_token.strings["text-case"];
            this.particle = CSL.Output.Formatters[textCase](state, this.particle);
            this.blobs = CSL.Output.Formatters[textCase](state, this.blobs);
        }
        this.gender = mother_token.gender;
        this.decorations = mother_token.decorations;
        this.strings.prefix = mother_token.strings.prefix;
        this.strings.suffix = mother_token.strings.suffix;
        this.strings["text-case"] = mother_token.strings["text-case"];
        this.successor_prefix = mother_token.successor_prefix;
        this.range_prefix = mother_token.range_prefix;
        this.splice_prefix = mother_token.splice_prefix;
        this.formatter = mother_token.formatter;
        if (!this.formatter) {
            this.formatter = new CSL.Output.DefaultFormatter;
        }
        if (this.formatter) {
            this.type = this.formatter.format(1);
        }
    } else {
        this.decorations = [];
        this.strings.prefix = "";
        this.strings.suffix = "";
        this.successor_prefix = "";
        this.range_prefix = "";
        this.splice_prefix = "";
        this.formatter = new CSL.Output.DefaultFormatter;
    }
};

CSL.NumericBlob.prototype.setFormatter = function(formatter) {
    this.formatter = formatter;
    this.type = this.formatter.format(1);
};

CSL.Output.DefaultFormatter = function() {};

CSL.Output.DefaultFormatter.prototype.format = function(num) {
    return num.toString();
};

CSL.NumericBlob.prototype.checkNext = function(next, start) {
    if (start) {
        this.status = CSL.START;
        if ("object" === typeof next) {
            if (next.num === this.num + 1) {
                next.status = CSL.SUCCESSOR;
            } else {
                next.status = CSL.SEEN;
            }
        }
    } else if (!next || !next.num || this.type !== next.type || next.num !== this.num + 1) {
        if (this.status === CSL.SUCCESSOR_OF_SUCCESSOR) {
            this.status = CSL.END;
        }
        if ("object" === typeof next) {
            next.status = CSL.SEEN;
        }
    } else {
        if (this.status === CSL.START || this.status === CSL.SEEN) {
            next.status = CSL.SUCCESSOR;
        } else if (this.status === CSL.SUCCESSOR || this.status === CSL.SUCCESSOR_OF_SUCCESSOR) {
            if (this.range_prefix) {
                next.status = CSL.SUCCESSOR_OF_SUCCESSOR;
                this.status = CSL.SUPPRESS;
            } else {
                next.status = CSL.SUCCESSOR;
            }
        }
    }
};

CSL.NumericBlob.prototype.checkLast = function(last) {
    if (this.status === CSL.SEEN || last.num !== this.num - 1 && this.status === CSL.SUCCESSOR) {
        this.status = CSL.SUCCESSOR;
        return true;
    }
    return false;
};

CSL.Util.fixDateNode = function(parent, pos, node) {
    var form, variable, datexml, subnode, partname, attr, val, prefix, suffix, children, subchildren, display, cslid;
    var lingo = this.cslXml.getAttributeValue(node, "lingo");
    var default_locale = this.cslXml.getAttributeValue(node, "default-locale");
    this.build.date_key = true;
    form = this.cslXml.getAttributeValue(node, "form");
    var lingo;
    if (default_locale) {
        lingo = this.opt["default-locale"][0];
    } else {
        lingo = this.cslXml.getAttributeValue(node, "lingo");
    }
    if (!this.getDate(form, default_locale)) {
        return parent;
    }
    var dateparts = this.cslXml.getAttributeValue(node, "date-parts");
    variable = this.cslXml.getAttributeValue(node, "variable");
    prefix = this.cslXml.getAttributeValue(node, "prefix");
    suffix = this.cslXml.getAttributeValue(node, "suffix");
    display = this.cslXml.getAttributeValue(node, "display");
    cslid = this.cslXml.getAttributeValue(node, "cslid");
    datexml = this.cslXml.nodeCopy(this.getDate(form, default_locale));
    this.cslXml.setAttribute(datexml, "lingo", this.opt.lang);
    this.cslXml.setAttribute(datexml, "form", form);
    this.cslXml.setAttribute(datexml, "date-parts", dateparts);
    this.cslXml.setAttribute(datexml, "cslid", cslid);
    this.cslXml.setAttribute(datexml, "variable", variable);
    this.cslXml.setAttribute(datexml, "default-locale", default_locale);
    if (prefix) {
        this.cslXml.setAttribute(datexml, "prefix", prefix);
    }
    if (suffix) {
        this.cslXml.setAttribute(datexml, "suffix", suffix);
    }
    if (display) {
        this.cslXml.setAttribute(datexml, "display", display);
    }
    children = this.cslXml.children(datexml);
    for (var key in children) {
        subnode = children[key];
        if ("date-part" === this.cslXml.nodename(subnode)) {
            partname = this.cslXml.getAttributeValue(subnode, "name");
            if (default_locale) {
                this.cslXml.setAttributeOnNodeIdentifiedByNameAttribute(datexml, "date-part", partname, "@default-locale", "true");
            }
        }
    }
    children = this.cslXml.children(node);
    for (var key in children) {
        subnode = children[key];
        if ("date-part" === this.cslXml.nodename(subnode)) {
            partname = this.cslXml.getAttributeValue(subnode, "name");
            subchildren = this.cslXml.attributes(subnode);
            for (attr in subchildren) {
                if ("@name" === attr) {
                    continue;
                }
                if (lingo && lingo !== this.opt.lang) {
                    if ([ "@suffix", "@prefix", "@form" ].indexOf(attr) > -1) {
                        continue;
                    }
                }
                val = subchildren[attr];
                this.cslXml.setAttributeOnNodeIdentifiedByNameAttribute(datexml, "date-part", partname, attr, val);
            }
        }
    }
    if ("year" === this.cslXml.getAttributeValue(node, "date-parts")) {
        this.cslXml.deleteNodeByNameAttribute(datexml, "month");
        this.cslXml.deleteNodeByNameAttribute(datexml, "day");
    } else if ("year-month" === this.cslXml.getAttributeValue(node, "date-parts")) {
        this.cslXml.deleteNodeByNameAttribute(datexml, "day");
    } else if ("month-day" === this.cslXml.getAttributeValue(node, "date-parts")) {
        var childNodes = this.cslXml.children(datexml);
        for (var i = 1, ilen = this.cslXml.numberofnodes(childNodes); i < ilen; i++) {
            if (this.cslXml.getAttributeValue(childNodes[i], "name") === "year") {
                this.cslXml.setAttribute(childNodes[i - 1], "suffix", "");
                break;
            }
        }
        this.cslXml.deleteNodeByNameAttribute(datexml, "year");
    }
    return this.cslXml.insertChildNodeAfter(parent, node, pos, datexml);
};

CSL.dateMacroAsSortKey = function(state, Item) {
    CSL.dateAsSortKey.call(this, state, Item, true);
};

CSL.dateAsSortKey = function(state, Item, isMacro) {
    var dp, elem, value, e, yr, prefix, i, ilen;
    var variable = this.variables[0];
    var macroFlag = "empty";
    if (isMacro && state.tmp.extension) {
        macroFlag = "macro-with-date";
    }
    dp = Item[variable];
    if ("undefined" === typeof dp) {
        dp = {
            "date-parts": [ [ 0 ] ]
        };
    }
    if ("undefined" === typeof this.dateparts) {
        this.dateparts = [ "year", "month", "day" ];
    }
    if (dp.raw) {
        dp = state.fun.dateparser.parseDateToArray(dp.raw);
    } else if (dp["date-parts"]) {
        dp = state.dateParseArray(dp);
    }
    if ("undefined" === typeof dp) {
        dp = {};
    }
    if (dp.year) {
        for (i = 0, ilen = CSL.DATE_PARTS_INTERNAL.length; i < ilen; i += 1) {
            elem = CSL.DATE_PARTS_INTERNAL[i];
            value = 0;
            e = elem;
            if (e.slice(-4) === "_end") {
                e = e.slice(0, -4);
            }
            if (dp[elem] && this.dateparts.indexOf(e) > -1) {
                value = dp[elem];
            }
            if (elem.slice(0, 4) === "year") {
                yr = CSL.Util.Dates[e].numeric(state, value);
                var prefix = "1";
                if (yr[0] === "-") {
                    prefix = "0";
                    yr = yr.slice(1);
                    yr = 9999 - parseInt(yr, 10);
                }
                state.output.append(CSL.Util.Dates[elem.slice(0, 4)].numeric(state, prefix + yr), macroFlag);
            } else {
                value = CSL.Util.Dates[e]["numeric-leading-zeros"](state, value);
                if (!value) {
                    value = "00";
                }
                state.output.append(value, macroFlag);
            }
        }
    }
};

CSL.Engine.prototype.dateParseArray = function(date_obj) {
    var ret, field, dp, exts;
    ret = {};
    for (field in date_obj) {
        if (field === "date-parts") {
            dp = date_obj["date-parts"];
            if (dp.length > 1) {
                if (dp[0].length !== dp[1].length) {
                    CSL.error("CSL data error: element mismatch in date range input.");
                }
            }
            exts = [ "", "_end" ];
            for (var i = 0, ilen = dp.length; i < ilen; i += 1) {
                for (var j = 0, jlen = CSL.DATE_PARTS.length; j < jlen; j += 1) {
                    if (isNaN(parseInt(dp[i][j], 10))) {
                        ret[CSL.DATE_PARTS[j] + exts[i]] = undefined;
                    } else {
                        ret[CSL.DATE_PARTS[j] + exts[i]] = parseInt(dp[i][j], 10);
                    }
                }
            }
        } else if (date_obj.hasOwnProperty(field)) {
            if (field === "literal" && "object" === typeof date_obj.literal && "string" === typeof date_obj.literal.part) {
                CSL.debug("Warning: fixing up weird literal date value");
                ret.literal = date_obj.literal.part;
            } else {
                ret[field] = date_obj[field];
            }
        }
    }
    return ret;
};

CSL.Util.Names = {};

CSL.Util.Names.compareNamesets = CSL.NameOutput.prototype._compareNamesets;

CSL.Util.Names.unInitialize = function(state, name) {
    var i, ilen, namelist, punctlist, ret;
    if (!name) {
        return "";
    }
    namelist = name.split(/(?:\-|\s+)/);
    punctlist = name.match(/(\-|\s+)/g);
    ret = "";
    for (i = 0, ilen = namelist.length; i < ilen; i += 1) {
        ret += namelist[i];
        if (i < ilen - 1) {
            ret += punctlist[i];
        }
    }
    return ret;
};

CSL.Util.Names.initializeWith = function(state, name, terminator, normalizeOnly) {
    var i, ilen, ret;
    if (!name) {
        return "";
    }
    if (!terminator) {
        terminator = "";
    }
    if ([ "Lord", "Lady" ].indexOf(name) > -1 || !name.replace(/^(?:<[^>]+>)*/, "").match(CSL.STARTSWITH_ROMANESQUE_REGEXP) && !terminator.match("%s")) {
        return name;
    }
    if (state.opt["initialize-with-hyphen"] === false) {
        name = name.replace(/\-/g, " ");
    }
    name = name.replace(/\s*\-\s*/g, "-").replace(/\s+/g, " ");
    name = name.replace(/-([a-z])/g, "–$1");
    for (var i = name.length - 2; i > -1; i += -1) {
        if (name.slice(i, i + 1) === "." && name.slice(i + 1, i + 2) !== " ") {
            name = name.slice(0, i) + ". " + name.slice(i + 1);
        }
    }
    var nameSplits = CSL.Output.Formatters.nameDoppel.split(name);
    var namelist = [];
    namelist = [ nameSplits.strings[0] ];
    if (nameSplits.tags.length === 0) {
        var mmm = namelist[0].match(/[^\.]+$/);
        if (mmm && mmm[0].length === 1 && mmm[0] !== mmm[0].toLowerCase()) {
            namelist[0] += ".";
        }
    }
    for (i = 1, ilen = nameSplits.strings.length; i < ilen; i += 1) {
        namelist.push(nameSplits.tags[i - 1]);
        namelist.push(nameSplits.strings[i]);
    }
    if (normalizeOnly) {
        ret = this.doNormalize(state, namelist, terminator);
    } else {
        ret = this.doInitialize(state, namelist, terminator);
    }
    ret = ret.replace(/\u2013([a-z])/g, "-$1");
    return ret;
};

CSL.Util.Names.notag = function(str) {
    return str.replace(/^(?:<[^>]+>)*/, "");
};

CSL.Util.Names.mergetag = function(state, tagstr, newstr) {
    var m = tagstr.match(/(?:-*<[^>]+>-*)/g);
    if (!m) {
        return newstr;
    } else {
        tagstr = m.join("");
    }
    m = newstr.match(/^(.*[^\s])*(\s+)$/);
    if (m) {
        m[1] = m[1] ? m[1] : "";
        newstr = m[1] + tagstr + m[2];
    } else {
        newstr = newstr + tagstr;
    }
    return newstr;
};

CSL.Util.Names.tagonly = function(state, str) {
    var m = str.match(/(?:<[^>]+>)+/);
    if (!m) {
        return str;
    } else {
        return m.join("");
    }
};

CSL.Util.Names.doNormalize = function(state, namelist, terminator) {
    var i, ilen;
    terminator = terminator ? terminator : "";
    var isAbbrev = [];
    for (i = 0, ilen = namelist.length; i < ilen; i += 1) {
        if (this.notag(namelist[i]).length > 1 && this.notag(namelist[i]).slice(-1) === ".") {
            namelist[i] = namelist[i].replace(/^(.*)\.(.*)$/, "$1$2");
            isAbbrev.push(true);
        } else if (namelist[i].length === 1 && namelist[i].toUpperCase() === namelist[i]) {
            isAbbrev.push(true);
        } else {
            isAbbrev.push(false);
        }
    }
    for (i = 0, ilen = namelist.length; i < ilen; i += 2) {
        if (isAbbrev[i]) {
            if (i < namelist.length - 2) {
                namelist[i + 1] = this.tagonly(state, namelist[i + 1]);
                if (!isAbbrev[i + 2]) {
                    namelist[i + 1] = this.tagonly(state, namelist[i + 1]) + " ";
                }
                if (namelist[i + 2].length > 1) {
                    namelist[i + 1] = terminator.replace(/\ufeff$/, "") + namelist[i + 1];
                } else {
                    namelist[i + 1] = this.mergetag(state, namelist[i + 1], terminator);
                }
            }
            if (i === namelist.length - 1) {
                namelist[i] = namelist[i] + terminator;
            }
        }
    }
    return namelist.join("").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020\ufeff\u00a0]+$/, "").replace(/\s*\-\s*/g, "-").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020]+/g, " ");
};

CSL.Util.Names.doInitialize = function(state, namelist, terminator) {
    var i, ilen, m, j, jlen, lst, n;
    for (i = 0, ilen = namelist.length; i < ilen; i += 2) {
        n = namelist[i];
        if (!n) {
            continue;
        }
        m = n.match(CSL.NAME_INITIAL_REGEXP);
        if (!m && !n.match(CSL.STARTSWITH_ROMANESQUE_REGEXP) && n.length > 1 && terminator.match("%s")) {
            m = n.match(/(.)(.*)/);
        }
        if (m && m[2] && m[3]) {
            m[1] = m[1] + m[2];
            m[2] = "";
        }
        if (m && m[1].slice(0, 1) === m[1].slice(0, 1).toUpperCase()) {
            var extra = "";
            if (m[2]) {
                var s = "";
                lst = m[2].split("");
                for (j = 0, jlen = lst.length; j < jlen; j += 1) {
                    var c = lst[j];
                    if (c === c.toUpperCase()) {
                        s += c;
                    } else {
                        break;
                    }
                }
                if (s.length < m[2].length) {
                    extra = CSL.toLocaleLowerCase.call(state, s);
                }
            }
            namelist[i] = m[1] + extra;
            if (i < ilen - 1) {
                if (terminator.match("%s")) {
                    namelist[i] = terminator.replace("%s", namelist[i]);
                } else {
                    if (namelist[i + 1].indexOf("-") > -1) {
                        namelist[i + 1] = this.mergetag(state, namelist[i + 1].replace("-", ""), terminator) + "-";
                    } else {
                        namelist[i + 1] = this.mergetag(state, namelist[i + 1], terminator);
                    }
                }
            } else {
                if (terminator.match("%s")) {
                    namelist[i] = terminator.replace("%s", namelist[i]);
                } else {
                    namelist.push(terminator);
                }
            }
        } else if (n.match(CSL.ROMANESQUE_REGEXP) && (!m || !m[3])) {
            namelist[i] = " " + n;
        }
    }
    var ret = namelist.join("");
    ret = ret.replace(/[\u0009\u000a\u000b\u000c\u000d\u0020\ufeff\u00a0]+$/, "").replace(/\s*\-\s*/g, "-").replace(/[\u0009\u000a\u000b\u000c\u000d\u0020]+/g, " ");
    return ret;
};

CSL.Util.Names.getRawName = function(name) {
    var ret = [];
    if (name.literal) {
        ret.push(name.literal);
    } else {
        if (name.given) {
            ret.push(name.given);
        }
        if (name.family) {
            ret.push(name.family);
        }
    }
    return ret.join(" ");
};

CSL.Util.Dates = {};

CSL.Util.Dates.year = {};

CSL.Util.Dates.year["long"] = function(state, num) {
    if (!num) {
        if ("boolean" === typeof num) {
            num = "";
        } else {
            num = 0;
        }
    }
    return num.toString();
};

CSL.Util.Dates.year.imperial = function(state, num, end) {
    var year = "";
    if (!num) {
        if ("boolean" === typeof num) {
            num = "";
        } else {
            num = 0;
        }
    }
    end = end ? "_end" : "";
    var month = state.tmp.date_object["month" + end];
    month = month ? "" + month : "1";
    while (month.length < 2) {
        month = "0" + month;
    }
    var day = state.tmp.date_object["day" + end];
    day = day ? "" + day : "1";
    while (day.length < 2) {
        day = "0" + day;
    }
    var date = parseInt(num + month + day, 10);
    var label;
    var offset;
    if (date >= 18680908 && date < 19120730) {
        label = "明治";
        offset = 1867;
    } else if (date >= 19120730 && date < 19261225) {
        label = "大正";
        offset = 1911;
    } else if (date >= 19261225 && date < 19890108) {
        label = "昭和";
        offset = 1925;
    } else if (date >= 19890108) {
        label = "平成";
        offset = 1988;
    }
    if (label && offset) {
        var normalizedKey = label;
        if (state.sys.normalizeAbbrevsKey) {
            normalizedKey = state.sys.normalizeAbbrevsKey("number", label);
        }
        if (!state.transform.abbrevs["default"]["number"][normalizedKey]) {
            state.transform.loadAbbreviation("default", "number", normalizedKey, null);
        }
        if (state.transform.abbrevs["default"]["number"][normalizedKey]) {
            label = state.transform.abbrevs["default"]["number"][normalizedKey];
        }
        year = label + (num - offset);
    }
    return year;
};

CSL.Util.Dates.year["short"] = function(state, num) {
    num = num.toString();
    if (num && num.length === 4) {
        return num.substr(2);
    }
};

CSL.Util.Dates.year.numeric = function(state, num) {
    var m, pre;
    num = "" + num;
    var m = num.match(/([0-9]*)$/);
    if (m) {
        pre = num.slice(0, m[1].length * -1);
        num = m[1];
    } else {
        pre = num;
        num = "";
    }
    while (num.length < 4) {
        num = "0" + num;
    }
    return pre + num;
};

CSL.Util.Dates.normalizeMonth = function(num, useSeason) {
    var ret;
    if (!num) {
        num = 0;
    }
    num = "" + num;
    if (!num.match(/^[0-9]+$/)) {
        num = 0;
    }
    num = parseInt(num, 10);
    if (useSeason) {
        var res = {
            stub: "month-",
            num: num
        };
        if (res.num < 1 || res.num > 24) {
            res.num = 0;
        } else {
            while (res.num > 16) {
                res.num = res.num - 4;
            }
            if (res.num > 12) {
                res.stub = "season-";
                res.num = res.num - 12;
            }
        }
        ret = res;
    } else {
        if (num < 1 || num > 12) {
            num = 0;
        }
        ret = num;
    }
    return ret;
};

CSL.Util.Dates.month = {};

CSL.Util.Dates.month.numeric = function(state, num) {
    var num = CSL.Util.Dates.normalizeMonth(num);
    if (!num) {
        num = "";
    }
    return num;
};

CSL.Util.Dates.month["numeric-leading-zeros"] = function(state, num) {
    var num = CSL.Util.Dates.normalizeMonth(num);
    if (!num) {
        num = "";
    } else {
        num = "" + num;
        while (num.length < 2) {
            num = "0" + num;
        }
    }
    return num;
};

CSL.Util.Dates.month["long"] = function(state, num, gender, forceDefaultLocale) {
    var res = CSL.Util.Dates.normalizeMonth(num, true);
    var num = res.num;
    if (!num) {
        num = "";
    } else {
        num = "" + num;
        while (num.length < 2) {
            num = "0" + num;
        }
        num = state.getTerm(res.stub + num, "long", 0, 0, false, forceDefaultLocale);
    }
    return num;
};

CSL.Util.Dates.month["short"] = function(state, num, gender, forceDefaultLocale) {
    var res = CSL.Util.Dates.normalizeMonth(num, true);
    var num = res.num;
    if (!num) {
        num = "";
    } else {
        num = "" + num;
        while (num.length < 2) {
            num = "0" + num;
        }
        num = state.getTerm(res.stub + num, "short", 0, 0, false, forceDefaultLocale);
    }
    return num;
};

CSL.Util.Dates.day = {};

CSL.Util.Dates.day.numeric = function(state, num) {
    return num.toString();
};

CSL.Util.Dates.day["long"] = CSL.Util.Dates.day.numeric;

CSL.Util.Dates.day["numeric-leading-zeros"] = function(state, num) {
    if (!num) {
        num = 0;
    }
    num = num.toString();
    while (num.length < 2) {
        num = "0" + num;
    }
    return num.toString();
};

CSL.Util.Dates.day.ordinal = function(state, num, gender) {
    return state.fun.ordinalizer.format(num, gender);
};

CSL.Util.Sort = {};

CSL.Util.Sort.strip_prepositions = function(str) {
    var m;
    if ("string" === typeof str) {
        m = str.match(/^(([aA]|[aA][nN]|[tT][hH][eE])\s+)/);
    }
    if (m) {
        str = str.substr(m[1].length);
    }
    return str;
};

CSL.Util.substituteStart = function(state, target) {
    var element_trace, display, bib_first, func, choose_start, if_start, nodetypes;
    func = function func(state, Item, item) {
        for (var i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
            if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                state.tmp.strip_periods += 1;
                break;
            }
        }
    };
    this.execs.push(func);
    if (this.decorations && state.opt.development_extensions.csl_reverse_lookup_support) {
        this.decorations.reverse();
        this.decorations.push([ "@showid", "true", this.cslid ]);
        this.decorations.reverse();
    }
    nodetypes = [ "number", "date", "names" ];
    if ("text" === this.name && !this.postponed_macro || nodetypes.indexOf(this.name) > -1) {
        element_trace = function element_trace(state, Item, item) {
            if (state.tmp.element_trace.value() === "author" || "names" === this.name) {
                if (!state.tmp.just_looking && item && item["author-only"] && state.tmp.area !== "intext") {
                    if (!state.tmp.probably_rendered_something) ; else {
                        state.tmp.element_trace.push("suppress-me");
                    }
                }
                if (!state.tmp.just_looking && item && item["suppress-author"]) {
                    if (!state.tmp.probably_rendered_something) {
                        state.tmp.element_trace.push("suppress-me");
                    }
                }
            } else if ("date" === this.name) {
                if (!state.tmp.just_looking && item && item["author-only"] && state.tmp.area !== "intext") {
                    if (state.tmp.probably_rendered_something) {
                        state.tmp.element_trace.push("suppress-me");
                    }
                }
            } else {
                if (!state.tmp.just_looking && item && item["author-only"] && state.tmp.area !== "intext") {
                    if (!state.tmp.probably_rendered_something && state.tmp.can_block_substitute) ; else {
                        state.tmp.element_trace.push("suppress-me");
                    }
                } else if (item && item["suppress-author"]) {
                    state.tmp.element_trace.push("do-not-suppress-me");
                }
            }
        };
        this.execs.push(element_trace);
    }
    display = this.strings.cls;
    this.strings.cls = false;
    if (state.build.render_nesting_level === 0) {
        if (state.build.area === "bibliography" && state.bibliography.opt["second-field-align"]) {
            bib_first = new CSL.Token("group", CSL.START);
            bib_first.decorations = [ [ "@display", "left-margin" ] ];
            func = function func(state, Item) {
                if (!state.tmp.render_seen) {
                    bib_first.strings.first_blob = Item.id;
                    state.output.startTag("bib_first", bib_first);
                }
            };
            bib_first.execs.push(func);
            target.push(bib_first);
        } else if (CSL.DISPLAY_CLASSES.indexOf(display) > -1) {
            bib_first = new CSL.Token("group", CSL.START);
            bib_first.decorations = [ [ "@display", display ] ];
            func = function func(state, Item) {
                bib_first.strings.first_blob = Item.id;
                state.output.startTag("bib_first", bib_first);
            };
            bib_first.execs.push(func);
            target.push(bib_first);
        }
        state.build.cls = display;
    }
    state.build.render_nesting_level += 1;
    if (state.build.substitute_level.value() === 1) {
        choose_start = new CSL.Token("choose", CSL.START);
        CSL.Node.choose.build.call(choose_start, state, target);
        if_start = new CSL.Token("if", CSL.START);
        func = function func() {
            if (state.tmp.can_substitute.value()) {
                return true;
            }
            return false;
        };
        if_start.tests ? {} : if_start.tests = [];
        if_start.tests.push(func);
        if_start.test = state.fun.match.any(this, state, if_start.tests);
        target.push(if_start);
    }
    if (state.sys.variableWrapper && this.variables_real && this.variables_real.length) {
        func = function func(state, Item, item) {
            if (!state.tmp.just_looking && !state.tmp.suppress_decorations) {
                var variable_entry = new CSL.Token("text", CSL.START);
                variable_entry.decorations = [ [ "@showid", "true" ] ];
                state.output.startTag("variable_entry", variable_entry);
                var position = null;
                if (item) {
                    position = item.position;
                }
                if (!position) {
                    position = 0;
                }
                var positionMap = [ "first", "container-subsequent", "subsequent", "ibid", "ibid-with-locator" ];
                var noteNumber = 0;
                if (item && item.noteIndex) {
                    noteNumber = item.noteIndex;
                }
                var firstReferenceNoteNumber = 0;
                if (item && item["first-reference-note-number"]) {
                    firstReferenceNoteNumber = item["first-reference-note-number"];
                }
                var firstContainerReferenceNoteNumber = 0;
                if (item && item["first-container-reference-note-number"]) {
                    firstContainerReferenceNoteNumber = item["first-container-reference-note-number"];
                }
                var citationNumber = 0;
                if (item && item["citation-number"]) {
                    citationNumber = item["citation-number"];
                }
                var index = 0;
                if (item && item.index) {
                    index = item.index;
                }
                var params = {
                    itemData: Item,
                    variableNames: this.variables,
                    context: state.tmp.area,
                    xclass: state.opt.xclass,
                    position: positionMap[position],
                    "note-number": noteNumber,
                    "first-reference-note-number": firstReferenceNoteNumber,
                    "first-container-reference-note-number": firstContainerReferenceNoteNumber,
                    "citation-number": citationNumber,
                    index: index,
                    mode: state.opt.mode
                };
                state.output.current.value().params = params;
            }
        };
        this.execs.push(func);
    }
};

CSL.Util.substituteEnd = function(state, target) {
    var func, bib_first_end, bib_other, if_end, choose_end, str;
    if (state.sys.variableWrapper && (this.hasVariable || this.variables_real && this.variables_real.length)) {
        func = function func(state) {
            if (!state.tmp.just_looking && !state.tmp.suppress_decorations) {
                state.output.endTag("variable_entry");
            }
        };
        this.execs.push(func);
    }
    func = function func(state) {
        for (var i = 0, ilen = this.decorations.length; i < ilen; i += 1) {
            if ("@strip-periods" === this.decorations[i][0] && "true" === this.decorations[i][1]) {
                state.tmp.strip_periods += -1;
                break;
            }
        }
    };
    this.execs.push(func);
    state.build.render_nesting_level += -1;
    if (state.build.render_nesting_level === 0) {
        if (state.build.cls) {
            func = function func(state) {
                state.output.endTag("bib_first");
            };
            this.execs.push(func);
            state.build.cls = false;
        } else if (state.build.area === "bibliography" && state.bibliography.opt["second-field-align"]) {
            bib_first_end = new CSL.Token("group", CSL.END);
            func = function func(state) {
                if (!state.tmp.render_seen) {
                    state.output.endTag("bib_first");
                }
            };
            bib_first_end.execs.push(func);
            target.push(bib_first_end);
            bib_other = new CSL.Token("group", CSL.START);
            bib_other.decorations = [ [ "@display", "right-inline" ] ];
            func = function func(state) {
                if (!state.tmp.render_seen) {
                    state.tmp.render_seen = true;
                    state.output.startTag("bib_other", bib_other);
                }
            };
            bib_other.execs.push(func);
            target.push(bib_other);
        }
    }
    if (state.build.substitute_level.value() === 1) {
        if_end = new CSL.Token("if", CSL.END);
        target.push(if_end);
        choose_end = new CSL.Token("choose", CSL.END);
        CSL.Node.choose.build.call(choose_end, state, target);
    }
    if ("names" === this.name || "text" === this.name && this.variables_real !== "title") {
        new CSL.Token("text", CSL.SINGLETON);
        var substitution_name = this.name;
        func = function func(state, Item) {
            if (state.tmp.area !== "bibliography") {
                return;
            }
            if ("string" !== typeof state.bibliography.opt["subsequent-author-substitute"]) {
                return;
            }
            if (this.variables_real && !Item[this.variables_real]) {
                return;
            }
            if (this.variables_real && substitution_name === "names") {
                return;
            }
            var subrule = state.bibliography.opt["subsequent-author-substitute-rule"];
            var i, ilen;
            var printing = !state.tmp.suppress_decorations;
            if (printing && state.tmp.subsequent_author_substitute_ok) {
                if (state.tmp.rendered_name) {
                    if ("partial-each" === subrule || "partial-first" === subrule) {
                        var dosub = true;
                        var rendered_name = [];
                        for (i = 0, ilen = state.tmp.name_node.children.length; i < ilen; i += 1) {
                            var name = state.tmp.rendered_name[i];
                            if (dosub && state.tmp.last_rendered_name && state.tmp.last_rendered_name.length > i - 1 && name && !name.localeCompare(state.tmp.last_rendered_name[i])) {
                                str = new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);
                                state.tmp.name_node.children[i].blobs = [ str ];
                                if ("partial-first" === subrule) {
                                    dosub = false;
                                }
                            } else {
                                dosub = false;
                            }
                            rendered_name.push(name);
                        }
                        state.tmp.last_rendered_name = rendered_name;
                    } else if ("complete-each" === subrule) {
                        var rendered_name = state.tmp.rendered_name.join(",");
                        if (rendered_name) {
                            if (state.tmp.last_rendered_name && !rendered_name.localeCompare(state.tmp.last_rendered_name)) {
                                for (i = 0, ilen = state.tmp.name_node.children.length; i < ilen; i += 1) {
                                    str = new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);
                                    state.tmp.name_node.children[i].blobs = [ str ];
                                }
                            }
                            state.tmp.last_rendered_name = rendered_name;
                        }
                    } else {
                        var rendered_name = state.tmp.rendered_name.join(",");
                        if (rendered_name) {
                            if (state.tmp.last_rendered_name && !rendered_name.localeCompare(state.tmp.last_rendered_name)) {
                                str = new CSL.Blob(state[state.tmp.area].opt["subsequent-author-substitute"]);
                                if (state.tmp.label_blob) {
                                    state.tmp.name_node.top.blobs = [ str, state.tmp.label_blob ];
                                } else if (state.tmp.name_node.top.blobs.length) {
                                    state.tmp.name_node.top.blobs[0].blobs = [ str ];
                                } else {
                                    state.tmp.name_node.top.blobs = [ str ];
                                }
                                state.tmp.substituted_variable = substitution_name;
                            }
                            state.tmp.last_rendered_name = rendered_name;
                        }
                    }
                    state.tmp.subsequent_author_substitute_ok = false;
                }
            }
        };
        this.execs.push(func);
    }
    if ("text" === this.name && !this.postponed_macro || [ "number", "date", "names" ].indexOf(this.name) > -1) {
        func = function func(state, Item) {
            if (state.tmp.element_trace.mystack.length > 1) {
                state.tmp.element_trace.pop();
            }
        };
        this.execs.push(func);
    }
};

CSL.Util.padding = function(num) {
    var m = num.match(/\s*(-{0,1}[0-9]+)/);
    if (m) {
        num = parseInt(m[1], 10);
        if (num < 0) {
            num = 1e20 + num;
        }
        num = "" + num;
        while (num.length < 20) {
            num = "0" + num;
        }
    }
    return num;
};

CSL.Util.LongOrdinalizer = function() {};

CSL.Util.LongOrdinalizer.prototype.init = function(state) {
    this.state = state;
};

CSL.Util.LongOrdinalizer.prototype.format = function(num, gender) {
    if (num < 10) {
        num = "0" + num;
    }
    var ret = CSL.Engine.getField(CSL.LOOSE, this.state.locale[this.state.opt.lang].terms, "long-ordinal-" + num, "long", 0, gender);
    if (!ret) {
        ret = this.state.fun.ordinalizer.format(num, gender);
    }
    this.state.tmp.cite_renders_content = true;
    return ret;
};

CSL.Util.Ordinalizer = function(state) {
    this.state = state;
    this.suffixes = {};
};

CSL.Util.Ordinalizer.prototype.init = function() {
    if (!this.suffixes[this.state.opt.lang]) {
        this.suffixes[this.state.opt.lang] = {};
        for (var i = 0, ilen = 3; i < ilen; i += 1) {
            var gender = [ undefined, "masculine", "feminine" ][i];
            this.suffixes[this.state.opt.lang][gender] = [];
            for (var j = 1; j < 5; j += 1) {
                var ordinal = this.state.getTerm("ordinal-0" + j, "long", false, gender);
                if ("undefined" === typeof ordinal) {
                    delete this.suffixes[this.state.opt.lang][gender];
                    break;
                }
                this.suffixes[this.state.opt.lang][gender].push(ordinal);
            }
        }
    }
};

CSL.Util.Ordinalizer.prototype.format = function(num, gender) {
    var str;
    num = parseInt(num, 10);
    str = "" + num;
    var suffix = "";
    var trygenders = [];
    if (gender) {
        trygenders.push(gender);
    }
    trygenders.push("neuter");
    if (this.state.locale[this.state.opt.lang].ord["1.0.1"]) {
        suffix = this.state.getTerm("ordinal", false, 0, gender);
        var trygender;
        for (var i = 0, ilen = trygenders.length; i < ilen; i += 1) {
            trygender = trygenders[i];
            var ordinfo = this.state.locale[this.state.opt.lang].ord["1.0.1"];
            if (ordinfo["whole-number"][str] && ordinfo["whole-number"][str][trygender]) {
                suffix = this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["whole-number"][str][trygender], false, 0, gender);
            } else if (ordinfo["last-two-digits"][str.slice(str.length - 2)] && ordinfo["last-two-digits"][str.slice(str.length - 2)][trygender]) {
                suffix = this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["last-two-digits"][str.slice(str.length - 2)][trygender], false, 0, gender);
            } else if (ordinfo["last-digit"][str.slice(str.length - 1)] && ordinfo["last-digit"][str.slice(str.length - 1)][trygender]) {
                suffix = this.state.getTerm(this.state.locale[this.state.opt.lang].ord["1.0.1"]["last-digit"][str.slice(str.length - 1)][trygender], false, 0, gender);
            }
            if (suffix) {
                break;
            }
        }
    } else {
        if (!gender) {
            gender = undefined;
        }
        this.state.fun.ordinalizer.init();
        if (num / 10 % 10 === 1 || num > 10 && num < 20) {
            suffix = this.suffixes[this.state.opt.lang][gender][3];
        } else if (num % 10 === 1 && num % 100 !== 11) {
            suffix = this.suffixes[this.state.opt.lang][gender][0];
        } else if (num % 10 === 2 && num % 100 !== 12) {
            suffix = this.suffixes[this.state.opt.lang][gender][1];
        } else if (num % 10 === 3 && num % 100 !== 13) {
            suffix = this.suffixes[this.state.opt.lang][gender][2];
        } else {
            suffix = this.suffixes[this.state.opt.lang][gender][3];
        }
    }
    str = str += suffix;
    return str;
};

CSL.Util.Romanizer = function() {};

CSL.Util.Romanizer.prototype.format = function(num) {
    var ret, pos, n, numstr, len;
    ret = "";
    if (num < 6e3) {
        numstr = num.toString().split("");
        numstr.reverse();
        pos = 0;
        n = 0;
        len = numstr.length;
        for (pos = 0; pos < len; pos += 1) {
            n = parseInt(numstr[pos], 10);
            ret = CSL.ROMAN_NUMERALS[pos][n] + ret;
        }
    }
    return ret;
};

CSL.Util.Suffixator = function(slist) {
    if (!slist) {
        slist = CSL.SUFFIX_CHARS;
    }
    this.slist = slist.split(",");
};

CSL.Util.Suffixator.prototype.format = function(N) {
    var X;
    N += 1;
    var key = "";
    do {
        X = N % 26 === 0 ? 26 : N % 26;
        var key = this.slist[X - 1] + key;
        N = (N - X) / 26;
    } while (N !== 0);
    return key;
};

CSL.Engine.prototype.processNumber = function(node, ItemObject, variable) {
    var val;
    var me = this;
    var realVariable = variable;
    variable = variable === "page-first" ? "page" : variable;
    var fullformAnd = ",\\s+and\\s+|\\s+and\\s+";
    if (this.opt.lang.slice(0, 2) !== "en") {
        fullformAnd += "|,\\s+" + this.getTerm("and") + "\\s+|\\s+" + this.getTerm("and") + "\\s+";
    }
    var symbolAnd = "\\s*&\\s*";
    var andRex = new RegExp("^" + symbolAnd + "$");
    var joinerMatchRex = new RegExp("(" + symbolAnd + "|" + fullformAnd + "|;\\s+|,\\s+|\\s*\\\\*[\\-\\u2013]+\\s*)", "g");
    var joinerSplitRex = new RegExp("(?:" + symbolAnd + "|" + fullformAnd + "|;\\s+|,\\s+|\\s*\\\\*[\\-\\u2013]+\\s*)");
    var localeAnd = this.getTerm("and");
    var localeAmpersand = this.getTerm("and", "symbol");
    if (localeAnd === localeAmpersand) {
        localeAmpersand = "&";
    }
    function normalizeFieldValue(str) {
        str = str.trim();
        var m = str.match(/^([^ ]+)/);
        if (m && !CSL.STATUTE_SUBDIV_STRINGS[m[1]]) {
            var embeddedLabel = null;
            if ([ "locator", "locator-extra", "page" ].indexOf(variable) > -1) {
                if (ItemObject.label) {
                    embeddedLabel = CSL.STATUTE_SUBDIV_STRINGS_REVERSE[ItemObject.label];
                } else {
                    embeddedLabel = "p.";
                }
            } else {
                embeddedLabel = CSL.STATUTE_SUBDIV_STRINGS_REVERSE[variable];
            }
            if (embeddedLabel) {
                str = embeddedLabel + " " + str;
            }
        }
        return str;
    }
    function composeNumberInfo(origLabel, label, val, joiningSuffix, parsePosition) {
        joiningSuffix = joiningSuffix ? joiningSuffix : "";
        var info = {};
        if (!label && !CSL.STATUTE_SUBDIV_STRINGS_REVERSE[variable]) {
            label = "var:" + variable;
        }
        if (label) {
            var m = label.match(/(\s*)([^\s]+)(\s*)/);
            if (realVariable === "page" && parsePosition === 0 && [ "p.", "pp." ].indexOf(m[2]) === -1) {
                info.gotosleepability = true;
                info.labelVisibility = true;
            } else {
                info.labelVisibility = false;
            }
            info.label = m[2];
            info.origLabel = origLabel;
            info.labelSuffix = m[3] ? m[3] : "";
            info.plural = 0;
        }
        var m = val.match(/^([0-9]*[a-zA-Z]+0*)?([0-9]+(?:[a-zA-Z]*|[-,a-zA-Z]+))$/);
        if (m) {
            info.particle = m[1] ? m[1] : "";
            info.value = m[2];
        } else {
            info.particle = "";
            info.value = val;
        }
        info.joiningSuffix = joiningSuffix.replace(/\s*-\s*/, "-");
        return info;
    }
    function fixupSubsections(elems) {
        for (var i = elems.length - 2; i > -1; i -= 2) {
            if (elems[i] === "-" && elems[i - 1].match(/^(?:(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z])\.  *)*[0-9]+[,a-zA-Z]+$/) && elems[i + 1].match(/^[,a-zA-Z]+$/)) {
                elems[i - 1] = elems.slice(i - 1, i + 2).join("");
                elems = elems.slice(0, i).concat(elems.slice(i + 2));
            }
        }
        return elems;
    }
    function parseString(str, defaultLabel) {
        defaultLabel = defaultLabel ? defaultLabel : "";
        str = normalizeFieldValue(str);
        var jmrex, jsrex, mystr;
        if ("page" === variable) {
            if (str.indexOf("–") > -1) {
                str = str.replace(/\u2013/g, "-");
            }
        }
        if (str.indexOf("\\-") > -1) {
            jmrex = new RegExp(joinerMatchRex.source.replace("\\-", ""));
            jsrex = new RegExp(joinerSplitRex.source.replace("\\-", ""));
            var lst = str.split("\\-");
            for (var i = 0, ilen = lst.length; i < ilen; i++) {
                lst[i] = lst[i].replace(/\-/g, "–");
            }
            mystr = lst.join("\\-");
            mystr = mystr.replace(/\\/g, "");
        } else {
            jmrex = joinerMatchRex;
            jsrex = joinerSplitRex;
            mystr = str;
        }
        var elems = [];
        var m = mystr.match(jmrex);
        if (m) {
            var lst = mystr.split(jsrex);
            for (var i = 0, ilen = m.length; i < ilen; i++) {
                if (m[i].match(andRex)) {
                    if (lst[i].match(/[a-zA-Z]$/) && lst[i].match(/^[a-zA-Z]/)) {
                        m[i] = localeAmpersand;
                    } else {
                        m[i] = " " + localeAmpersand + " ";
                    }
                }
            }
            var recombine = false;
            for (var i in lst) {
                if (("" + lst[i]).replace(/^[a-z]\.\s+/, "").match(/[^\s0-9ivxlcmIVXLCM]/)) {
                    break;
                }
            }
            if (recombine) {
                elems = [ mystr ];
            } else {
                for (var i = 0, ilen = lst.length - 1; i < ilen; i++) {
                    elems.push(lst[i]);
                    elems.push(m[i]);
                }
                elems.push(lst[lst.length - 1]);
                elems = fixupSubsections(elems);
            }
        } else {
            var elems = [ mystr ];
        }
        var values = [];
        var label = defaultLabel;
        var origLabel = "";
        for (var i = 0, ilen = elems.length; i < ilen; i += 2) {
            var m = elems[i].match(/((?:^| )(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z]|subpara|subch|amend|bibliog|annot|illus|princ|intro|sched|subdiv|subsec)(?:\.| ) *)/g);
            if (m) {
                var lst = elems[i].split(/(?:(?:^| )(?:[a-z]|[a-z][a-z]|[a-z][a-z][a-z]|[a-z][a-z][a-z][a-z]|subpara|subch|amend|bibliog|annot|illus|princ|intro|sched|subdiv|subsec)(?:\.| ) *)/);
                for (var j = lst.length - 1; j > 0; j--) {
                    if (lst[j - 1] && (!lst[j].match(/^[0-9]+([-;,:a-zA-Z]*)$/) || !lst[j - 1].match(/^[0-9]+([-;,:a-zA-Z]*)$/))) {
                        lst[j - 1] = lst[j - 1] + m[j - 1] + lst[j];
                        lst = lst.slice(0, j).concat(lst.slice(j + 1));
                        m = m.slice(0, j - 1).concat(m.slice(j));
                    }
                }
                if (m.length > 0) {
                    var slug = m[0].trim();
                    var notAlabel = !CSL.STATUTE_SUBDIV_STRINGS[slug] || "undefined" === typeof me.getTerm(CSL.STATUTE_SUBDIV_STRINGS[slug]) || [ "locator", "number", "locator-extra", "page" ].indexOf(variable) === -1 && CSL.STATUTE_SUBDIV_STRINGS[slug] !== variable;
                    if (notAlabel) {
                        if (i === 0) {
                            m = m.slice(1);
                            lst[0] = lst[0] + " " + slug + " " + lst[1];
                            lst = lst.slice(0, 1).concat(lst.slice(2));
                        }
                    } else {
                        origLabel = slug;
                    }
                }
                for (var j = 0, jlen = lst.length; j < jlen; j++) {
                    if (lst[j] || j === lst.length - 1) {
                        var filteredOrigLabel;
                        label = m[j - 1] ? m[j - 1] : label;
                        if (origLabel === label.trim()) {
                            filteredOrigLabel = "";
                        } else {
                            filteredOrigLabel = origLabel;
                        }
                        mystr = lst[j] ? lst[j].trim() : "";
                        if (j === lst.length - 1) {
                            values.push(composeNumberInfo(filteredOrigLabel, label, mystr, elems[i + 1], i));
                        } else {
                            values.push(composeNumberInfo(filteredOrigLabel, label, mystr, null, i));
                        }
                    }
                }
            } else {
                var filteredOrigLabel;
                if (origLabel === label.trim()) {
                    filteredOrigLabel = "";
                } else {
                    filteredOrigLabel = origLabel;
                }
                values.push(composeNumberInfo(filteredOrigLabel, label, elems[i], elems[i + 1]));
            }
        }
        return values;
    }
    function setSpaces(values) {
        for (var i = 0, ilen = values.length - 1; i < ilen; i++) {
            if (!values[i].joiningSuffix && values[i + 1].label) {
                values[i].joiningSuffix = " ";
            }
        }
    }
    function fixNumericAndCount(values, i, currentLabelInfo) {
        var master = values[currentLabelInfo.pos];
        var val = values[i].value;
        var isEscapedHyphen = master.joiningSuffix === "\\-";
        if (val.particle && val.particle !== master.particle) {
            currentLabelInfo.collapsible = false;
        }
        var mVal = val.match(/^[0-9]+([-,:a-zA-Z]*)$/);
        var mCurrentLabel = master.value.match(/^(?:[0-9]+|[ixv]+)([-,:a-zA-Z]*|\-[\-0-9]+)$/);
        if (!val || !mVal || !mCurrentLabel || isEscapedHyphen) {
            currentLabelInfo.collapsible = false;
            if (!val || !mCurrentLabel) {
                currentLabelInfo.numeric = false;
            }
            if (isEscapedHyphen) {
                currentLabelInfo.count--;
            }
        }
        if (mVal && mVal[1] || mCurrentLabel && mCurrentLabel[1]) {
            currentLabelInfo.collapsible = false;
        }
        if (undefined === values[i].collapsible) {
            for (var j = i, jlen = i + currentLabelInfo.count; j < jlen; j++) {
                if (isNaN(parseInt(values[j].value)) && !values[j].value.match(/^[ivxlcmIVXLCM]+$/)) {
                    values[j].collapsible = false;
                } else {
                    values[j].collapsible = true;
                }
            }
            currentLabelInfo.collapsible = values[i].collapsible;
        }
        var isCollapsible = currentLabelInfo.collapsible;
        for (var j = currentLabelInfo.pos, jlen = currentLabelInfo.pos + currentLabelInfo.count; j < jlen; j++) {
            if (currentLabelInfo.count > 1 && isCollapsible) {
                values[j].plural = 1;
            }
            values[j].numeric = currentLabelInfo.numeric;
            values[j].collapsible = currentLabelInfo.collapsible;
        }
    }
    function fixLabelVisibility(values, groupStartPos, currentLabelInfo) {
        if (currentLabelInfo.label.slice(0, 4) !== "var:") {
            if (currentLabelInfo.pos === 0) {
                if ([ "locator", "number", "locator-extra", "page" ].indexOf(variable) > -1) {
                    if ("undefined" === typeof me.getTerm(CSL.STATUTE_SUBDIV_STRINGS[currentLabelInfo.label])) {
                        values[currentLabelInfo.pos].labelVisibility = true;
                    }
                }
                if ([ "locator", "number", "locator-extra", "page" ].indexOf(variable) === -1) {
                    if (CSL.STATUTE_SUBDIV_STRINGS[currentLabelInfo.label] !== variable) {
                        values[0].labelVisibility = true;
                    }
                }
            } else {
                values[currentLabelInfo.pos].labelVisibility = true;
            }
        }
    }
    function setPluralsAndNumerics(values) {
        if (values.length === 0) {
            return;
        }
        var groupStartPos = 0;
        var groupCount = 1;
        for (var i = 1, ilen = values.length; i < ilen; i++) {
            var lastVal = values[i - 1];
            var thisVal = values[i];
            if (lastVal.label === thisVal.label && lastVal.particle === lastVal.particle) {
                groupCount++;
            } else {
                var currentLabelInfo = JSON.parse(JSON.stringify(values[groupStartPos]));
                currentLabelInfo.pos = groupStartPos;
                currentLabelInfo.count = groupCount;
                currentLabelInfo.numeric = true;
                fixNumericAndCount(values, groupStartPos, currentLabelInfo);
                if (lastVal.label !== thisVal.label) {
                    fixLabelVisibility(values, groupStartPos, currentLabelInfo);
                }
                groupStartPos = i;
                groupCount = 1;
            }
        }
        var currentLabelInfo = JSON.parse(JSON.stringify(values[groupStartPos]));
        currentLabelInfo.pos = groupStartPos;
        currentLabelInfo.count = groupCount;
        currentLabelInfo.numeric = true;
        fixNumericAndCount(values, groupStartPos, currentLabelInfo);
        fixLabelVisibility(values, groupStartPos, currentLabelInfo);
        if (values.length && values[0].numeric && variable.slice(0, 10) === "number-of-") {
            if (parseInt(ItemObject[realVariable], 10) > 1) {
                values[0].plural = 1;
            }
        }
    }
    function stripHyphenBackslash(joiningSuffix) {
        return joiningSuffix.replace("\\-", "-");
    }
    function setStyling(values) {
        var masterNode = CSL.Util.cloneToken(node);
        var masterStyling = new CSL.Token;
        if (!me.tmp.just_looking) {
            masterStyling.decorations = masterNode.decorations;
            masterNode.decorations = [];
            masterStyling.strings.prefix = masterNode.strings.prefix;
            masterNode.strings.prefix = "";
            masterStyling.strings.suffix = masterNode.strings.suffix;
            masterNode.strings.suffix = "";
        }
        var masterLabel = values.length ? values[0].label : null;
        if (values.length) {
            for (var i = 0, ilen = values.length; i < ilen; i++) {
                var val = values[i];
                var newnode = CSL.Util.cloneToken(masterNode);
                newnode.gender = node.gender;
                if (masterLabel === val.label) {
                    newnode.formatter = node.formatter;
                }
                if (val.numeric) {
                    newnode.successor_prefix = val.successor_prefix;
                }
                newnode.strings.suffix = newnode.strings.suffix + stripHyphenBackslash(val.joiningSuffix);
                val.styling = newnode;
            }
            if (!me.tmp.just_looking) {
                if (values[0].value.slice(0, 1) === '"' && values[values.length - 1].value.slice(-1) === '"') {
                    values[0].value = values[0].value.slice(1);
                    values[values.length - 1].value = values[values.length - 1].value.slice(0, -1);
                    masterStyling.decorations.push([ "@quotes", true ]);
                }
            }
        }
        return masterStyling;
    }
    function checkTerm(variable, val) {
        var ret = true;
        if ([ "locator", "locator-extra", "page" ].indexOf(variable) > -1) {
            var label;
            if (val.origLabel) {
                label = val.origLabel;
            } else {
                label = val.label;
            }
            ret = !!me.getTerm(CSL.STATUTE_SUBDIV_STRINGS[label]);
        }
        return ret;
    }
    function checkPage(variable, val) {
        return "page" === variable || [ "locator", "locator-extra" ].indexOf(variable) > -1 && ([ "p." ].indexOf(val.label) > -1 || [ "p." ].indexOf(val.origLabel) > -1);
    }
    function fixupRangeDelimiter(variable, val, rangeDelimiter, isNumeric) {
        var isPage = checkPage(variable, val);
        var hasTerm = checkTerm(variable, val);
        if (hasTerm && rangeDelimiter === "-") {
            if (isNumeric) {
                if (isPage || [ "locator", "locator-extra", "issue", "volume", "edition", "number" ].indexOf(variable) > -1) {
                    rangeDelimiter = me.getTerm("page-range-delimiter");
                    if (!rangeDelimiter) {
                        rangeDelimiter = "–";
                    }
                }
                if (variable === "collection-number") {
                    rangeDelimiter = me.getTerm("year-range-delimiter");
                    if (!rangeDelimiter) {
                        rangeDelimiter = "–";
                    }
                }
            }
        }
        return rangeDelimiter;
    }
    function manglePageNumbers(values, i, currentInfo) {
        if (i < 1) {
            return;
        }
        if (currentInfo.count !== 2) {
            return;
        }
        if (values[i - 1].particle !== values[i].particle) {
            return;
        }
        if (values[i - 1].joiningSuffix !== "-") {
            currentInfo.count = 1;
            return;
        }
        if (!me.opt["page-range-format"] && parseInt(values[i - 1].value, 10) > parseInt(values[i].value, 10)) {
            values[i - 1].joiningSuffix = fixupRangeDelimiter(variable, values[i], values[i - 1].joiningSuffix, true);
            return;
        }
        var val = values[i];
        var isPage = checkPage(variable, val);
        var str;
        if (isPage && !isNaN(parseInt(values[i - 1].value)) && !isNaN(parseInt(values[i].value))) {
            str = values[i - 1].particle + values[i - 1].value + " - " + values[i].particle + values[i].value;
            str = me.fun.page_mangler(str);
        } else {
            if (("" + values[i - 1].value).match(/^([0-9]+|[ivxlcmIVXLCM]+)$/) && ("" + values[i].value).match(/^([0-9]+|[ivxlcmIVXLCM]+)$/)) {
                values[i - 1].joiningSuffix = me.getTerm("page-range-delimiter");
            }
            str = values[i - 1].value + stripHyphenBackslash(values[i - 1].joiningSuffix) + values[i].value;
        }
        var m = str.match(/^((?:[0-9]*[a-zA-Z]+0*))?([0-9]+[a-z]*)(\s*[^0-9]+\s*)([-,a-zA-Z]?0*)([0-9]+[a-z]*)$/);
        if (m) {
            var rangeDelimiter = m[3];
            rangeDelimiter = fixupRangeDelimiter(variable, val, rangeDelimiter, values[i].numeric);
            values[i - 1].particle = m[1];
            values[i - 1].value = m[2];
            values[i - 1].joiningSuffix = rangeDelimiter;
            values[i].particle = m[4];
            values[i].value = m[5];
        }
        currentInfo.count = 0;
    }
    function fixRanges(values) {
        if (!node) {
            return;
        }
        if ([ "page", "chapter-number", "collection-number", "edition", "issue", "number", "number-of-pages", "number-of-volumes", "volume", "locator", "locator-extra" ].indexOf(variable) === -1) {
            return;
        }
        var currentInfo = {
            count: 0,
            label: null
        };
        for (var i = 0, ilen = values.length; i < ilen; i++) {
            var val = values[i];
            if (!val.collapsible) {
                currentInfo.count = 0;
                currentInfo.label = null;
                var isNumeric = val.numeric;
                val.joiningSuffix = fixupRangeDelimiter(variable, val, val.joiningSuffix, isNumeric);
            } else if (currentInfo.label === val.label && val.joiningSuffix === "-") {
                currentInfo.count = 1;
            } else if (currentInfo.label === val.label && val.joiningSuffix !== "-") {
                currentInfo.count++;
                if (currentInfo.count === 2) {
                    manglePageNumbers(values, i, currentInfo);
                }
            } else if (currentInfo.label !== val.label) {
                currentInfo.label = val.label;
                currentInfo.count = 1;
            } else {
                currentInfo.count = 1;
                currentInfo.label = val.label;
            }
        }
        if (currentInfo.count === 2) {
            manglePageNumbers(values, values.length - 1, currentInfo);
        }
    }
    function setVariableParams(shadow_numbers, realVariable, values) {
        var obj = shadow_numbers[realVariable];
        if (values.length) {
            obj.numeric = values[0].numeric;
            obj.collapsible = values[0].collapsible;
            obj.plural = values[0].plural;
            obj.label = CSL.STATUTE_SUBDIV_STRINGS[values[0].label];
            if (variable === "number" && obj.label === "issue" && me.getTerm("number")) {
                obj.label = "number";
            }
        }
    }
    if (node && this.tmp.shadow_numbers[realVariable] && this.tmp.shadow_numbers[realVariable].values.length) {
        var values = this.tmp.shadow_numbers[realVariable].values;
        fixRanges(values);
        this.tmp.shadow_numbers[realVariable].masterStyling = setStyling(values);
        return;
    }
    if (!this.tmp.shadow_numbers[realVariable]) {
        this.tmp.shadow_numbers[realVariable] = {
            values: []
        };
    }
    if (!ItemObject) {
        return;
    }
    var languageRole = CSL.LangPrefsMap[variable];
    if (languageRole) {
        var localeType = this.opt["cite-lang-prefs"][languageRole][0];
        val = this.transform.getTextSubField(ItemObject, realVariable, "locale-" + localeType, true);
        val = val.name;
    } else {
        val = ItemObject[realVariable];
    }
    if (val && realVariable === "number" && ItemObject.type === "legal_case") {
        val = val.replace(/[\\]*-/g, "\\-");
    }
    if (val && this.sys.getAbbreviation) {
        if (this.sys.normalizeAbbrevsKey) {
            var normval = this.sys.normalizeAbbrevsKey(realVariable, val);
        } else {
            var normval = val;
        }
        var jurisdiction = this.transform.loadAbbreviation(ItemObject.jurisdiction, "number", normval, ItemObject.language);
        if (this.transform.abbrevs[jurisdiction].number) {
            if (this.transform.abbrevs[jurisdiction].number[normval]) {
                val = this.transform.abbrevs[jurisdiction].number[normval];
            } else {
                if ("undefined" !== typeof this.transform.abbrevs[jurisdiction].number[normval]) {
                    delete this.transform.abbrevs[jurisdiction].number[normval];
                }
            }
        }
    }
    if ("undefined" !== typeof val && ("string" === typeof val || "number" === typeof val)) {
        if ("number" === typeof val) {
            val = "" + val;
        }
        var defaultLabel = CSL.STATUTE_SUBDIV_STRINGS_REVERSE[variable];
        if (this.tmp.shadow_numbers[realVariable].values.length === 0) {
            var values = parseString(val, defaultLabel);
            setSpaces(values);
            setPluralsAndNumerics(values);
            for (var obj of values) {
                if (!obj.numeric) obj.plural = 0;
            }
            this.tmp.shadow_numbers[realVariable].values = values;
            if (node) {
                fixRanges(values);
                this.tmp.shadow_numbers[realVariable].masterStyling = setStyling(values);
            }
            setVariableParams(this.tmp.shadow_numbers, realVariable, values);
        }
        var info = this.tmp.shadow_numbers[realVariable];
        if (variable === "number") {
            if (info.values.length === 1 && info.values[0].value.indexOf("|") > -1) {
                info.values[0].value = info.values[0].value.replace(/\|/g, ", ");
                info.values[0].numeric = true;
                info.values[0].plural = 1;
                info.values[0].collapsible = false;
                info.numeric = true;
                info.plural = 1;
                info.collapsible = false;
            }
        }
        if (info.values.length === 1) {
            if (info.values[0].value.match(/^[0-9]+(?:\/[0-9]+)+$/)) {
                info.values[0].numeric = true;
                info.values[0].plural = 0;
                info.values[0].collapsible = false;
                info.numeric = true;
                info.plural = 0;
                info.collapsible = false;
            }
        }
        if (variable === "page") {
            if (info.values.length > 0) {
                if (info.values[0].gotosleepability) {
                    info.labelForm = "short";
                }
            }
        }
    }
};

CSL.Util.outputNumericField = function(state, varname, itemID) {
    state.output.openLevel(state.tmp.shadow_numbers[varname].masterStyling);
    var masterStyling = state.tmp.shadow_numbers[varname].masterStyling;
    var nums = state.tmp.shadow_numbers[varname].values;
    var masterLabel = nums.length ? nums[0].label : null;
    var labelForm = state.tmp.shadow_numbers[varname].labelForm;
    var tryStatic = state.tmp.group_context.tip.label_static;
    var embeddedLabelForm;
    if (labelForm) {
        embeddedLabelForm = labelForm;
    } else {
        embeddedLabelForm = "short";
    }
    var labelCapitalizeIfFirst = state.tmp.shadow_numbers[varname].labelCapitalizeIfFirst;
    var labelDecorations = state.tmp.shadow_numbers[varname].labelDecorations;
    var lastLabelName = null;
    for (var i = 0, ilen = nums.length; i < ilen; i++) {
        var num = nums[i];
        var label = "";
        var labelName;
        if (num.label) {
            if ("var:" === num.label.slice(0, 4)) {
                labelName = num.label.slice(4);
            } else {
                labelName = CSL.STATUTE_SUBDIV_STRINGS[num.label];
            }
            if (labelName) {
                if (num.label === masterLabel) {
                    if (tryStatic) {
                        label = state.getTerm(labelName, "static", num.plural);
                        if (label.indexOf("%s") === -1) {
                            label = "";
                        }
                    }
                    if (!label) {
                        label = state.getTerm(labelName, labelForm, num.plural);
                    }
                } else {
                    if (tryStatic) {
                        label = state.getTerm(labelName, "static", num.plural);
                        if (label.indexOf("%s") === -1) {
                            label = "";
                        }
                    }
                    if (!label) {
                        label = state.getTerm(labelName, embeddedLabelForm, num.plural);
                    }
                }
                if (labelCapitalizeIfFirst) {
                    label = CSL.Output.Formatters["capitalize-first"](state, label);
                }
            }
        }
        var labelPlaceholderPos = -1;
        if (label) {
            labelPlaceholderPos = label.indexOf("%s");
        }
        var numStyling = CSL.Util.cloneToken(num.styling);
        numStyling.formatter = num.styling.formatter;
        numStyling.type = num.styling.type;
        numStyling.num = num.styling.num;
        numStyling.gender = num.styling.gender;
        if (labelPlaceholderPos > 0 && labelPlaceholderPos < label.length - 2) {
            numStyling.strings.prefix += label.slice(0, labelPlaceholderPos);
            numStyling.strings.suffix = label.slice(labelPlaceholderPos + 2) + numStyling.strings.suffix;
        } else if (num.labelVisibility) {
            if (!label) {
                label = num.label;
                labelName = num.label;
            }
            if (labelPlaceholderPos > 0) {
                var prefixLabelStyling = new CSL.Token;
                prefixLabelStyling.decorations = labelDecorations;
                state.output.append(label.slice(0, labelPlaceholderPos), prefixLabelStyling);
            } else if (labelPlaceholderPos === label.length - 2 || labelPlaceholderPos === -1) {
                state.output.append(label + num.labelSuffix, "empty");
            }
        }
        CSL.UPDATE_GROUP_CONTEXT_CONDITION(state, masterStyling.strings.prefix, null, masterStyling, "".concat(num.particle).concat(num.value));
        if (num.collapsible) {
            var blob;
            if (num.value.match(/^[1-9][0-9]*$/) && Number.isSafeInteger(parseInt(num.value, 10))) {
                blob = new CSL.NumericBlob(state, num.particle, parseInt(num.value, 10), numStyling, itemID);
            } else {
                blob = new CSL.NumericBlob(state, num.particle, num.value, numStyling, itemID);
            }
            if ("undefined" === typeof blob.gender) {
                blob.gender = state.locale[state.opt.lang]["noun-genders"][varname];
            }
            state.output.append(blob, "literal");
        } else {
            state.output.append(num.particle + num.value, numStyling);
        }
        if (labelPlaceholderPos === 0 && labelPlaceholderPos < label.length - 2) {
            if (lastLabelName === null) {
                lastLabelName = labelName;
            }
            if (labelName !== lastLabelName || i === nums.length - 1) {
                var suffixLabelStyling = new CSL.Token;
                suffixLabelStyling.decorations = labelDecorations;
                state.output.append(label.slice(labelPlaceholderPos + 2), suffixLabelStyling);
            }
        }
        lastLabelName = labelName;
        state.tmp.term_predecessor = true;
    }
    state.output.closeLevel();
};

CSL.Util.PageRangeMangler = {};

CSL.Util.PageRangeMangler.getFunction = function(state, rangeType) {
    var rangerex, pos, len, stringify, listify, expand, minimize, minimize_internal, chicago15, chicago16, lst, m, b, e, ret, begin, end, ret_func;
    var range_delimiter = state.getTerm(rangeType + "-range-delimiter");
    rangerex = /([0-9]*[a-zA-Z]+0*)?([0-9]+[a-z]*)\s*(?:\u2013|-)\s*([0-9]*[a-zA-Z]+0*)?([0-9]+[a-z]*)/;
    stringify = function stringify(lst) {
        len = lst.length;
        for (pos = 1; pos < len; pos += 2) {
            if ("object" === typeof lst[pos]) {
                lst[pos] = lst[pos].join("");
            }
        }
        var ret = lst.join("");
        ret = ret.replace(/([^\\])\-/g, "$1" + state.getTerm(rangeType + "-range-delimiter"));
        return ret;
    };
    listify = function listify(str) {
        var m, lst, ret;
        var hyphens = "\\s+\\-\\s+";
        var this_range_delimiter = range_delimiter === "-" ? "" : range_delimiter;
        var delimRex = new RegExp("([^\\\\])[-" + this_range_delimiter + "\\u2013]", "g");
        str = str.replace(delimRex, "$1 - ").replace(/\s+-\s+/g, " - ");
        var rexm = new RegExp("((?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*" + hyphens + "(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*)", "g");
        var rexlst = new RegExp("(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*" + hyphens + "(?:[0-9]*[a-zA-Z]+0*)?[0-9]+[a-z]*");
        m = str.match(rexm);
        lst = str.split(rexlst);
        if (lst.length === 0) {
            ret = m;
        } else {
            ret = [ lst[0] ];
            for (pos = 1, len = lst.length; pos < len; pos += 1) {
                ret.push(m[pos - 1].replace(/\s*\-\s*/g, "-"));
                ret.push(lst[pos]);
            }
        }
        return ret;
    };
    expand = function expand(str) {
        str = "" + str;
        lst = listify(str);
        len = lst.length;
        for (pos = 1; pos < len; pos += 2) {
            m = lst[pos].match(rangerex);
            if (m) {
                if (!m[3] || m[1] === m[3]) {
                    if (m[4].length < m[2].length) {
                        m[4] = m[2].slice(0, m[2].length - m[4].length) + m[4];
                    }
                    if (parseInt(m[2], 10) < parseInt(m[4], 10)) {
                        m[3] = range_delimiter + (m[1] ? m[1] : "");
                        lst[pos] = m.slice(1);
                    }
                }
            }
            if ("string" === typeof lst[pos]) {
                lst[pos] = lst[pos].replace(/\-/g, range_delimiter);
            }
        }
        return lst;
    };
    minimize = function minimize(lst, minchars, isyear) {
        len = lst.length;
        for (var i = 1, ilen = lst.length; i < ilen; i += 2) {
            if ("object" === typeof lst[i]) {
                lst[i][3] = minimize_internal(lst[i][1], lst[i][3], minchars, isyear);
                if (lst[i][2].slice(1) === lst[i][0]) {
                    lst[i][2] = range_delimiter;
                }
            }
        }
        return stringify(lst);
    };
    minimize_internal = function minimize_internal(begin, end, minchars, isyear) {
        if (!minchars) {
            minchars = 0;
        }
        b = ("" + begin).split("");
        e = ("" + end).split("");
        ret = e.slice();
        ret.reverse();
        if (b.length === e.length) {
            for (var i = 0, ilen = b.length; i < ilen; i += 1) {
                if (b[i] === e[i] && ret.length > minchars) {
                    ret.pop();
                } else {
                    if (minchars && isyear && ret.length === 3) {
                        var front = b.slice(0, i);
                        front.reverse();
                        ret = ret.concat(front);
                    }
                    break;
                }
            }
        }
        ret.reverse();
        return ret.join("");
    };
    chicago15 = function chicago15(lst) {
        len = lst.length;
        for (pos = 1; pos < len; pos += 2) {
            if ("object" === typeof lst[pos]) {
                m = lst[pos];
                begin = parseInt(m[1], 10);
                end = parseInt(m[3], 10);
                if (begin > 100 && begin % 100 && parseInt(begin / 100, 10) === parseInt(end / 100, 10)) {
                    m[3] = "" + end % 100;
                } else if (begin >= 1e4) {
                    m[3] = "" + end % 1e3;
                }
            }
            if (m[2].slice(1) === m[0]) {
                m[2] = range_delimiter;
            }
        }
        return stringify(lst);
    };
    chicago16 = function chicago16(lst) {
        len = lst.length;
        for (pos = 1; pos < len; pos += 2) {
            if ("object" === typeof lst[pos]) {
                m = lst[pos];
                begin = parseInt(m[1], 10);
                end = parseInt(m[3], 10);
                e = "" + end;
                if (begin > 100 && begin % 100) {
                    for (var i = 2; i < e.length; i++) {
                        var divisor = Math.pow(10, i);
                        if (Math.floor(begin / divisor) === Math.floor(end / divisor)) {
                            m[3] = "" + end % divisor;
                            break;
                        }
                    }
                }
            }
            if (m[2].slice(1) === m[0]) {
                m[2] = range_delimiter;
            }
        }
        return stringify(lst);
    };
    var sniff = function sniff(str, func, minchars, isyear) {
        var ret;
        str = "" + str;
        var lst = expand(str);
        var ret = func(lst, minchars, isyear);
        return ret;
    };
    if (!state.opt[rangeType + "-range-format"]) {
        ret_func = function ret_func(str) {
            return sniff(str, stringify);
        };
    } else if (state.opt[rangeType + "-range-format"] === "expanded") {
        ret_func = function ret_func(str) {
            return sniff(str, stringify);
        };
    } else if (state.opt[rangeType + "-range-format"] === "minimal") {
        ret_func = function ret_func(str) {
            return sniff(str, minimize);
        };
    } else if (state.opt[rangeType + "-range-format"] === "minimal-two") {
        ret_func = function ret_func(str, isyear) {
            return sniff(str, minimize, 2, isyear);
        };
    } else if (state.opt[rangeType + "-range-format"] === "chicago") {
        ret_func = function ret_func(str) {
            return sniff(str, chicago15);
        };
    } else if (state.opt[rangeType + "-range-format"] === "chicago-15") {
        ret_func = function ret_func(str) {
            return sniff(str, chicago15);
        };
    } else if (state.opt[rangeType + "-range-format"] === "chicago-16") {
        ret_func = function ret_func(str) {
            return sniff(str, chicago16);
        };
    }
    return ret_func;
};

CSL.Util.FlipFlopper = function(state) {
    var _nestingState = [];
    var _nestingData = {
        '<span class="nocase">': {
            type: "nocase",
            opener: '<span class="nocase">',
            closer: "</span>",
            attr: null,
            outer: null,
            flipflop: null
        },
        '<span class="nodecor">': {
            type: "nodecor",
            opener: '<span class="nodecor">',
            closer: "</span>",
            attr: "@class",
            outer: "nodecor",
            flipflop: {
                nodecor: "nodecor"
            }
        },
        '<span style="font-variant:small-caps;">': {
            type: "tag",
            opener: '<span style="font-variant:small-caps;">',
            closer: "</span>",
            attr: "@font-variant",
            outer: "small-caps",
            flipflop: {
                "small-caps": "normal",
                normal: "small-caps"
            }
        },
        "<sc>": {
            type: "tag",
            opener: "<sc>",
            closer: "</sc>",
            attr: "@font-variant",
            outer: "small-caps",
            flipflop: {
                "small-caps": "normal",
                normal: "small-caps"
            }
        },
        "<i>": {
            type: "tag",
            opener: "<i>",
            closer: "</i>",
            attr: "@font-style",
            outer: "italic",
            flipflop: {
                italic: "normal",
                normal: "italic"
            }
        },
        "<b>": {
            type: "tag",
            opener: "<b>",
            closer: "</b>",
            attr: "@font-weight",
            outer: "bold",
            flipflop: {
                bold: "normal",
                normal: "bold"
            }
        },
        "<sup>": {
            type: "tag",
            opener: "<sup>",
            closer: "</sup>",
            attr: "@vertical-align",
            outer: "sup",
            flipflop: {
                sub: "sup",
                sup: "sup"
            }
        },
        "<sub>": {
            type: "tag",
            opener: "<sub>",
            closer: "</sub>",
            attr: "@vertical-align",
            outer: "sub",
            flipflop: {
                sup: "sub",
                sub: "sub"
            }
        },
        ' "': {
            type: "quote",
            opener: ' "',
            closer: '"',
            attr: "@quotes",
            outer: "true",
            flipflop: {
                true: "inner",
                inner: "true",
                false: "true"
            }
        },
        " '": {
            type: "quote",
            opener: " '",
            closer: "'",
            attr: "@quotes",
            outer: "inner",
            flipflop: {
                true: "inner",
                inner: "true",
                false: "true"
            }
        }
    };
    _nestingData['("'] = _nestingData[' "'];
    _nestingData["('"] = _nestingData[" '"];
    var localeOpenQuote = state.getTerm("open-quote");
    var localeCloseQuote = state.getTerm("close-quote");
    var localeOpenInnerQuote = state.getTerm("open-inner-quote");
    var localeCloseInnerQuote = state.getTerm("close-inner-quote");
    if (localeOpenQuote && localeCloseQuote && [ ' "', " '", '"', "'" ].indexOf(localeOpenQuote) === -1) {
        _nestingData[localeOpenQuote] = JSON.parse(JSON.stringify(_nestingData[' "']));
        _nestingData[localeOpenQuote].opener = localeOpenQuote;
        _nestingData[localeOpenQuote].closer = localeCloseQuote;
    }
    if (localeOpenInnerQuote && localeCloseInnerQuote && [ ' "', " '", '"', "'" ].indexOf(localeOpenInnerQuote) === -1) {
        _nestingData[localeOpenInnerQuote] = JSON.parse(JSON.stringify(_nestingData[" '"]));
        _nestingData[localeOpenInnerQuote].opener = localeOpenInnerQuote;
        _nestingData[localeOpenInnerQuote].closer = localeCloseInnerQuote;
    }
    function _setOuterQuoteForm(quot) {
        var flip = {
            " '": ' "',
            ' "': " '",
            '("': "('",
            "('": '("'
        };
        _nestingData[quot].outer = "true";
        _nestingData[flip[quot]].outer = "inner";
    }
    function _getNestingOpenerParams(opener) {
        var openers = [];
        var keys = Object.keys(_nestingData);
        for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            if (_nestingData[opener].type !== "quote" || !_nestingData[opener]) {
                openers.push(key);
            }
        }
        var ret = _nestingData[opener];
        ret.opener = new RegExp("^(?:" + openers.map(function(str) {
            return str.replace("(", "\\(");
        }).join("|") + ")");
        return ret;
    }
    var _nestingParams = function() {
        var ret = {};
        var keys = Object.keys(_nestingData);
        for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            ret[key] = _getNestingOpenerParams(key);
        }
        return ret;
    }();
    var _tagRex = function() {
        var openers = [];
        var closers = [];
        var vals = {};
        for (var opener in _nestingParams) {
            openers.push(opener);
            vals[_nestingParams[opener].closer] = true;
        }
        var keys = Object.keys(vals);
        for (var i = 0, l = keys.length; i < l; i++) {
            var closer = keys[i];
            closers.push(closer);
        }
        var all = openers.concat(closers).map(function(str) {
            return str.replace("(", "\\(");
        }).join("|");
        return {
            matchAll: new RegExp("((?:" + all + "))", "g"),
            splitAll: new RegExp("(?:" + all + ")", "g"),
            open: new RegExp("(^(?:" + openers.map(function(str) {
                return str.replace("(", "\\(");
            }).join("|") + ")$)"),
            close: new RegExp("(^(?:" + closers.join("|") + ")$)")
        };
    }();
    function _tryOpen(tag, pos) {
        var params = _nestingState[_nestingState.length - 1];
        if (!params || tag.match(params.opener)) {
            _nestingState.push({
                type: _nestingParams[tag].type,
                opener: _nestingParams[tag].opener,
                closer: _nestingParams[tag].closer,
                pos: pos
            });
            return false;
        } else {
            _nestingState.pop();
            _nestingState.push({
                type: _nestingParams[tag].type,
                opener: _nestingParams[tag].opener,
                closer: _nestingParams[tag].closer,
                pos: pos
            });
            return {
                fixtag: params.pos
            };
        }
    }
    function _tryClose(tag, pos) {
        var params = _nestingState[_nestingState.length - 1];
        if (params && tag === params.closer) {
            _nestingState.pop();
            if (params.type === "nocase") {
                return {
                    nocase: {
                        open: params.pos,
                        close: pos
                    }
                };
            } else {
                return false;
            }
        } else {
            if (params) {
                return {
                    fixtag: params.pos
                };
            } else {
                return {
                    fixtag: pos
                };
            }
        }
    }
    function _pushNestingState(tag, pos) {
        if (tag.match(_tagRex.open)) {
            return _tryOpen(tag, pos);
        } else {
            return _tryClose(tag, pos);
        }
    }
    function _doppelString(str) {
        var forcedSpaces = [];
        str = str.replace(/(<span)\s+(style=\"font-variant:)\s*(small-caps);?\"[^>]*(>)/g, '$1 $2$3;"$4');
        str = str.replace(/(<span)\s+(class=\"no(?:case|decor)\")[^>]*(>)/g, "$1 $2$3");
        var match = str.match(_tagRex.matchAll);
        if (!match) {
            return {
                tags: [],
                strings: [ str ],
                forcedSpaces: []
            };
        }
        var split = str.split(_tagRex.splitAll);
        for (var i = 0, ilen = match.length - 1; i < ilen; i++) {
            if (_nestingData[match[i]]) {
                if (split[i + 1] === "" && [ '"', "'" ].indexOf(match[i + 1]) > -1) {
                    match[i + 1] = " " + match[i + 1];
                    forcedSpaces.push(true);
                } else {
                    forcedSpaces.push(false);
                }
            }
        }
        return {
            tags: match,
            strings: split,
            forcedSpaces: forcedSpaces
        };
    }
    var TagReg = function TagReg(blob) {
        var _stack = [];
        this.set = function(tag) {
            var attr = _nestingData[tag].attr;
            var decor = null;
            for (var i = _stack.length - 1; i > -1; i--) {
                var _decor = _stack[i];
                if (_decor[0] === attr) {
                    decor = _decor;
                    break;
                }
            }
            if (!decor) {
                var allTheDecor = [ state[state.tmp.area].opt.layout_decorations ].concat(blob.alldecor);
                outer: for (var i = allTheDecor.length - 1; i > -1; i--) {
                    var decorset = allTheDecor[i];
                    if (!decorset) {
                        continue;
                    }
                    for (var j = decorset.length - 1; j > -1; j--) {
                        var _decor = decorset[j];
                        if (_decor[0] === attr) {
                            decor = _decor;
                            break outer;
                        }
                    }
                }
            }
            if (!decor) {
                decor = [ attr, _nestingData[tag].outer ];
            } else {
                decor = [ attr, _nestingData[tag].flipflop[decor[1]] ];
            }
            _stack.push(decor);
        };
        this.pair = function() {
            return _stack[_stack.length - 1];
        };
        this.pop = function() {
            _stack.pop();
        };
    };
    function _apostropheForce(tag, str) {
        if (tag === "'") {
            if (str && str.match(/^[^\,\.\?\:\;\ ]/)) {
                return "’";
            }
        } else if (tag === " '" && str && str.match(/^[\ ]/)) {
            return " ’";
        }
        return false;
    }
    function _undoppelToQueue(blob, doppel, leadingSpace) {
        var firstString = true;
        var tagReg = new TagReg(blob);
        blob.blobs = [];
        function Stack(blob) {
            this.stack = [ blob ];
            this.latest = blob;
            this.addStyling = function(str, decor) {
                if (firstString) {
                    if (str.slice(0, 1) === " ") {
                        str = str.slice(1);
                    }
                    if (str.slice(0, 1) === " ") {
                        str = str.slice(1);
                    }
                    firstString = false;
                }
                this.latest = this.stack[this.stack.length - 1];
                if (decor) {
                    if ("string" === typeof this.latest.blobs) {
                        var child = new CSL.Blob;
                        child.blobs = this.latest.blobs;
                        child.alldecor = this.latest.alldecor.slice();
                        this.latest.blobs = [ child ];
                    }
                    var tok = new CSL.Token;
                    var newblob = new CSL.Blob(null, tok);
                    newblob.alldecor = this.latest.alldecor.slice();
                    if (decor[0] === "@class" && decor[1] === "nodecor") {
                        var newdecorset = [];
                        var seen = {};
                        var allTheDecor = [ state[state.tmp.area].opt.layout_decorations ].concat(newblob.alldecor);
                        for (var i = allTheDecor.length - 1; i > -1; i--) {
                            var _decorset = allTheDecor[i];
                            if (!_decorset) {
                                continue;
                            }
                            for (var j = _decorset.length - 1; j > -1; j--) {
                                var _olddecor = _decorset[j];
                                if ([ "@font-weight", "@font-style", "@font-variant" ].indexOf(_olddecor[0]) > -1 && !seen[_olddecor[0]]) {
                                    if (decor[1] !== "normal") {
                                        newblob.decorations.push([ _olddecor[0], "normal" ]);
                                        newdecorset.push([ _olddecor[0], "normal" ]);
                                    }
                                    seen[_olddecor[0]] = true;
                                }
                            }
                        }
                        newblob.alldecor.push(newdecorset);
                    } else {
                        newblob.decorations.push(decor);
                        newblob.alldecor.push([ decor ]);
                    }
                    this.latest.blobs.push(newblob);
                    this.stack.push(newblob);
                    this.latest = newblob;
                    if (str) {
                        var tok = new CSL.Token;
                        var newblob = new CSL.Blob(null, tok);
                        newblob.blobs = str;
                        newblob.alldecor = this.latest.alldecor.slice();
                        this.latest.blobs.push(newblob);
                    }
                } else {
                    if (str) {
                        var child = new CSL.Blob;
                        child.blobs = str;
                        child.alldecor = this.latest.alldecor.slice();
                        this.latest.blobs.push(child);
                    }
                }
            };
            this.popStyling = function() {
                this.stack.pop();
            };
        }
        var stack = new Stack(blob);
        if (doppel.strings.length) {
            var str = doppel.strings[0];
            if (leadingSpace) {
                str = " " + str;
            }
            stack.addStyling(str);
        }
        for (var i = 0, ilen = doppel.tags.length; i < ilen; i++) {
            var tag = doppel.tags[i];
            var str = doppel.strings[i + 1];
            if (tag.match(_tagRex.open)) {
                tagReg.set(tag);
                stack.addStyling(str, tagReg.pair());
            } else {
                tagReg.pop();
                stack.popStyling();
                stack.addStyling(str);
            }
        }
    }
    this.processTags = function(blob) {
        var str = blob.blobs;
        var leadingSpace = false;
        if (str.slice(0, 1) === " " && !str.match(/^\s+[\'\"]/)) {
            leadingSpace = true;
        }
        var rex = new RegExp("(" + CSL.ROMANESQUE_REGEXP.source + ")’(" + CSL.ROMANESQUE_REGEXP.source + ")", "g");
        var str = " " + str.replace(rex, "$1'$2");
        var doppel = _doppelString(str);
        if (doppel.tags.length === 0) {
            return;
        }
        var quoteFormSeen = false;
        for (var i = 0, ilen = doppel.tags.length; i < ilen; i++) {
            var tag = doppel.tags[i];
            var str = doppel.strings[i + 1];
            var apostrophe = _apostropheForce(tag, str);
            if (apostrophe) {
                doppel.strings[i + 1] = apostrophe + doppel.strings[i + 1];
                doppel.tags[i] = "";
            } else {
                var tagInfo;
                while (true) {
                    tagInfo = _pushNestingState(tag, i);
                    if (tagInfo) {
                        if (Object.keys(tagInfo).indexOf("fixtag") > -1) {
                            if (tag.match(_tagRex.close) && tag === "'") {
                                doppel.strings[i + 1] = "’" + doppel.strings[i + 1];
                                doppel.tags[i] = "";
                            } else {
                                var failedTag = doppel.tags[tagInfo.fixtag];
                                if (doppel.forcedSpaces[tagInfo.fixtag - 1]) {
                                    failedTag = failedTag.slice(1);
                                }
                                doppel.strings[tagInfo.fixtag + 1] = failedTag + doppel.strings[tagInfo.fixtag + 1];
                                doppel.tags[tagInfo.fixtag] = "";
                            }
                            if (_nestingState.length > 0) {
                                if (tag !== "'") {
                                    _nestingState.pop();
                                } else {
                                    break;
                                }
                            } else {
                                break;
                            }
                        } else if (tagInfo.nocase) {
                            doppel.tags[tagInfo.nocase.open] = "";
                            doppel.tags[tagInfo.nocase.close] = "";
                            break;
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }
                if (tagInfo && (tagInfo.fixtag || tagInfo.fixtag === 0)) {
                    doppel.strings[i + 1] = doppel.tags[i] + doppel.strings[i + 1];
                    doppel.tags[i] = "";
                }
            }
        }
        for (var i = _nestingState.length - 1; i > -1; i--) {
            var tagPos = _nestingState[i].pos;
            var tag = doppel.tags[tagPos];
            if (tag === " '" || tag === "'") {
                doppel.strings[tagPos + 1] = " ’" + doppel.strings[tagPos + 1];
            } else {
                doppel.strings[tagPos + 1] = doppel.tags[tagPos] + doppel.strings[tagPos + 1];
            }
            doppel.tags[tagPos] = "";
            _nestingState.pop();
        }
        for (var i = doppel.tags.length - 1; i > -1; i--) {
            if (!doppel.tags[i]) {
                doppel.tags = doppel.tags.slice(0, i).concat(doppel.tags.slice(i + 1));
                doppel.strings[i] = doppel.strings[i] + doppel.strings[i + 1];
                doppel.strings = doppel.strings.slice(0, i + 1).concat(doppel.strings.slice(i + 2));
            }
        }
        for (var i = 0, ilen = doppel.tags.length; i < ilen; i++) {
            var tag = doppel.tags[i];
            var forcedSpace = doppel.forcedSpaces[i - 1];
            if ([ ' "', " '", '("', "('" ].indexOf(tag) > -1) {
                if (!quoteFormSeen) {
                    _setOuterQuoteForm(tag);
                    quoteFormSeen = true;
                }
                if (!forcedSpace) {
                    doppel.strings[i] += tag.slice(0, 1);
                }
            }
        }
        _undoppelToQueue(blob, doppel, leadingSpace);
    };
};

CSL.Output.Formatters = function() {
    var rexStr = '(?:‘|’|“|”| "| \'|"|\'|[-–—/.,;?!:]|\\[|\\]|\\(|\\)|<span style="font-variant: small-caps;">|<span class="no(?:case|decor)">|</span>|</?(?:i|sc|b|sub|sup)>)';
    var tagDoppel = new CSL.Doppeler(rexStr, function(str) {
        return str.replace(/(<span)\s+(class=\"no(?:case|decor)\")[^>]*(>)/g, "$1 $2$3").replace(/(<span)\s+(style=\"font-variant:)\s*(small-caps);?(\")[^>]*(>)/g, "$1 $2 $3;$4$5");
    });
    var rexNameStr = '(?:[-\\s]*<\\/*(?:spans+class="no(?:case|decor)"|i|sc|b|sub|sup)>[-\\s]*|[-\\s]+)';
    var nameDoppel = new CSL.Doppeler(rexNameStr);
    var wordDoppel = new CSL.Doppeler("(?:[    -​ 　]+)");
    var _tagParams = {
        '<span style="font-variant: small-caps;">': "</span>",
        '<span class="nocase">': "</span>",
        '<span class="nodecor">': "</span>",
        "<sc>": "</sc>",
        "<sub>": "</sub>",
        "<sup>": "</sup>"
    };
    function _capitalise(word) {
        var m = word.match(/(^\s*)((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]))(.*)/);
        if (m && !(m[2].match(/^[\u0370-\u03FF]$/) && !m[3])) {
            return m[1] + CSL.toLocaleUpperCase.call(this, m[2]) + m[3];
        }
        return word;
    }
    function _textcaseEngine(config, string) {
        if (!string) {
            return "";
        }
        config.doppel = tagDoppel.split(string);
        var quoteParams = {
            ' "': {
                opener: " '",
                closer: '"'
            },
            " '": {
                opener: ' "',
                closer: "'"
            },
            "‘": {
                opener: "‘",
                closer: "’"
            },
            "“": {
                opener: "“",
                closer: "”"
            }
        };
        function tryOpen(tag, pos) {
            if (config.quoteState.length === 0 || tag === config.quoteState[config.quoteState.length - 1].opener) {
                config.quoteState.push({
                    opener: quoteParams[tag].opener,
                    closer: quoteParams[tag].closer,
                    pos: pos
                });
                return false;
            } else {
                var prevPos = config.quoteState[config.quoteState.length - 1].pos;
                config.quoteState.pop();
                config.quoteState.push({
                    opener: quoteParams[tag].opener,
                    closer: quoteParams[tag].closer,
                    positions: pos
                });
                return prevPos;
            }
        }
        function tryClose(tag, pos) {
            if (config.quoteState.length > 0 && tag === config.quoteState[config.quoteState.length - 1].closer) {
                config.quoteState.pop();
            } else {
                return pos;
            }
        }
        function pushQuoteState(tag, pos) {
            var isOpener = [ "“", "‘", ' "', " '" ].indexOf(tag) > -1 ? true : false;
            if (isOpener) {
                return tryOpen(tag, pos);
            } else {
                return tryClose(tag, pos);
            }
        }
        function quoteFix(tag, positions) {
            var m = tag.match(/(^(?:\u2018|\u2019|\u201C|\u201D|\"|\')|(?: \"| \')$)/);
            if (m) {
                return pushQuoteState(m[1], positions);
            }
        }
        if (config.doppel.strings.length && config.doppel.strings[0].trim()) {
            config.doppel.strings[0] = config.capitaliseWords(config.doppel.strings[0], 0, config.doppel.tags[0]);
        }
        for (var i = 0, ilen = config.doppel.tags.length; i < ilen; i++) {
            var tag = config.doppel.tags[i];
            var str = config.doppel.strings[i + 1];
            if (config.tagState !== null) {
                if (_tagParams[tag]) {
                    config.tagState.push(_tagParams[tag]);
                } else if (config.tagState.length && tag === config.tagState[config.tagState.length - 1]) {
                    config.tagState.pop();
                }
            }
            if (config.afterPunct !== null) {
                if (tag.match(/[\!\?\:]$/)) {
                    config.afterPunct = true;
                }
            }
            if (config.tagState.length === 0) {
                config.doppel.strings[i + 1] = config.capitaliseWords(str, i + 1, config.doppel, config.doppel.tags[i + 1]);
            } else if (config.doppel.strings[i + 1].trim()) {
                config.lastWordPos = null;
            }
            if (config.quoteState !== null) {
                var quotePos = quoteFix(tag, i);
                if (quotePos || quotePos === 0) {
                    var origChar = config.doppel.origStrings[quotePos + 1].slice(0, 1);
                    config.doppel.strings[quotePos + 1] = origChar + config.doppel.strings[quotePos + 1].slice(1);
                    config.lastWordPos = null;
                }
            }
            if (config.isFirst) {
                if (str.trim()) {
                    config.isFirst = false;
                }
            }
            if (config.afterPunct) {
                if (str.trim()) {
                    config.afterPunct = false;
                }
            }
        }
        if (config.quoteState) {
            for (var i = 0, ilen = config.quoteState.length; i < ilen; i++) {
                var quotePos = config.quoteState[i].pos;
                if (typeof quotePos !== "undefined") {
                    var origChar = config.doppel.origStrings[quotePos + 1].slice(0, 1);
                    config.doppel.strings[quotePos + 1] = origChar + config.doppel.strings[quotePos + 1].slice(1);
                }
            }
        }
        if (config.lastWordPos) {
            var lastWords = wordDoppel.split(config.doppel.strings[config.lastWordPos.strings]);
            var lastWord = lastWords.strings[config.lastWordPos.words];
            if (lastWord.length > 1 && CSL.toLocaleLowerCase.call(this, lastWord).match(config.skipWordsRex)) {
                lastWord = _capitalise.call(this, lastWord);
                lastWords.strings[config.lastWordPos.words] = lastWord;
            }
            config.doppel.strings[config.lastWordPos.strings] = wordDoppel.join(lastWords);
        }
        return tagDoppel.join(config.doppel);
    }
    function passthrough(state, str) {
        return str;
    }
    function lowercase(state, string) {
        var config = {
            quoteState: null,
            capitaliseWords: function capitaliseWords(str) {
                var words = str.split(" ");
                for (var i = 0, ilen = words.length; i < ilen; i++) {
                    var word = words[i];
                    if (word) {
                        words[i] = CSL.toLocaleLowerCase.call(state, word);
                    }
                }
                return words.join(" ");
            },
            skipWordsRex: null,
            tagState: [],
            afterPunct: null,
            isFirst: null
        };
        return _textcaseEngine.call(state, config, string);
    }
    function uppercase(state, string) {
        var config = {
            quoteState: null,
            capitaliseWords: function capitaliseWords(str) {
                var words = str.split(" ");
                for (var i = 0, ilen = words.length; i < ilen; i++) {
                    var word = words[i];
                    if (word) {
                        words[i] = CSL.toLocaleUpperCase.call(state, word);
                    }
                }
                return words.join(" ");
            },
            skipWordsRex: null,
            tagState: [],
            afterPunct: null,
            isFirst: null
        };
        return _textcaseEngine.call(state, config, string);
    }
    function sentence(state, string) {
        var config = {
            quoteState: [],
            capitaliseWords: function capitaliseWords(str) {
                var words = str.split(" ");
                for (var i = 0, ilen = words.length; i < ilen; i++) {
                    var word = words[i];
                    if (word) {
                        if (config.isFirst) {
                            words[i] = _capitalise.call(state, word);
                            config.isFirst = false;
                        } else {
                            words[i] = CSL.toLocaleLowerCase.call(state, word);
                        }
                    }
                }
                return words.join(" ");
            },
            skipWordsRex: null,
            tagState: [],
            afterPunct: null,
            isFirst: true
        };
        return _textcaseEngine.call(state, config, string);
    }
    function title(state, string) {
        var config = {
            quoteState: [],
            capitaliseWords: function capitaliseWords(str, i, followingTag) {
                if (str.trim()) {
                    var wordle = wordDoppel.split(str);
                    var words = wordle.strings;
                    for (var j = 0, jlen = words.length; j < jlen; j++) {
                        var word = words[j];
                        if (!word) {
                            continue;
                        }
                        var lcase = CSL.toLocaleLowerCase.call(state, word);
                        var capitalize = false;
                        if (word.length > 1 && !lcase.match(config.skipWordsRex)) {
                            capitalize = true;
                        } else if (j === words.length - 1 && followingTag === "-") {
                            capitalize = true;
                        } else if (config.isFirst) {
                            capitalize = true;
                        } else if (config.afterPunct) {
                            capitalize = true;
                        }
                        if (capitalize && word === lcase) {
                            words[j] = _capitalise.call(state, word);
                        }
                        config.afterPunct = false;
                        config.isFirst = false;
                        config.lastWordPos = {
                            strings: i,
                            words: j
                        };
                    }
                    str = wordDoppel.join(wordle);
                }
                return str;
            },
            skipWordsRex: state.locale[state.opt.lang].opts["skip-words-regexp"],
            tagState: [],
            afterPunct: false,
            isFirst: true
        };
        return _textcaseEngine.call(state, config, string);
    }
    function capitalizeFirst(state, string) {
        var config = {
            quoteState: [],
            capitaliseWords: function capitaliseWords(str) {
                var wordle = wordDoppel.split(str);
                var words = wordle.strings;
                for (var i = 0, ilen = words.length; i < ilen; i++) {
                    var word = words[i];
                    if (word) {
                        if (config.isFirst) {
                            if (word === CSL.toLocaleLowerCase.call(state, word)) {
                                words[i] = _capitalise.call(state, word);
                            }
                            config.isFirst = false;
                            break;
                        }
                    }
                }
                return wordDoppel.join(wordle);
            },
            skipWordsRex: null,
            tagState: [],
            afterPunct: null,
            isFirst: true
        };
        return _textcaseEngine.call(state, config, string);
    }
    function capitalizeAll(state, string) {
        var config = {
            quoteState: [],
            capitaliseWords: function capitaliseWords(str) {
                var wordle = wordDoppel.split(str);
                var words = wordle.strings;
                for (var i = 0, ilen = words.length; i < ilen; i++) {
                    var word = words[i];
                    if (word) {
                        if (word === CSL.toLocaleLowerCase.call(state, word)) {
                            words[i] = _capitalise.call(state, word);
                        }
                    }
                }
                return wordDoppel.join(wordle);
            },
            skipWordsRex: null,
            tagState: [],
            afterPunct: null,
            isFirst: null
        };
        return _textcaseEngine.call(state, config, string);
    }
    return {
        nameDoppel: nameDoppel,
        passthrough: passthrough,
        lowercase: lowercase,
        uppercase: uppercase,
        sentence: sentence,
        title: title,
        "capitalize-first": capitalizeFirst,
        "capitalize-all": capitalizeAll
    };
}();

CSL.Output.Formats = function() {};

CSL.Output.Formats.prototype.html = {
    text_escape: function text_escape(text) {
        if (!text) {
            text = "";
        }
        return text.replace(/&/g, "&#38;").replace(/</g, "&#60;").replace(/>/g, "&#62;").replace(/\s\s/g, "  ").replace(CSL.SUPERSCRIPTS_REGEXP, function(aChar) {
            return "<sup>" + CSL.SUPERSCRIPTS[aChar] + "</sup>";
        });
    },
    bibstart: '<div class="csl-bib-body">\n',
    bibend: "</div>",
    "@font-style/italic": "<i>%%STRING%%</i>",
    "@font-style/oblique": "<em>%%STRING%%</em>",
    "@font-style/normal": '<span style="font-style:normal;">%%STRING%%</span>',
    "@font-variant/small-caps": '<span style="font-variant:small-caps;">%%STRING%%</span>',
    "@passthrough/true": CSL.Output.Formatters.passthrough,
    "@font-variant/normal": '<span style="font-variant:normal;">%%STRING%%</span>',
    "@font-weight/bold": "<b>%%STRING%%</b>",
    "@font-weight/normal": '<span style="font-weight:normal;">%%STRING%%</span>',
    "@font-weight/light": false,
    "@text-decoration/none": '<span style="text-decoration:none;">%%STRING%%</span>',
    "@text-decoration/underline": '<span style="text-decoration:underline;">%%STRING%%</span>',
    "@vertical-align/sup": "<sup>%%STRING%%</sup>",
    "@vertical-align/sub": "<sub>%%STRING%%</sub>",
    "@vertical-align/baseline": '<span style="baseline">%%STRING%%</span>',
    "@strip-periods/true": CSL.Output.Formatters.passthrough,
    "@strip-periods/false": CSL.Output.Formatters.passthrough,
    "@quotes/true": function quotes_true(state, str) {
        if ("undefined" === typeof str) {
            return state.getTerm("open-quote");
        }
        return state.getTerm("open-quote") + str + state.getTerm("close-quote");
    },
    "@quotes/inner": function quotes_inner(state, str) {
        if ("undefined" === typeof str) {
            return "’";
        }
        return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
    },
    "@quotes/false": false,
    "@cite/entry": function cite_entry(state, str) {
        return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
    },
    "@bibliography/entry": function bibliography_entry(state, str) {
        var insert = "";
        if (state.sys.embedBibliographyEntry) {
            insert = state.sys.embedBibliographyEntry(this.item_id) + "\n";
        }
        return '  <div class="csl-entry">' + str + "</div>\n" + insert;
    },
    "@display/block": function display_block(state, str) {
        return '\n\n    <div class="csl-block">' + str + "</div>\n";
    },
    "@display/left-margin": function display_leftMargin(state, str) {
        return '\n    <div class="csl-left-margin">' + str + "</div>";
    },
    "@display/right-inline": function display_rightInline(state, str) {
        return '<div class="csl-right-inline">' + str + "</div>\n  ";
    },
    "@display/indent": function display_indent(state, str) {
        return '<div class="csl-indent">' + str + "</div>\n  ";
    },
    "@showid/true": function showid_true(state, str, cslid) {
        if (!state.tmp.just_looking && !state.tmp.suppress_decorations) {
            if (cslid) {
                return '<span class="' + state.opt.nodenames[cslid] + '" cslid="' + cslid + '">' + str + "</span>";
            } else if (this.params && "string" === typeof str) {
                var prePunct = "";
                if (str) {
                    var m = str.match(CSL.VARIABLE_WRAPPER_PREPUNCT_REX);
                    prePunct = m[1];
                    str = m[2];
                }
                var postPunct = "";
                if (str && CSL.SWAPPING_PUNCTUATION.indexOf(str.slice(-1)) > -1) {
                    postPunct = str.slice(-1);
                    str = str.slice(0, -1);
                }
                return state.sys.variableWrapper(this.params, prePunct, str, postPunct);
            } else {
                return str;
            }
        } else {
            return str;
        }
    },
    "@URL/true": function URL_true(state, str) {
        return '<a href="' + str + '">' + str + "</a>";
    },
    "@DOI/true": function DOI_true(state, str) {
        var doiurl = str;
        if (!str.match(/^https?:\/\//)) {
            doiurl = "https://doi.org/" + CSL.Util.encodeDoiForUrl(str);
        }
        return '<a href="' + doiurl + '">' + str + "</a>";
    }
};

CSL.Output.Formats.prototype.text = {
    text_escape: function text_escape(text) {
        if (!text) {
            text = "";
        }
        return text;
    },
    bibstart: "",
    bibend: "",
    "@font-style/italic": false,
    "@font-style/oblique": false,
    "@font-style/normal": false,
    "@font-variant/small-caps": false,
    "@passthrough/true": CSL.Output.Formatters.passthrough,
    "@font-variant/normal": false,
    "@font-weight/bold": false,
    "@font-weight/normal": false,
    "@font-weight/light": false,
    "@text-decoration/none": false,
    "@text-decoration/underline": false,
    "@vertical-align/baseline": false,
    "@vertical-align/sup": false,
    "@vertical-align/sub": false,
    "@strip-periods/true": CSL.Output.Formatters.passthrough,
    "@strip-periods/false": CSL.Output.Formatters.passthrough,
    "@quotes/true": function quotes_true(state, str) {
        if ("undefined" === typeof str) {
            return state.getTerm("open-quote");
        }
        return state.getTerm("open-quote") + str + state.getTerm("close-quote");
    },
    "@quotes/inner": function quotes_inner(state, str) {
        if ("undefined" === typeof str) {
            return "’";
        }
        return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
    },
    "@quotes/false": false,
    "@cite/entry": function cite_entry(state, str) {
        return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
    },
    "@bibliography/entry": function bibliography_entry(state, str) {
        return str + "\n";
    },
    "@display/block": function display_block(state, str) {
        return "\n" + str;
    },
    "@display/left-margin": function display_leftMargin(state, str) {
        return str + " ";
    },
    "@display/right-inline": function display_rightInline(state, str) {
        return str;
    },
    "@display/indent": function display_indent(state, str) {
        return "\n    " + str;
    },
    "@showid/true": function showid_true(state, str) {
        return str;
    },
    "@URL/true": function URL_true(state, str) {
        return str;
    },
    "@DOI/true": function DOI_true(state, str) {
        return str;
    }
};

CSL.Output.Formats.prototype.rtf = {
    text_escape: function text_escape(text) {
        if (!text) {
            text = "";
        }
        return text.replace(/([\\{}])/g, "\\$1").replace(CSL.SUPERSCRIPTS_REGEXP, function(aChar) {
            return "\\super " + CSL.SUPERSCRIPTS[aChar] + "\\nosupersub{}";
        }).replace(/[\u007F-\uFFFF]/g, function(aChar) {
            return "\\uc0\\u" + aChar.charCodeAt(0).toString() + "{}";
        }).split("\t").join("\\tab{}");
    },
    "@passthrough/true": CSL.Output.Formatters.passthrough,
    "@font-style/italic": "{\\i{}%%STRING%%}",
    "@font-style/normal": "{\\i0{}%%STRING%%}",
    "@font-style/oblique": "{\\i{}%%STRING%%}",
    "@font-variant/small-caps": "{\\scaps %%STRING%%}",
    "@font-variant/normal": "{\\scaps0{}%%STRING%%}",
    "@font-weight/bold": "{\\b{}%%STRING%%}",
    "@font-weight/normal": "{\\b0{}%%STRING%%}",
    "@font-weight/light": false,
    "@text-decoration/none": false,
    "@text-decoration/underline": "{\\ul{}%%STRING%%}",
    "@vertical-align/baseline": false,
    "@vertical-align/sup": "\\super %%STRING%%\\nosupersub{}",
    "@vertical-align/sub": "\\sub %%STRING%%\\nosupersub{}",
    "@strip-periods/true": CSL.Output.Formatters.passthrough,
    "@strip-periods/false": CSL.Output.Formatters.passthrough,
    "@quotes/true": function quotes_true(state, str) {
        if ("undefined" === typeof str) {
            return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-quote"));
        }
        return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-quote")) + str + CSL.Output.Formats.rtf.text_escape(state.getTerm("close-quote"));
    },
    "@quotes/inner": function quotes_inner(state, str) {
        if ("undefined" === typeof str) {
            return CSL.Output.Formats.rtf.text_escape("’");
        }
        return CSL.Output.Formats.rtf.text_escape(state.getTerm("open-inner-quote")) + str + CSL.Output.Formats.rtf.text_escape(state.getTerm("close-inner-quote"));
    },
    "@quotes/false": false,
    bibstart: "{\\rtf ",
    bibend: "}",
    "@display/block": "\\line{}%%STRING%%\\line\r\n",
    "@cite/entry": function cite_entry(state, str) {
        return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
    },
    "@bibliography/entry": function bibliography_entry(state, str) {
        return str;
    },
    "@display/left-margin": function display_leftMargin(state, str) {
        return str + "\\tab ";
    },
    "@display/right-inline": function display_rightInline(state, str) {
        return str + "\r\n";
    },
    "@display/indent": function display_indent(state, str) {
        return "\n\\tab " + str + "\\line\r\n";
    },
    "@showid/true": function showid_true(state, str) {
        if (!state.tmp.just_looking && !state.tmp.suppress_decorations) {
            var prePunct = "";
            if (str) {
                var m = str.match(CSL.VARIABLE_WRAPPER_PREPUNCT_REX);
                prePunct = m[1];
                str = m[2];
            }
            var postPunct = "";
            if (str && CSL.SWAPPING_PUNCTUATION.indexOf(str.slice(-1)) > -1) {
                postPunct = str.slice(-1);
                str = str.slice(0, -1);
            }
            return state.sys.variableWrapper(this.params, prePunct, str, postPunct);
        } else {
            return str;
        }
    },
    "@URL/true": function URL_true(state, str) {
        return str;
    },
    "@DOI/true": function DOI_true(state, str) {
        return str;
    }
};

CSL.Output.Formats.prototype.asciidoc = {
    text_escape: function text_escape(text) {
        if (!text) {
            text = "";
        }
        return text.replace("*", "pass:[*]", "g").replace("_", "pass:[_]", "g").replace("#", "pass:[#]", "g").replace("^", "pass:[^]", "g").replace("~", "pass:[~]", "g").replace("[[", "pass:[[[]", "g").replace("  ", "&#160; ", "g").replace(CSL.SUPERSCRIPTS_REGEXP, function(aChar) {
            return "^" + CSL.SUPERSCRIPTS[aChar] + "^";
        });
    },
    bibstart: "",
    bibend: "",
    "@passthrough/true": CSL.Output.Formatters.passthrough,
    "@font-style/italic": "__%%STRING%%__",
    "@font-style/oblique": "__%%STRING%%__",
    "@font-style/normal": false,
    "@font-variant/small-caps": "[small-caps]#%%STRING%%#",
    "@font-variant/normal": false,
    "@font-weight/bold": "**%%STRING%%**",
    "@font-weight/normal": false,
    "@font-weight/light": false,
    "@text-decoration/none": false,
    "@text-decoration/underline": "[underline]##%%STRING%%##",
    "@vertical-align/sup": "^^%%STRING%%^^",
    "@vertical-align/sub": "~~%%STRING%%~~",
    "@vertical-align/baseline": false,
    "@strip-periods/true": CSL.Output.Formatters.passthrough,
    "@strip-periods/false": CSL.Output.Formatters.passthrough,
    "@quotes/true": function quotes_true(state, str) {
        if ("undefined" === typeof str) {
            return "``";
        }
        return "``" + str + "''";
    },
    "@quotes/inner": function quotes_inner(state, str) {
        if ("undefined" === typeof str) {
            return "`";
        }
        return "`" + str + "'";
    },
    "@quotes/false": false,
    "@cite/entry": function cite_entry(state, str) {
        return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
    },
    "@bibliography/entry": function bibliography_entry(state, str) {
        return str + "\n";
    },
    "@display/block": function display_block(state, str) {
        return str;
    },
    "@display/left-margin": function display_leftMargin(state, str) {
        return str;
    },
    "@display/right-inline": function display_rightInline(state, str) {
        return " " + str;
    },
    "@display/indent": function display_indent(state, str) {
        return " " + str;
    },
    "@showid/true": function showid_true(state, str) {
        if (!state.tmp.just_looking && !state.tmp.suppress_decorations && this.params && "string" === typeof str) {
            var prePunct = "";
            if (str) {
                var m = str.match(CSL.VARIABLE_WRAPPER_PREPUNCT_REX);
                prePunct = m[1];
                str = m[2];
            }
            var postPunct = "";
            if (str && CSL.SWAPPING_PUNCTUATION.indexOf(str.slice(-1)) > -1) {
                postPunct = str.slice(-1);
                str = str.slice(0, -1);
            }
            return state.sys.variableWrapper(this.params, prePunct, str, postPunct);
        } else {
            return str;
        }
    },
    "@URL/true": function URL_true(state, str) {
        return str;
    },
    "@DOI/true": function DOI_true(state, str) {
        var doiurl = str;
        if (!str.match(/^https?:\/\//)) {
            doiurl = "https://doi.org/" + CSL.Util.encodeDoiForUrl(str);
        }
        return doiurl + "[" + str + "]";
    }
};

CSL.Output.Formats.prototype.fo = {
    text_escape: function text_escape(text) {
        if (!text) {
            text = "";
        }
        return text.replace(/&/g, "&#38;").replace(/</g, "&#60;").replace(/>/g, "&#62;").replace("  ", "&#160; ", "g").replace(CSL.SUPERSCRIPTS_REGEXP, function(aChar) {
            return '<fo:inline vertical-align="super">' + CSL.SUPERSCRIPTS[aChar] + "</fo:inline>";
        });
    },
    bibstart: "",
    bibend: "",
    "@passthrough/true": CSL.Output.Formatters.passthrough,
    "@font-style/italic": '<fo:inline font-style="italic">%%STRING%%</fo:inline>',
    "@font-style/oblique": '<fo:inline font-style="oblique">%%STRING%%</fo:inline>',
    "@font-style/normal": '<fo:inline font-style="normal">%%STRING%%</fo:inline>',
    "@font-variant/small-caps": '<fo:inline font-variant="small-caps">%%STRING%%</fo:inline>',
    "@font-variant/normal": '<fo:inline font-variant="normal">%%STRING%%</fo:inline>',
    "@font-weight/bold": '<fo:inline font-weight="bold">%%STRING%%</fo:inline>',
    "@font-weight/normal": '<fo:inline font-weight="normal">%%STRING%%</fo:inline>',
    "@font-weight/light": '<fo:inline font-weight="lighter">%%STRING%%</fo:inline>',
    "@text-decoration/none": '<fo:inline text-decoration="none">%%STRING%%</fo:inline>',
    "@text-decoration/underline": '<fo:inline text-decoration="underline">%%STRING%%</fo:inline>',
    "@vertical-align/sup": '<fo:inline vertical-align="super">%%STRING%%</fo:inline>',
    "@vertical-align/sub": '<fo:inline vertical-align="sub">%%STRING%%</fo:inline>',
    "@vertical-align/baseline": '<fo:inline vertical-align="baseline">%%STRING%%</fo:inline>',
    "@strip-periods/true": CSL.Output.Formatters.passthrough,
    "@strip-periods/false": CSL.Output.Formatters.passthrough,
    "@quotes/true": function quotes_true(state, str) {
        if ("undefined" === typeof str) {
            return state.getTerm("open-quote");
        }
        return state.getTerm("open-quote") + str + state.getTerm("close-quote");
    },
    "@quotes/inner": function quotes_inner(state, str) {
        if ("undefined" === typeof str) {
            return "’";
        }
        return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
    },
    "@quotes/false": false,
    "@cite/entry": function cite_entry(state, str) {
        return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
    },
    "@bibliography/entry": function bibliography_entry(state, str) {
        var indent = "";
        if (state.bibliography && state.bibliography.opt && state.bibliography.opt.hangingindent) {
            var hi = state.bibliography.opt.hangingindent;
            indent = ' start-indent="' + hi + 'em" text-indent="-' + hi + 'em"';
        }
        var insert = "";
        if (state.sys.embedBibliographyEntry) {
            insert = state.sys.embedBibliographyEntry(this.item_id) + "\n";
        }
        return '<fo:block id="' + this.system_id + '"' + indent + ">" + str + "</fo:block>\n" + insert;
    },
    "@display/block": function display_block(state, str) {
        return "\n  <fo:block>" + str + "</fo:block>\n";
    },
    "@display/left-margin": function display_leftMargin(state, str) {
        return '\n  <fo:table table-layout="fixed" width="100%">\n    ' + '<fo:table-column column-number="1" column-width="$$$__COLUMN_WIDTH_1__$$$"/>\n    ' + '<fo:table-column column-number="2" column-width="proportional-column-width(1)"/>\n    ' + "<fo:table-body>\n      " + "<fo:table-row>\n        " + "<fo:table-cell>\n          " + "<fo:block>" + str + "</fo:block>\n        " + "</fo:table-cell>\n        ";
    },
    "@display/right-inline": function display_rightInline(state, str) {
        return "<fo:table-cell>\n          " + "<fo:block>" + str + "</fo:block>\n        " + "</fo:table-cell>\n      " + "</fo:table-row>\n    " + "</fo:table-body>\n  " + "</fo:table>\n";
    },
    "@display/indent": function display_indent(state, str) {
        return '<fo:block margin-left="2em">' + str + "</fo:block>\n";
    },
    "@showid/true": function showid_true(state, str) {
        if (!state.tmp.just_looking && !state.tmp.suppress_decorations && this.params && "string" === typeof str) {
            var prePunct = "";
            if (str) {
                var m = str.match(CSL.VARIABLE_WRAPPER_PREPUNCT_REX);
                prePunct = m[1];
                str = m[2];
            }
            var postPunct = "";
            if (str && CSL.SWAPPING_PUNCTUATION.indexOf(str.slice(-1)) > -1) {
                postPunct = str.slice(-1);
                str = str.slice(0, -1);
            }
            return state.sys.variableWrapper(this.params, prePunct, str, postPunct);
        } else {
            return str;
        }
    },
    "@URL/true": function URL_true(state, str) {
        return "<fo:basic-link external-destination=\"url('" + str + "')\">" + str + "</fo:basic-link>";
    },
    "@DOI/true": function DOI_true(state, str) {
        var doiurl = str;
        if (!str.match(/^https?:\/\//)) {
            doiurl = "https://doi.org/" + str;
        }
        return "<fo:basic-link external-destination=\"url('" + doiurl + "')\">" + str + "</fo:basic-link>";
    }
};

CSL.Output.Formats.prototype.latex = {
    text_escape: function text_escape(text) {
        if (!text) {
            text = "";
        }
        return text;
    },
    bibstart: "\\begin{thebibliography}{4}",
    bibend: "\\end{thebibliography}",
    "@font-style/italic": "{\\em %%STRING%%}",
    "@font-style/oblique": false,
    "@font-style/normal": false,
    "@font-variant/small-caps": false,
    "@passthrough/true": CSL.Output.Formatters.passthrough,
    "@font-variant/normal": false,
    "@font-weight/bold": "{\\bf %%STRING%%}",
    "@font-weight/normal": false,
    "@font-weight/light": false,
    "@text-decoration/none": false,
    "@text-decoration/underline": false,
    "@vertical-align/baseline": false,
    "@vertical-align/sup": false,
    "@vertical-align/sub": false,
    "@strip-periods/true": CSL.Output.Formatters.passthrough,
    "@strip-periods/false": CSL.Output.Formatters.passthrough,
    "@quotes/true": function quotes_true(state, str) {
        if ("undefined" === typeof str) {
            return state.getTerm("open-quote");
        }
        return state.getTerm("open-quote") + str + state.getTerm("close-quote");
    },
    "@quotes/inner": function quotes_inner(state, str) {
        if ("undefined" === typeof str) {
            return "’";
        }
        return state.getTerm("open-inner-quote") + str + state.getTerm("close-inner-quote");
    },
    "@quotes/false": false,
    "@cite/entry": function cite_entry(state, str) {
        return state.sys.wrapCitationEntry(str, this.item_id, this.locator_txt, this.suffix_txt);
    },
    "@bibliography/entry": function bibliography_entry(state, str) {
        return "\\bibitem{" + state.sys.embedBibliographyEntry(this.item_id) + "}\n";
    },
    "@display/block": function display_block(state, str) {
        return "\n" + str;
    },
    "@display/left-margin": function display_leftMargin(state, str) {
        return str;
    },
    "@display/right-inline": function display_rightInline(state, str) {
        return str;
    },
    "@display/indent": function display_indent(state, str) {
        return "\n    " + str;
    },
    "@showid/true": function showid_true(state, str, cslid) {
        return str;
    },
    "@URL/true": function URL_true(state, str) {
        return str;
    },
    "@DOI/true": function DOI_true(state, str) {
        return str;
    }
};

CSL.Output.Formats = new CSL.Output.Formats;

CSL.Registry = function(state) {
    this.debug = false;
    this.state = state;
    this.registry = {};
    this.reflist = [];
    this.refhash = {};
    this.namereg = new CSL.Registry.NameReg(state);
    this.citationreg = new CSL.Registry.CitationReg(state);
    this.authorstrings = {};
    this.masterMap = {};
    this.mylist = [];
    this.myhash = {};
    this.deletes = [];
    this.inserts = [];
    this.uncited = {};
    this.refreshes = {};
    this.akeys = {};
    this.oldseq = {};
    this.return_data = {};
    this.ambigcites = {};
    this.ambigresets = {};
    this.sorter = new CSL.Registry.Comparifier(state, "bibliography_sort");
    this.getSortedIds = function() {
        var ret = [];
        for (var i = 0, ilen = this.reflist.length; i < ilen; i += 1) {
            ret.push("" + this.reflist[i].id);
        }
        return ret;
    };
    this.getSortedRegistryItems = function() {
        var ret = [];
        for (var i = 0, ilen = this.reflist.length; i < ilen; i += 1) {
            ret.push(this.reflist[i]);
        }
        return ret;
    };
};

CSL.Registry.prototype.init = function(itemIDs, uncited_flag) {
    var i, ilen;
    this.oldseq = {};
    if (uncited_flag) {
        this.uncited = {};
        for (var i = 0, ilen = itemIDs.length; i < ilen; i += 1) {
            if (!this.myhash[itemIDs[i]]) {
                this.mylist.push("" + itemIDs[i]);
            }
            this.uncited[itemIDs[i]] = true;
            this.myhash[itemIDs[i]] = true;
        }
    } else {
        for (var key in this.uncited) {
            itemIDs.push(key);
        }
        var myhash = {};
        for (i = itemIDs.length - 1; i > -1; i += -1) {
            if (myhash[itemIDs[i]]) {
                itemIDs = itemIDs.slice(0, i).concat(itemIDs.slice(i + 1));
            } else {
                myhash[itemIDs[i]] = true;
            }
        }
        this.mylist = itemIDs;
        this.myhash = myhash;
    }
    this.refreshes = {};
    this.touched = {};
    this.ambigsTouched = {};
    this.ambigresets = {};
};

CSL.Registry.prototype.dopurge = function(myhash) {
    for (var i = this.mylist.length - 1; i > -1; i += -1) {
        if (this.citationreg.citationsByItemId) {
            if ((!this.citationreg.citationsByItemId || !this.citationreg.citationsByItemId[this.mylist[i]]) && !myhash[this.mylist[i]]) {
                delete this.myhash[this.mylist[i]];
                delete this.uncited[this.mylist[i]];
                this.mylist = this.mylist.slice(0, i).concat(this.mylist.slice(i + 1));
            }
        }
    }
    this.dodeletes(this.myhash);
};

CSL.Registry.prototype.dodeletes = function(myhash) {
    var otheritems, key, ambig, pos, len, items, kkey, mypos, id;
    if ("string" === typeof myhash) {
        var key = myhash;
        myhash = {};
        myhash[key] = true;
    }
    for (var key in this.registry) {
        if (!myhash[key]) {
            if (this.uncited[key]) {
                continue;
            }
            otheritems = this.namereg.delitems(key);
            for (kkey in otheritems) {
                this.refreshes[kkey] = true;
            }
            ambig = this.registry[key].ambig;
            mypos = this.ambigcites[ambig].indexOf(key);
            if (mypos > -1) {
                items = this.ambigcites[ambig].slice();
                this.ambigcites[ambig] = items.slice(0, mypos).concat(items.slice(mypos + 1, items.length));
                this.ambigresets[ambig] = this.ambigcites[ambig].length;
            }
            len = this.ambigcites[ambig].length;
            for (pos = 0; pos < len; pos += 1) {
                id = "" + this.ambigcites[ambig][pos];
                this.refreshes[id] = true;
            }
            if (this.registry[key].siblings) {
                if (this.registry[key].siblings.length == 1) {
                    var loneSiblingID = this.registry[key].siblings[0];
                    if (this.registry[loneSiblingID].siblings) {
                        this.registry[loneSiblingID].siblings.pop();
                        this.registry[loneSiblingID].master = true;
                    }
                } else if (this.registry[key].siblings.length > 1) {
                    var removeIDs = [ key ];
                    if (this.registry[key].master) {
                        var newmasterID = this.registry[key].siblings[0];
                        var newmaster = this.registry[newmasterID];
                        newmaster.master = true;
                        removeIDs.push(newmasterID);
                    }
                    var buffer = [];
                    for (var k = this.registry[key].siblings.length - 1; k > -1; k += -1) {
                        var siblingID = this.registry[key].siblings.pop();
                        if (removeIDs.indexOf(siblingID) === -1) {
                            buffer.push(siblingID);
                        }
                    }
                    for (var k = buffer.length - 1; k > -1; k += -1) {
                        this.registry[key].siblings.push(buffer[k]);
                    }
                }
            }
            for (var i = this.reflist.length - 1; i > -1; i--) {
                if (this.reflist[i].id === key) {
                    this.reflist = this.reflist.slice(0, i).concat(this.reflist.slice(i + 1));
                }
            }
            delete this.registry[key];
            delete this.refhash[key];
            this.return_data.bibchange = true;
        }
    }
};

CSL.Registry.prototype.doinserts = function(mylist) {
    var item, Item, akey, newitem, abase, i, ilen;
    if ("string" === typeof mylist) {
        mylist = [ mylist ];
    }
    for (var i = 0, ilen = mylist.length; i < ilen; i += 1) {
        item = mylist[i];
        if (!this.registry[item]) {
            Item = this.state.retrieveItem(item);
            akey = CSL.getAmbiguousCite.call(this.state, Item);
            this.ambigsTouched[akey] = true;
            if (!Item.legislation_id) {
                this.akeys[akey] = true;
            }
            newitem = {
                id: "" + item,
                seq: 0,
                offset: 0,
                sortkeys: false,
                ambig: false,
                rendered: false,
                disambig: false,
                ref: Item,
                newItem: true
            };
            this.registry[item] = newitem;
            if (this.citationreg.citationsByItemId && this.citationreg.citationsByItemId[item]) {
                this.registry[item]["first-reference-note-number"] = this.citationreg.citationsByItemId[item][0].properties.noteIndex;
            }
            abase = CSL.getAmbigConfig.call(this.state);
            this.registerAmbigToken(akey, item, abase);
            this.touched[item] = true;
            this.return_data.bibchange = true;
        }
    }
};

CSL.Registry.prototype.rebuildlist = function(nosort) {
    var len, pos, item, Item;
    if (!nosort) {
        this.reflist_inserts = [];
        len = this.mylist.length;
        for (pos = 0; pos < len; pos += 1) {
            item = this.mylist[pos];
            Item = this.registry[item];
            if (Item.newItem) {
                this.reflist_inserts.push(Item);
            }
            this.oldseq[item] = this.registry[item].seq;
            this.registry[item].seq = pos + 1;
        }
    } else {
        this.reflist = [];
        len = this.mylist.length;
        for (pos = 0; pos < len; pos += 1) {
            item = this.mylist[pos];
            Item = this.registry[item];
            this.reflist.push(Item);
            this.oldseq[item] = this.registry[item].seq;
            this.registry[item].seq = pos + 1;
        }
    }
};

CSL.Registry.prototype.dorefreshes = function() {
    var key, regtoken, Item, akey, abase;
    for (var key in this.refreshes) {
        regtoken = this.registry[key];
        if (!regtoken) {
            continue;
        }
        regtoken.sortkeys = undefined;
        Item = this.state.refetchItem(key);
        var akey = regtoken.ambig;
        if ("undefined" === typeof akey) {
            this.state.tmp.disambig_settings = false;
            akey = CSL.getAmbiguousCite.call(this.state, Item);
            abase = CSL.getAmbigConfig.call(this.state);
            this.registerAmbigToken(akey, key, abase);
        }
        for (var akkey in this.ambigresets) {
            if (this.ambigresets[akkey] === 1) {
                var loneKey = this.ambigcites[akey][0];
                var Item = this.state.refetchItem(loneKey);
                this.registry[loneKey].disambig = new CSL.AmbigConfig;
                this.state.tmp.disambig_settings = false;
                var akey = CSL.getAmbiguousCite.call(this.state, Item);
                var abase = CSL.getAmbigConfig.call(this.state);
                this.registerAmbigToken(akey, loneKey, abase);
            }
        }
        this.state.tmp.taintedItemIDs[key] = true;
        this.ambigsTouched[akey] = true;
        if (!Item.legislation_id) {
            this.akeys[akey] = true;
        }
        this.touched[key] = true;
    }
};

CSL.Registry.prototype.setdisambigs = function() {
    for (var akey in this.ambigsTouched) {
        this.state.disambiguate.run(akey);
    }
    this.ambigsTouched = {};
    this.akeys = {};
};

CSL.Registry.prototype.renumber = function() {
    var len, pos, item;
    if (this.state.bibliography_sort.opt.citation_number_sort_direction === CSL.DESCENDING) {
        this.state.bibliography_sort.tmp.citation_number_map = {};
    }
    len = this.reflist.length;
    for (pos = 0; pos < len; pos += 1) {
        item = this.reflist[pos];
        item.seq = pos + 1;
        if (this.state.bibliography_sort.opt.citation_number_sort_direction === CSL.DESCENDING) {
            this.state.bibliography_sort.tmp.citation_number_map[item.seq] = this.reflist.length - item.seq + 1;
        }
        if (this.state.opt.update_mode === CSL.NUMERIC && item.seq != this.oldseq[item.id]) {
            this.state.tmp.taintedItemIDs[item.id] = true;
        }
        if (item.seq != this.oldseq[item.id]) {
            this.return_data.bibchange = true;
        }
    }
};

CSL.Registry.prototype.setsortkeys = function() {
    var key;
    for (var i = 0, ilen = this.mylist.length; i < ilen; i += 1) {
        var key = this.mylist[i];
        if (this.touched[key] || this.state.tmp.taintedItemIDs[key] || !this.registry[key].sortkeys) {
            this.registry[key].sortkeys = CSL.getSortKeys.call(this.state, this.state.retrieveItem(key), "bibliography_sort");
        }
    }
};

CSL.Registry.prototype._insertItem = function(element, array) {
    array.splice(this._locationOf(element, array) + 1, 0, element);
    return array;
};

CSL.Registry.prototype._locationOf = function(element, array, start, end) {
    if (array.length === 0) {
        return -1;
    }
    start = start || 0;
    end = end || array.length;
    var pivot = start + end >> 1;
    var c = this.sorter.compareKeys(element, array[pivot]);
    if (end - start <= 1) {
        return c == -1 ? pivot - 1 : pivot;
    }
    switch (c) {
      case -1:
        return this._locationOf(element, array, start, pivot);

      case 0:
        return pivot;

      case 1:
        return this._locationOf(element, array, pivot, end);
    }
};

CSL.Registry.prototype.sorttokens = function(nosort) {
    var len, item, Item, pos;
    if (!nosort) {
        this.reflist_inserts = [];
        len = this.mylist.length;
        for (pos = 0; pos < len; pos += 1) {
            item = this.mylist[pos];
            Item = this.registry[item];
            if (Item.newItem) {
                this.reflist_inserts.push(Item);
            }
        }
        for (var key in this.state.tmp.taintedItemIDs) {
            if (this.registry[key] && !this.registry[key].newItem) {
                for (var i = this.reflist.length - 1; i > -1; i--) {
                    if (this.reflist[i].id === key) {
                        this.reflist_inserts.push(this.reflist[i]);
                        this.reflist = this.reflist.slice(0, i).concat(this.reflist.slice(i + 1));
                    }
                }
            }
        }
        for (var i = 0, ilen = this.reflist_inserts.length; i < ilen; i++) {
            var Item = this.reflist_inserts[i];
            delete Item.newItem;
            this.reflist = this._insertItem(Item, this.reflist);
        }
        for (pos = 0; pos < len; pos += 1) {
            item = this.mylist[pos];
            Item = this.registry[item];
            this.registry[item].seq = pos + 1;
        }
    }
};

CSL.Registry.Comparifier = function(state, keyset) {
    var sort_directions, len, pos, compareKeys;
    var sortCompare = CSL.getSortCompare.call(state, state.opt["default-locale-sort"]);
    sort_directions = state[keyset].opt.sort_directions;
    this.compareKeys = function(a, b) {
        len = a.sortkeys ? a.sortkeys.length : 0;
        for (pos = 0; pos < len; pos += 1) {
            var cmp = 0;
            if (a.sortkeys[pos] === b.sortkeys[pos]) {
                cmp = 0;
            } else if ("undefined" === typeof a.sortkeys[pos]) {
                cmp = sort_directions[pos][1];
            } else if ("undefined" === typeof b.sortkeys[pos]) {
                cmp = sort_directions[pos][0];
            } else {
                cmp = sortCompare(a.sortkeys[pos], b.sortkeys[pos]);
            }
            if (0 < cmp) {
                return sort_directions[pos][1];
            } else if (0 > cmp) {
                return sort_directions[pos][0];
            }
        }
        if (a.seq > b.seq) {
            return 1;
        } else if (a.seq < b.seq) {
            return -1;
        }
        return 0;
    };
    compareKeys = this.compareKeys;
    this.compareCompositeKeys = function(a, b) {
        return compareKeys(a[1], b[1]);
    };
};

CSL.Registry.prototype.compareRegistryTokens = function(a, b) {
    if (a.seq > b.seq) {
        return 1;
    } else if (a.seq < b.seq) {
        return -1;
    }
    return 0;
};

CSL.Registry.prototype.registerAmbigToken = function(akey, id, ambig_config) {
    if (!this.registry[id]) {
        CSL.debug("Warning: unregistered item: itemID=(" + id + "), akey=(" + akey + ")");
    }
    if (this.registry[id] && this.registry[id].disambig && this.registry[id].disambig.names) {
        for (var i = 0, ilen = ambig_config.names.length; i < ilen; i += 1) {
            var new_names_params = ambig_config.names[i];
            var old_names_params = this.registry[id].disambig.names[i];
            if (new_names_params !== old_names_params) {
                this.state.tmp.taintedItemIDs[id] = true;
            } else if (ambig_config.givens[i]) {
                for (var j = 0, jlen = ambig_config.givens[i].length; j < jlen; j += 1) {
                    var new_gnames_params = ambig_config.givens[i][j];
                    var old_gnames_params = this.registry[id].disambig.givens[i][j];
                    if (new_gnames_params !== old_gnames_params) {
                        this.state.tmp.taintedItemIDs[id] = true;
                    }
                }
            }
        }
    }
    if (!this.ambigcites[akey]) {
        this.ambigcites[akey] = [];
    }
    if (this.ambigcites[akey].indexOf("" + id) === -1) {
        this.ambigcites[akey].push("" + id);
    }
    this.registry[id].ambig = akey;
    this.registry[id].disambig = CSL.cloneAmbigConfig(ambig_config);
};

CSL.getSortKeys = function(Item, key_type) {
    var area, root, extension, strip_prepositions, len, pos;
    area = this.tmp.area;
    root = this.tmp.root;
    extension = this.tmp.extension;
    strip_prepositions = CSL.Util.Sort.strip_prepositions;
    this.tmp.area = key_type;
    this.tmp.root = key_type.indexOf("_") > -1 ? key_type.slice(0, -5) : key_type;
    this.tmp.extension = "_sort";
    this.tmp.disambig_override = true;
    this.tmp.disambig_request = false;
    this.tmp.suppress_decorations = true;
    CSL.getCite.call(this, Item);
    this.tmp.suppress_decorations = false;
    this.tmp.disambig_override = false;
    len = this[key_type].keys.length;
    for (pos = 0; pos < len; pos += 1) {
        this[key_type].keys[pos] = strip_prepositions(this[key_type].keys[pos]);
    }
    this.tmp.area = area;
    this.tmp.root = root;
    this.tmp.extension = extension;
    return this[key_type].keys;
};

CSL.Registry.NameReg = function(state) {
    var pkey, ikey, skey, dagopt, gdropt, items, strip_periods, set_keys, evalname, delitems, addname, myitems;
    this.state = state;
    this.namereg = {};
    this.nameind = {};
    this.nameindpkeys = {};
    this.itemkeyreg = {};
    strip_periods = function strip_periods(str) {
        if (!str) {
            str = "";
        }
        return str.replace(/\./g, " ").replace(/\s+/g, " ").replace(/\s+$/, "");
    };
    set_keys = function set_keys(state, itemid, nameobj) {
        pkey = strip_periods(nameobj.family);
        if (state.opt["demote-non-dropping-particle"] === "never" && nameobj["non-dropping-particle"] && nameobj["family"]) {
            pkey = "".concat(pkey, " ").concat(nameobj["non-dropping-particle"]);
        }
        skey = strip_periods(nameobj.given);
        var m = skey.match(/[,\!]* ([^,]+)$/);
        if (m && m[1] === m[1].toLowerCase()) {
            skey = skey.replace(/[,\!]* [^,]+$/, "");
        }
        ikey = CSL.Util.Names.initializeWith(state, skey, "%s");
        if (state.citation.opt["givenname-disambiguation-rule"] === "by-cite") {
            pkey = "" + itemid + pkey;
        }
    };
    evalname = function evalname(item_id, nameobj, namenum, request_base, form, initials) {
        var param;
        if (state.tmp.area.slice(0, 12) === "bibliography" && !form) {
            if ("string" === typeof initials) {
                return 1;
            } else {
                return 2;
            }
        }
        var res = state.nameOutput.getName(nameobj, "locale-translit", true);
        nameobj = res.name;
        set_keys(this.state, "" + item_id, nameobj);
        param = 2;
        dagopt = state.opt["disambiguate-add-givenname"];
        gdropt = state.citation.opt["givenname-disambiguation-rule"];
        var gdropt_orig = gdropt;
        if (gdropt === "by-cite") {
            gdropt = "all-names";
        }
        if ("short" === form) {
            param = 0;
        } else if ("string" === typeof initials) {
            param = 1;
        }
        if ("undefined" === typeof this.namereg[pkey] || "undefined" === typeof this.namereg[pkey].ikey[ikey]) {
            return param;
        }
        if (gdropt_orig === "by-cite" && param <= request_base) {
            return request_base;
        }
        if (!dagopt) {
            return param;
        }
        if ("string" === typeof gdropt && gdropt.slice(0, 12) === "primary-name" && namenum > 0) {
            return param;
        }
        if (!gdropt || gdropt === "all-names" || gdropt === "primary-name") {
            if (this.namereg[pkey].count > 1) {
                param = 1;
            }
            if (this.namereg[pkey].ikey && this.namereg[pkey].ikey[ikey].count > 1 || this.namereg[pkey].count > 1 && "string" !== typeof initials) {
                param = 2;
            }
        } else if (gdropt === "all-names-with-initials" || gdropt === "primary-name-with-initials") {
            if (this.namereg[pkey].count > 1) {
                param = 1;
            } else {
                param = 0;
            }
        }
        if (!state.registry.registry[item_id]) {
            if (form == "short") {
                return 0;
            } else if ("string" == typeof initials) {
                return 1;
            }
        } else {
            return param;
        }
    };
    delitems = function delitems(ids) {
        var pos, len, posB, id, fullkey;
        if ("string" === typeof ids || "number" === typeof ids) {
            ids = [ "" + ids ];
        }
        var ret = {};
        len = ids.length;
        for (pos = 0; pos < len; pos += 1) {
            id = "" + ids[pos];
            if (!this.nameind[id]) {
                continue;
            }
            for (fullkey in this.nameind[id]) {
                if (this.nameind[id].hasOwnProperty(fullkey)) {
                    var key = fullkey.split("::");
                    pkey = key[0];
                    ikey = key[1];
                    skey = key[2];
                    if ("undefined" === typeof this.namereg[pkey]) {
                        continue;
                    }
                    items = this.namereg[pkey].items;
                    if (skey && this.namereg[pkey].ikey[ikey] && this.namereg[pkey].ikey[ikey].skey[skey]) {
                        myitems = this.namereg[pkey].ikey[ikey].skey[skey].items;
                        posB = myitems.indexOf("" + id);
                        if (posB > -1) {
                            this.namereg[pkey].ikey[ikey].skey[skey].items = myitems.slice(0, posB).concat(myitems.slice([ posB + 1 ]));
                        }
                        if (this.namereg[pkey].ikey[ikey].skey[skey].items.length === 0) {
                            delete this.namereg[pkey].ikey[ikey].skey[skey];
                            this.namereg[pkey].ikey[ikey].count += -1;
                            if (this.namereg[pkey].ikey[ikey].count < 2) {
                                for (var i = 0, ilen = this.namereg[pkey].ikey[ikey].items.length; i < ilen; i += 1) {
                                    state.tmp.taintedItemIDs[this.namereg[pkey].ikey[ikey].items[i]] = true;
                                }
                            }
                        }
                    }
                    if (ikey && this.namereg[pkey].ikey[ikey]) {
                        posB = this.namereg[pkey].ikey[ikey].items.indexOf("" + id);
                        if (posB > -1) {
                            items = this.namereg[pkey].ikey[ikey].items.slice();
                            this.namereg[pkey].ikey[ikey].items = items.slice(0, posB).concat(items.slice([ posB + 1 ]));
                        }
                        if (this.namereg[pkey].ikey[ikey].items.length === 0) {
                            delete this.namereg[pkey].ikey[ikey];
                            this.namereg[pkey].count += -1;
                            if (this.namereg[pkey].count < 2) {
                                for (var i = 0, ilen = this.namereg[pkey].items.length; i < ilen; i += 1) {
                                    state.tmp.taintedItemIDs[this.namereg[pkey].items[i]] = true;
                                }
                            }
                        }
                    }
                    if (pkey) {
                        posB = this.namereg[pkey].items.indexOf("" + id);
                        if (posB > -1) {
                            items = this.namereg[pkey].items.slice();
                            this.namereg[pkey].items = items.slice(0, posB).concat(items.slice([ posB + 1 ], items.length));
                        }
                        if (this.namereg[pkey].items.length < 2) {
                            delete this.namereg[pkey];
                        }
                    }
                    delete this.nameind[id][fullkey];
                }
            }
            delete this.nameind[id];
            delete this.nameindpkeys[id];
        }
        return ret;
    };
    addname = function addname(item_id, nameobj, pos) {
        var i, ilen;
        var res = state.nameOutput.getName(nameobj, "locale-translit", true);
        nameobj = res.name;
        if (state.citation.opt["givenname-disambiguation-rule"] && state.citation.opt["givenname-disambiguation-rule"].slice(0, 8) === "primary-" && pos !== 0) {
            return;
        }
        set_keys(this.state, "" + item_id, nameobj);
        if (pkey) {
            if ("undefined" === typeof this.namereg[pkey]) {
                this.namereg[pkey] = {};
                this.namereg[pkey].count = 0;
                this.namereg[pkey].ikey = {};
                this.namereg[pkey].items = [ item_id ];
            } else if (this.namereg[pkey].items.indexOf(item_id) === -1) {
                this.namereg[pkey].items.push(item_id);
            }
        }
        if (pkey && ikey) {
            if ("undefined" === typeof this.namereg[pkey].ikey[ikey]) {
                this.namereg[pkey].ikey[ikey] = {};
                this.namereg[pkey].ikey[ikey].count = 0;
                this.namereg[pkey].ikey[ikey].skey = {};
                this.namereg[pkey].ikey[ikey].items = [ item_id ];
                this.namereg[pkey].count += 1;
                if (this.namereg[pkey].count === 2) {
                    for (var i = 0, ilen = this.namereg[pkey].items.length; i < ilen; i += 1) {
                        state.tmp.taintedItemIDs[this.namereg[pkey].items[i]] = true;
                    }
                }
            } else if (this.namereg[pkey].ikey[ikey].items.indexOf(item_id) === -1) {
                this.namereg[pkey].ikey[ikey].items.push(item_id);
            }
        }
        if (pkey && ikey && skey) {
            if ("undefined" === typeof this.namereg[pkey].ikey[ikey].skey[skey]) {
                this.namereg[pkey].ikey[ikey].skey[skey] = {};
                this.namereg[pkey].ikey[ikey].skey[skey].items = [ item_id ];
                this.namereg[pkey].ikey[ikey].count += 1;
                if (this.namereg[pkey].ikey[ikey].count === 2) {
                    for (var i = 0, ilen = this.namereg[pkey].ikey[ikey].items.length; i < ilen; i += 1) {
                        state.tmp.taintedItemIDs[this.namereg[pkey].ikey[ikey].items[i]] = true;
                    }
                }
            } else if (this.namereg[pkey].ikey[ikey].skey[skey].items.indexOf(item_id) === -1) {
                this.namereg[pkey].ikey[ikey].skey[skey].items.push(item_id);
            }
        }
        if ("undefined" === typeof this.nameind[item_id]) {
            this.nameind[item_id] = {};
            this.nameindpkeys[item_id] = {};
        }
        if (pkey) {
            this.nameind[item_id][pkey + "::" + ikey + "::" + skey] = true;
            this.nameindpkeys[item_id][pkey] = this.namereg[pkey];
        }
    };
    this.addname = addname;
    this.delitems = delitems;
    this.evalname = evalname;
};

CSL.Registry.CitationReg = function() {
    this.citationById = {};
    this.citationByIndex = [];
};

CSL.Disambiguation = function(state) {
    this.state = state;
    this.sys = this.state.sys;
    this.registry = state.registry.registry;
    this.ambigcites = state.registry.ambigcites;
    this.configModes();
    this.debug = false;
};

CSL.Disambiguation.prototype.run = function(akey) {
    if (!this.modes.length) {
        return;
    }
    if (this.debug) {
        this.state.sys.print("[A] === RUN ===");
    }
    this.akey = akey;
    if (this.initVars(akey)) {
        this.runDisambig();
    }
};

CSL.Disambiguation.prototype.runDisambig = function() {
    var ismax;
    if (this.debug) {
        this.state.sys.print("[C] === runDisambig() ===");
    }
    this.initGivens = true;
    while (this.lists.length) {
        this.gnameset = 0;
        this.gname = 0;
        this.clashes = [ 1, 0 ];
        while (this.lists[0][1].length) {
            this.listpos = 0;
            if (!this.base) {
                this.base = this.lists[0][0];
            }
            ismax = this.incrementDisambig();
            this.scanItems(this.lists[0]);
            this.evalScan(ismax);
        }
        this.lists = this.lists.slice(1);
    }
};

CSL.Disambiguation.prototype.scanItems = function(list) {
    var pos, len, otherItem;
    if (this.debug) {
        this.state.sys.print("[2] === scanItems() ===");
    }
    this.Item = list[1][0];
    this.ItemCite = CSL.getAmbiguousCite.call(this.state, this.Item, this.base, true);
    this.scanlist = list[1];
    this.partners = [];
    this.partners.push(this.Item);
    this.nonpartners = [];
    var clashes = 0;
    for (var pos = 1, len = list[1].length; pos < len; pos += 1) {
        otherItem = list[1][pos];
        var otherItemCite = CSL.getAmbiguousCite.call(this.state, otherItem, this.base, true);
        if (this.debug) {
            if (pos > 1) {
                this.state.sys.print("  -----------");
            }
        }
        if (this.ItemCite === otherItemCite) {
            if (this.debug) {
                this.state.sys.print("  [CLASH]--\x3e " + this.Item.id + ": " + this.ItemCite);
                this.state.sys.print("             " + otherItem.id + ": " + otherItemCite);
            }
            clashes += 1;
            this.partners.push(otherItem);
        } else {
            if (this.debug) {
                this.state.sys.print("  [clear]--\x3e " + this.Item.id + ": " + this.ItemCite);
                this.state.sys.print("             " + otherItem.id + ": " + otherItemCite);
            }
            this.nonpartners.push(otherItem);
        }
    }
    this.clashes[0] = this.clashes[1];
    this.clashes[1] = clashes;
};

CSL.Disambiguation.prototype.evalScan = function(maxed) {
    this[this.modes[this.modeindex]](maxed);
    if (maxed) {
        if (this.modeindex < this.modes.length - 1) {
            this.modeindex += 1;
        } else {
            this.lists[this.listpos + 1] = [ this.base, [] ];
        }
    }
};

CSL.Disambiguation.prototype.disNames = function(ismax) {
    var i, ilen;
    if (this.debug) {
        this.state.sys.print("[3] == disNames() ==");
    }
    if (this.clashes[1] === 0 && this.nonpartners.length === 1) {
        this.captureStepToBase();
        if (this.debug) {
            this.state.sys.print("  ** RESOLUTION [a]: lone partner, one nonpartner");
            this.state.sys.print("  registering " + this.partners[0].id + " and " + this.nonpartners[0].id);
        }
        this.state.registry.registerAmbigToken(this.akey, "" + this.nonpartners[0].id, this.betterbase);
        this.state.registry.registerAmbigToken(this.akey, "" + this.partners[0].id, this.betterbase);
        this.lists[this.listpos] = [ this.betterbase, [] ];
    } else if (this.clashes[1] === 0) {
        this.captureStepToBase();
        if (this.debug) {
            this.state.sys.print("  ** RESOLUTION [b]: lone partner, unknown number of remaining nonpartners");
            this.state.sys.print("  registering " + this.partners[0].id);
        }
        this.state.registry.registerAmbigToken(this.akey, "" + this.partners[0].id, this.betterbase);
        this.lists[this.listpos] = [ this.betterbase, this.nonpartners ];
        if (this.nonpartners.length) {
            this.initGivens = true;
        }
    } else if (this.nonpartners.length === 1) {
        this.captureStepToBase();
        if (this.debug) {
            this.state.sys.print("  ** RESOLUTION [c]: lone nonpartner, unknown number of partners remaining");
            this.state.sys.print("  registering " + this.nonpartners[0].id);
        }
        this.state.registry.registerAmbigToken(this.akey, "" + this.nonpartners[0].id, this.betterbase);
        this.lists[this.listpos] = [ this.betterbase, this.partners ];
    } else if (this.clashes[1] < this.clashes[0]) {
        this.captureStepToBase();
        if (this.debug) {
            this.state.sys.print("  ** RESOLUTION [d]: better result, but no entries safe to register");
        }
        this.lists[this.listpos] = [ this.betterbase, this.partners ];
        this.lists.push([ this.betterbase, this.nonpartners ]);
    } else {
        if (this.debug) {
            this.state.sys.print("  ** RESOLUTION [e]: no improvement, and clashes remain");
        }
        if (ismax) {
            this.lists[this.listpos] = [ this.betterbase, this.nonpartners ];
            this.lists.push([ this.betterbase, this.partners ]);
            if (this.modeindex === this.modes.length - 1) {
                if (this.debug) {
                    this.state.sys.print("     (registering clashing entries because we've run out of options)");
                }
                for (var i = 0, ilen = this.partners.length; i < ilen; i += 1) {
                    this.state.registry.registerAmbigToken(this.akey, "" + this.partners[i].id, this.betterbase);
                }
                this.lists[this.listpos] = [ this.betterbase, [] ];
            }
        }
    }
};

CSL.Disambiguation.prototype.disExtraText = function() {
    if (this.debug) {
        this.state.sys.print("[3] === disExtraText ==");
    }
    var done = false;
    if (this.clashes[1] === 0 && this.nonpartners.length < 2) {
        done = true;
    }
    if (!done && (!this.base.disambiguate || this.state.tmp.disambiguate_count !== this.state.tmp.disambiguate_maxMax)) {
        this.modeindex = 0;
        this.base.disambiguate = this.state.tmp.disambiguate_count;
        this.betterbase.disambiguate = this.state.tmp.disambiguate_count;
        if (!this.base.disambiguate) {
            this.initGivens = true;
            this.base.disambiguate = 1;
            for (var i = 0, ilen = this.lists[this.listpos][1].length; i < ilen; i += 1) {
                this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id] = true;
            }
        } else {
            this.disNames();
        }
    } else if (done || this.state.tmp.disambiguate_count === this.state.tmp.disambiguate_maxMax) {
        if (done || this.modeindex === this.modes.length - 1) {
            var base = this.lists[this.listpos][0];
            for (var i = 0, ilen = this.lists[this.listpos][1].length; i < ilen; i += 1) {
                this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id] = true;
                this.state.registry.registerAmbigToken(this.akey, "" + this.lists[this.listpos][1][i].id, base);
            }
            this.lists[this.listpos] = [ this.betterbase, [] ];
        } else {
            this.modeindex = this.modes.length - 1;
            var base = this.lists[this.listpos][0];
            base.disambiguate = true;
            for (var i = 0, ilen = this.lists[this.listpos][1].length; i < ilen; i += 1) {
                this.state.tmp.taintedItemIDs[this.lists[this.listpos][1][i].id] = true;
                this.state.registry.registerAmbigToken(this.akey, "" + this.lists[this.listpos][1][i].id, base);
            }
        }
    }
};

CSL.Disambiguation.prototype.disYears = function() {
    var pos, len, tokens, token;
    if (this.debug) {
        this.state.sys.print("[3] === disYears ==");
    }
    tokens = [];
    var base = this.lists[this.listpos][0];
    if (this.clashes[1]) {
        for (var i = 0, ilen = this.state.registry.mylist.length; i < ilen; i += 1) {
            var origid = this.state.registry.mylist[i];
            for (var j = 0, jlen = this.lists[this.listpos][1].length; j < jlen; j += 1) {
                var token = this.lists[this.listpos][1][j];
                if (token.id == origid) {
                    tokens.push(this.registry[token.id]);
                    break;
                }
            }
        }
    }
    tokens.sort(this.state.registry.sorter.compareKeys);
    for (var pos = 0, len = tokens.length; pos < len; pos += 1) {
        base.year_suffix = "" + pos;
        var oldBase = this.state.registry.registry[tokens[pos].id].disambig;
        this.state.registry.registerAmbigToken(this.akey, "" + tokens[pos].id, base);
        if (CSL.ambigConfigDiff(oldBase, base)) {
            this.state.tmp.taintedItemIDs[tokens[pos].id] = true;
        }
    }
    this.lists[this.listpos] = [ this.betterbase, [] ];
};

CSL.Disambiguation.prototype.incrementDisambig = function() {
    if (this.debug) {
        this.state.sys.print("\n[1] === incrementDisambig() ===");
    }
    if (this.initGivens) {
        this.initGivens = false;
        return false;
    }
    var maxed = false;
    var increment_names = true;
    if ("disNames" === this.modes[this.modeindex]) {
        increment_names = false;
        if ("number" !== typeof this.givensMax) {
            increment_names = true;
        }
        var increment_namesets = false;
        if ("number" !== typeof this.namesMax) {
            increment_namesets = true;
        }
        if ("number" === typeof this.givensMax) {
            if (this.base.givens.length && this.base.givens[this.gnameset][this.gname] < this.givensMax) {
                this.base.givens[this.gnameset][this.gname] += 1;
            } else {
                increment_names = true;
            }
        }
        if ("number" === typeof this.namesMax && increment_names) {
            if (this.state.opt["disambiguate-add-names"]) {
                increment_namesets = false;
                if (this.gname < this.namesMax) {
                    this.base.names[this.gnameset] += 1;
                    this.gname += 1;
                } else {
                    increment_namesets = true;
                }
            } else {
                increment_namesets = true;
            }
        }
        if ("number" === typeof this.namesetsMax && increment_namesets) {
            if (this.gnameset < this.namesetsMax) {
                this.gnameset += 1;
                this.base.names[this.gnameset] = 1;
                this.gname = 0;
            }
        }
        if (this.debug) {
            this.state.sys.print("    ------------------");
            this.state.sys.print("    incremented values");
            this.state.sys.print("    ------------------");
            this.state.sys.print("    | gnameset: " + this.gnameset);
            this.state.sys.print("    | gname: " + this.gname);
            this.state.sys.print("    | names value: " + this.base.names[this.gnameset]);
            if (this.base.givens.length) {
                this.state.sys.print("    | givens value: " + this.base.givens[this.gnameset][this.gname]);
            } else {
                this.state.sys.print("    | givens value: nil");
            }
            this.state.sys.print("    | namesetsMax: " + this.namesetsMax);
            this.state.sys.print("    | namesMax: " + this.namesMax);
            this.state.sys.print("    | givensMax: " + this.givensMax);
        }
        if (("number" !== typeof this.namesetsMax || this.namesetsMax === -1 || this.gnameset === this.namesetsMax) && (!this.state.opt["disambiguate-add-names"] || "number" !== typeof this.namesMax || this.gname === this.namesMax) && ("number" != typeof this.givensMax || "undefined" === typeof this.base.givens[this.gnameset] || "undefined" === typeof this.base.givens[this.gnameset][this.gname] || this.base.givens[this.gnameset][this.gname] === this.givensMax)) {
            maxed = true;
            if (this.debug) {
                this.state.sys.print("    MAXED");
            }
        }
    } else if ("disExtraText" === this.modes[this.modeindex]) {
        this.base.disambiguate += 1;
        this.betterbase.disambiguate += 1;
    }
    return maxed;
};

CSL.Disambiguation.prototype.initVars = function(akey) {
    var i, ilen, myIds, myItemBundles, myItems;
    if (this.debug) {
        this.state.sys.print("[B] === initVars() ===");
    }
    this.lists = [];
    this.base = false;
    this.betterbase = false;
    this.akey = akey;
    this.maxNamesByItemId = {};
    myItemBundles = [];
    myIds = this.ambigcites[akey];
    if (!myIds || !myIds.length) {
        return false;
    }
    var myItem = this.state.refetchItem("" + myIds[0]);
    this.getCiteData(myItem);
    this.base = CSL.getAmbigConfig.call(this.state);
    if (myIds && myIds.length > 1) {
        myItemBundles.push([ this.maxNamesByItemId[myItem.id], myItem ]);
        for (var i = 1, ilen = myIds.length; i < ilen; i += 1) {
            myItem = this.state.refetchItem("" + myIds[i]);
            this.getCiteData(myItem, this.base);
            myItemBundles.push([ this.maxNamesByItemId[myItem.id], myItem ]);
        }
        myItemBundles.sort(function(a, b) {
            if (a[0] > b[0]) {
                return 1;
            } else if (a[0] < b[0]) {
                return -1;
            } else {
                if (a[1].id > b[1].id) {
                    return 1;
                } else if (a[1].id < b[1].id) {
                    return -1;
                } else {
                    return 0;
                }
            }
        });
        myItems = [];
        for (var i = 0, ilen = myItemBundles.length; i < ilen; i += 1) {
            myItems.push(myItemBundles[i][1]);
        }
        this.lists.push([ this.base, myItems ]);
        this.Item = this.lists[0][1][0];
    } else {
        this.Item = this.state.refetchItem("" + myIds[0]);
    }
    this.modeindex = 0;
    var i, ilen;
    if (this.state.citation.opt["disambiguate-add-names"] || true) {
        this.namesMax = this.maxNamesByItemId[this.Item.id][0];
    }
    this.padBase(this.base);
    this.padBase(this.betterbase);
    this.base.year_suffix = false;
    this.base.disambiguate = false;
    this.betterbase.year_suffix = false;
    this.betterbase.disambiguate = false;
    if (this.state.citation.opt["givenname-disambiguation-rule"] === "by-cite" && this.state.opt["disambiguate-add-givenname"]) {
        this.givensMax = 2;
    }
    return true;
};

CSL.Disambiguation.prototype.padBase = function(base) {
    for (var i = 0, ilen = base.names.length; i < ilen; i += 1) {
        if (!base.givens[i]) {
            base.givens[i] = [];
        }
        for (var j = 0, jlen = base.names[i]; j < jlen; j += 1) {
            if (!base.givens[i][j]) {
                base.givens[i][j] = 0;
            }
        }
    }
};

CSL.Disambiguation.prototype.configModes = function() {
    var dagopt, gdropt;
    this.modes = [];
    dagopt = this.state.opt["disambiguate-add-givenname"];
    gdropt = this.state.citation.opt["givenname-disambiguation-rule"];
    if (this.state.opt["disambiguate-add-names"] || dagopt && gdropt === "by-cite") {
        this.modes.push("disNames");
    }
    if (this.state.opt.development_extensions.prioritize_disambiguate_condition) {
        if (this.state.opt.has_disambiguate) {
            this.modes.push("disExtraText");
        }
        if (this.state.opt["disambiguate-add-year-suffix"]) {
            this.modes.push("disYears");
        }
    } else {
        if (this.state.opt["disambiguate-add-year-suffix"]) {
            this.modes.push("disYears");
        }
        if (this.state.opt.has_disambiguate) {
            this.modes.push("disExtraText");
        }
    }
};

CSL.Disambiguation.prototype.getCiteData = function(Item, base) {
    if (!this.maxNamesByItemId[Item.id]) {
        CSL.getAmbiguousCite.call(this.state, Item, base);
        base = CSL.getAmbigConfig.call(this.state);
        this.maxNamesByItemId[Item.id] = CSL.getMaxVals.call(this.state);
        this.state.registry.registry[Item.id].disambig.givens = this.state.tmp.disambig_settings.givens.slice();
        for (var i = 0, ilen = this.state.registry.registry[Item.id].disambig.givens.length; i < ilen; i += 1) {
            this.state.registry.registry[Item.id].disambig.givens[i] = this.state.tmp.disambig_settings.givens[i].slice();
        }
        this.namesetsMax = this.state.registry.registry[Item.id].disambig.names.length - 1;
        if (!this.base) {
            this.base = base;
            this.betterbase = CSL.cloneAmbigConfig(base);
        }
        if (base.names.length < this.base.names.length) {
            this.base = base;
        }
        for (var i = 0, ilen = base.names.length; i < ilen; i += 1) {
            if (base.names[i] > this.base.names[i]) {
                this.base.givens[i] = base.givens[i].slice();
                this.base.names[i] = base.names[i];
                this.betterbase.names = this.base.names.slice();
                this.betterbase.givens = this.base.givens.slice();
                this.padBase(this.base);
                this.padBase(this.betterbase);
            }
        }
        this.betterbase.givens = this.base.givens.slice();
        for (var j = 0, jlen = this.base.givens.length; j < jlen; j += 1) {
            this.betterbase.givens[j] = this.base.givens[j].slice();
        }
    }
};

CSL.Disambiguation.prototype.captureStepToBase = function() {
    if (this.state.citation.opt["givenname-disambiguation-rule"] === "by-cite" && this.base.givens && this.base.givens.length) {
        if ("undefined" !== typeof this.base.givens[this.gnameset][this.gname]) {
            if (this.betterbase.givens.length < this.base.givens.length) {
                this.betterbase.givens = JSON.parse(JSON.stringify(this.base.givens));
            }
            this.betterbase.givens[this.gnameset][this.gname] = this.base.givens[this.gnameset][this.gname];
        }
    }
    this.betterbase.names[this.gnameset] = this.base.names[this.gnameset];
};

CSL.Engine.prototype.getJurisdictionList = function(jurisdiction) {
    var jurisdictionList = [];
    var jurisdictionElems = jurisdiction.split(":");
    for (var j = jurisdictionElems.length; j > 0; j--) {
        var composedID = jurisdictionElems.slice(0, j).join(":");
        jurisdictionList.push(composedID);
        if (this.opt.jurisdiction_fallbacks[composedID]) {
            var fallback = this.opt.jurisdiction_fallbacks[composedID];
            jurisdictionList.push(fallback);
        }
    }
    if (jurisdictionList.indexOf("us") === -1) {
        jurisdictionList.push("us");
    }
    return jurisdictionList;
};

CSL.Engine.prototype.loadStyleModule = function(jurisdiction, xmlSource, skipFallback) {
    var myFallback = null;
    this.juris[jurisdiction] = {};
    var myXml = CSL.setupXml(xmlSource);
    myXml.addMissingNameNodes(myXml.dataObj);
    myXml.addInstitutionNodes(myXml.dataObj);
    myXml.insertPublisherAndPlace(myXml.dataObj);
    myXml.flagDateMacros(myXml.dataObj);
    var myNodes = myXml.getNodesByName(myXml.dataObj, "law-module");
    for (var i = 0, ilen = myNodes.length; i < ilen; i++) {
        var myTypes = myXml.getAttributeValue(myNodes[i], "types");
        if (myTypes) {
            this.juris[jurisdiction].types = {};
            myTypes = myTypes.split(/\s+/);
            for (var j = 0, jlen = myTypes.length; j < jlen; j++) {
                this.juris[jurisdiction].types[myTypes[j]] = true;
            }
        }
        if (!skipFallback) {
            myFallback = myXml.getAttributeValue(myNodes[i], "fallback");
            if (myFallback) {
                if (jurisdiction !== "us") {
                    this.opt.jurisdiction_fallbacks[jurisdiction] = myFallback;
                }
            }
        }
    }
    var lang = this.opt.lang ? this.opt.lang : this.opt["default-locale"][0];
    CSL.SET_COURT_CLASSES(this, lang, myXml, myXml.dataObj);
    if (!this.juris[jurisdiction].types) {
        this.juris[jurisdiction].types = CSL.MODULE_TYPES;
    }
    var myNodes = myXml.getNodesByName(myXml.dataObj, "macro");
    for (var i = 0, ilen = myNodes.length; i < ilen; i++) {
        var myName = myXml.getAttributeValue(myNodes[i], "name");
        if (!CSL.MODULE_MACROS[myName]) {
            CSL.debug('CSL: skipping non-modular macro name "' + myName + '" in module context');
            continue;
        }
        this.juris[jurisdiction][myName] = [];
        this.buildTokenLists(myNodes[i], this.juris[jurisdiction][myName]);
        this.configureTokenList(this.juris[jurisdiction][myName]);
    }
    return myFallback;
};

CSL.Engine.prototype.retrieveAllStyleModules = function(jurisdictionList) {
    var ret = {};
    var preferences = this.locale[this.opt.lang].opts["jurisdiction-preference"];
    preferences = preferences ? preferences : [];
    preferences = [ "" ].concat(preferences);
    for (var i = preferences.length - 1; i > -1; i--) {
        var preference = preferences[i];
        for (var j = 0, jlen = jurisdictionList.length; j < jlen; j++) {
            var jurisdiction = jurisdictionList[j];
            if (this.opt.jurisdictions_seen[jurisdiction]) {
                continue;
            }
            var res = this.sys.retrieveStyleModule(jurisdiction, preference);
            if (!res && !preference || res) {
                this.opt.jurisdictions_seen[jurisdiction] = true;
            }
            if (!res) {
                continue;
            }
            ret[jurisdiction] = res;
        }
    }
    return ret;
};

CSL.ParticleList = function() {
    var always_dropping_1 = [ [ [ 0, 1 ], null ] ];
    var always_dropping_3 = [ [ [ 0, 3 ], null ] ];
    var always_non_dropping_1 = [ [ null, [ 0, 1 ] ] ];
    var always_non_dropping_2 = [ [ null, [ 0, 2 ] ] ];
    var always_non_dropping_3 = [ [ null, [ 0, 3 ] ] ];
    var either_1 = [ [ null, [ 0, 1 ] ], [ [ 0, 1 ], null ] ];
    var either_2 = [ [ null, [ 0, 2 ] ], [ [ 0, 2 ], null ] ];
    var either_1_dropping_best = [ [ [ 0, 1 ], null ], [ null, [ 0, 1 ] ] ];
    var either_2_dropping_best = [ [ [ 0, 2 ], null ], [ null, [ 0, 2 ] ] ];
    var either_3_dropping_best = [ [ [ 0, 3 ], null ], [ null, [ 0, 3 ] ] ];
    var non_dropping_2_alt_dropping_1_non_dropping_1 = [ [ null, [ 0, 2 ] ], [ [ 0, 1 ], [ 1, 2 ] ] ];
    var PARTICLES = [ [ "'s", always_non_dropping_1 ], [ "'s-", always_non_dropping_1 ], [ "'t", always_non_dropping_1 ], [ "a", always_non_dropping_1 ], [ "aan 't", always_non_dropping_2 ], [ "aan de", always_non_dropping_2 ], [ "aan den", always_non_dropping_2 ], [ "aan der", always_non_dropping_2 ], [ "aan het", always_non_dropping_2 ], [ "aan t", always_non_dropping_2 ], [ "aan", always_non_dropping_1 ], [ "ad-", either_1 ], [ "adh-", either_1 ], [ "af", either_1 ], [ "al", either_1 ], [ "al-", either_1 ], [ "am de", always_non_dropping_2 ], [ "am", always_non_dropping_1 ], [ "an-", either_1 ], [ "ar-", either_1 ], [ "as-", either_1 ], [ "ash-", either_1 ], [ "at-", either_1 ], [ "ath-", either_1 ], [ "auf dem", either_2_dropping_best ], [ "auf den", either_2_dropping_best ], [ "auf der", either_2_dropping_best ], [ "auf ter", always_non_dropping_2 ], [ "auf", either_1_dropping_best ], [ "aus 'm", either_2_dropping_best ], [ "aus dem", either_2_dropping_best ], [ "aus den", either_2_dropping_best ], [ "aus der", either_2_dropping_best ], [ "aus m", either_2_dropping_best ], [ "aus", either_1_dropping_best ], [ "aus'm", either_2_dropping_best ], [ "az-", either_1 ], [ "aš-", either_1 ], [ "aḍ-", either_1 ], [ "aḏ-", either_1 ], [ "aṣ-", either_1 ], [ "aṭ-", either_1 ], [ "aṯ-", either_1 ], [ "aẓ-", either_1 ], [ "ben", always_non_dropping_1 ], [ "bij 't", always_non_dropping_2 ], [ "bij de", always_non_dropping_2 ], [ "bij den", always_non_dropping_2 ], [ "bij het", always_non_dropping_2 ], [ "bij t", always_non_dropping_2 ], [ "bij", always_non_dropping_1 ], [ "bin", always_non_dropping_1 ], [ "boven d", always_non_dropping_2 ], [ "boven d'", always_non_dropping_2 ], [ "d", always_non_dropping_1 ], [ "d'", either_1 ], [ "da", either_1 ], [ "dal", always_non_dropping_1 ], [ "dal'", always_non_dropping_1 ], [ "dall'", always_non_dropping_1 ], [ "dalla", always_non_dropping_1 ], [ "das", either_1 ], [ "de die le", always_non_dropping_3 ], [ "de die", always_non_dropping_2 ], [ "de l", always_non_dropping_2 ], [ "de l'", always_non_dropping_2 ], [ "de la", non_dropping_2_alt_dropping_1_non_dropping_1 ], [ "de las", non_dropping_2_alt_dropping_1_non_dropping_1 ], [ "de le", always_non_dropping_2 ], [ "de li", either_2 ], [ "de van der", always_non_dropping_3 ], [ "de", either_1 ], [ "de'", either_1 ], [ "deca", always_non_dropping_1 ], [ "degli", either_1 ], [ "dei", either_1 ], [ "del", either_1 ], [ "dela", always_dropping_1 ], [ "dell'", either_1 ], [ "della", either_1 ], [ "delle", either_1 ], [ "dello", either_1 ], [ "den", either_1 ], [ "der", either_1 ], [ "des", either_1 ], [ "di", either_1 ], [ "die le", always_non_dropping_2 ], [ "do", always_non_dropping_1 ], [ "don", always_non_dropping_1 ], [ "dos", either_1 ], [ "du", either_1 ], [ "ed-", either_1 ], [ "edh-", either_1 ], [ "el", either_1 ], [ "el-", either_1 ], [ "en-", either_1 ], [ "er-", either_1 ], [ "es-", either_1 ], [ "esh-", either_1 ], [ "et-", either_1 ], [ "eth-", either_1 ], [ "ez-", either_1 ], [ "eš-", either_1 ], [ "eḍ-", either_1 ], [ "eḏ-", either_1 ], [ "eṣ-", either_1 ], [ "eṭ-", either_1 ], [ "eṯ-", either_1 ], [ "eẓ-", either_1 ], [ "het", always_non_dropping_1 ], [ "i", always_non_dropping_1 ], [ "il", always_dropping_1 ], [ "im", always_non_dropping_1 ], [ "in 't", always_non_dropping_2 ], [ "in de", always_non_dropping_2 ], [ "in den", always_non_dropping_2 ], [ "in der", either_2 ], [ "in het", always_non_dropping_2 ], [ "in t", always_non_dropping_2 ], [ "in", always_non_dropping_1 ], [ "l", always_non_dropping_1 ], [ "l'", always_non_dropping_1 ], [ "la", always_non_dropping_1 ], [ "las", always_non_dropping_1 ], [ "le", always_non_dropping_1 ], [ "les", either_1 ], [ "lo", either_1 ], [ "los", always_non_dropping_1 ], [ "lou", always_non_dropping_1 ], [ "of", always_non_dropping_1 ], [ "onder 't", always_non_dropping_2 ], [ "onder de", always_non_dropping_2 ], [ "onder den", always_non_dropping_2 ], [ "onder het", always_non_dropping_2 ], [ "onder t", always_non_dropping_2 ], [ "onder", always_non_dropping_1 ], [ "op 't", always_non_dropping_2 ], [ "op de", either_2 ], [ "op den", always_non_dropping_2 ], [ "op der", always_non_dropping_2 ], [ "op gen", always_non_dropping_2 ], [ "op het", always_non_dropping_2 ], [ "op t", always_non_dropping_2 ], [ "op ten", always_non_dropping_2 ], [ "op", always_non_dropping_1 ], [ "over 't", always_non_dropping_2 ], [ "over de", always_non_dropping_2 ], [ "over den", always_non_dropping_2 ], [ "over het", always_non_dropping_2 ], [ "over t", always_non_dropping_2 ], [ "over", always_non_dropping_1 ], [ "s", always_non_dropping_1 ], [ "s'", always_non_dropping_1 ], [ "sen", always_dropping_1 ], [ "t", always_non_dropping_1 ], [ "te", always_non_dropping_1 ], [ "ten", always_non_dropping_1 ], [ "ter", always_non_dropping_1 ], [ "tho", always_non_dropping_1 ], [ "thoe", always_non_dropping_1 ], [ "thor", always_non_dropping_1 ], [ "to", always_non_dropping_1 ], [ "toe", always_non_dropping_1 ], [ "tot", always_non_dropping_1 ], [ "uijt 't", always_non_dropping_2 ], [ "uijt de", always_non_dropping_2 ], [ "uijt den", always_non_dropping_2 ], [ "uijt te de", always_non_dropping_3 ], [ "uijt ten", always_non_dropping_2 ], [ "uijt", always_non_dropping_1 ], [ "uit 't", always_non_dropping_2 ], [ "uit de", always_non_dropping_2 ], [ "uit den", always_non_dropping_2 ], [ "uit het", always_non_dropping_2 ], [ "uit t", always_non_dropping_2 ], [ "uit te de", always_non_dropping_3 ], [ "uit ten", always_non_dropping_2 ], [ "uit", always_non_dropping_1 ], [ "unter", always_non_dropping_1 ], [ "v", always_non_dropping_1 ], [ "v.", always_non_dropping_1 ], [ "v.d.", always_non_dropping_1 ], [ "van 't", always_non_dropping_2 ], [ "van de l", always_non_dropping_3 ], [ "van de l'", always_non_dropping_3 ], [ "van de", always_non_dropping_2 ], [ "van de", always_non_dropping_2 ], [ "van den", always_non_dropping_2 ], [ "van der", always_non_dropping_2 ], [ "van gen", always_non_dropping_2 ], [ "van het", always_non_dropping_2 ], [ "van la", always_non_dropping_2 ], [ "van t", always_non_dropping_2 ], [ "van ter", always_non_dropping_2 ], [ "van van de", always_non_dropping_3 ], [ "van", either_1 ], [ "vander", always_non_dropping_1 ], [ "vd", always_non_dropping_1 ], [ "ver", always_non_dropping_1 ], [ "vom und zum", always_dropping_3 ], [ "vom", either_1 ], [ "von 't", always_non_dropping_2 ], [ "von dem", either_2_dropping_best ], [ "von den", either_2_dropping_best ], [ "von der", either_2_dropping_best ], [ "von t", always_non_dropping_2 ], [ "von und zu", either_3_dropping_best ], [ "von zu", either_2_dropping_best ], [ "von", either_1_dropping_best ], [ "voor 't", always_non_dropping_2 ], [ "voor de", always_non_dropping_2 ], [ "voor den", always_non_dropping_2 ], [ "voor in 't", always_non_dropping_3 ], [ "voor in t", always_non_dropping_3 ], [ "voor", always_non_dropping_1 ], [ "vor der", either_2_dropping_best ], [ "vor", either_1_dropping_best ], [ "z", always_dropping_1 ], [ "ze", always_dropping_1 ], [ "zu", either_1_dropping_best ], [ "zum", either_1 ], [ "zur", either_1 ] ];
    return PARTICLES;
}();

CSL.parseParticles = function() {
    function splitParticles(nameValue, firstNameFlag, caseOverride) {
        var origNameValue = nameValue;
        nameValue = nameValue;
        var particleList = [];
        var rex;
        var hasParticle;
        if (firstNameFlag) {
            nameValue = nameValue.split("").reverse().join("");
            rex = CSL.PARTICLE_GIVEN_REGEXP;
        } else {
            rex = CSL.PARTICLE_FAMILY_REGEXP;
        }
        var m = nameValue.match(rex);
        while (m) {
            var m1 = firstNameFlag ? m[1].split("").reverse().join("") : m[1];
            var firstChar = m ? m1 : false;
            var firstChar = firstChar ? m1.replace(/^[-\'\u02bb\u2019\s]*(.).*$/, "$1") : false;
            hasParticle = firstChar ? firstChar.toUpperCase() !== firstChar : false;
            if (!hasParticle) {
                break;
            }
            if (firstNameFlag) {
                particleList.push(origNameValue.slice(m1.length * -1));
                origNameValue = origNameValue.slice(0, m1.length * -1);
            } else {
                particleList.push(origNameValue.slice(0, m1.length));
                origNameValue = origNameValue.slice(m1.length);
            }
            nameValue = m[2];
            m = nameValue.match(rex);
        }
        if (firstNameFlag) {
            nameValue = nameValue.split("").reverse().join("");
            particleList.reverse();
            for (var i = 1, ilen = particleList.length; i < ilen; i++) {
                if (particleList[i].slice(0, 1) == " ") {
                    particleList[i - 1] += " ";
                }
            }
            for (var i = 0, ilen = particleList.length; i < ilen; i++) {
                if (particleList[i].slice(0, 1) == " ") {
                    particleList[i] = particleList[i].slice(1);
                }
            }
            nameValue = origNameValue.slice(0, nameValue.length);
        } else {
            nameValue = origNameValue.slice(nameValue.length * -1);
        }
        return [ hasParticle, nameValue, particleList ];
    }
    function trimLast(str) {
        var lastChar = str.slice(-1);
        str = str.trim();
        if (lastChar === " " && [ "'", "’" ].indexOf(str.slice(-1)) > -1) {
            str += " ";
        }
        return str;
    }
    function parseSuffix(nameObj) {
        if (!nameObj.suffix && nameObj.given) {
            var m = nameObj.given.match(/(\s*,!*\s*)/);
            if (m) {
                var idx = nameObj.given.indexOf(m[1]);
                var possible_suffix = nameObj.given.slice(idx + m[1].length);
                var possible_comma = nameObj.given.slice(idx, idx + m[1].length).replace(/\s*/g, "");
                if (possible_suffix.replace(/\./g, "") === "et al" && !nameObj["dropping-particle"]) {
                    nameObj["dropping-particle"] = possible_suffix;
                    nameObj["comma-dropping-particle"] = ",";
                } else {
                    if (possible_comma.length === 2) {
                        nameObj["comma-suffix"] = true;
                    }
                    nameObj.suffix = possible_suffix;
                }
                nameObj.given = nameObj.given.slice(0, idx);
            }
        }
    }
    return function(nameObj) {
        var res = splitParticles(nameObj.family);
        var lastNameValue = res[1];
        var lastParticleList = res[2];
        nameObj.family = lastNameValue;
        var nonDroppingParticle = trimLast(lastParticleList.join(""));
        if (nonDroppingParticle) {
            nameObj["non-dropping-particle"] = nonDroppingParticle;
        }
        parseSuffix(nameObj);
        var res = splitParticles(nameObj.given, true);
        var firstNameValue = res[1];
        var firstParticleList = res[2];
        nameObj.given = firstNameValue;
        var droppingParticle = firstParticleList.join("").trim();
        if (droppingParticle) {
            nameObj["dropping-particle"] = droppingParticle;
        }
    };
}();

function CitationService(localesManager, cslStylesManager, sdk) {
    this._bibPlaceholder = "Please insert some citation into the document.";
    this._citPrefixNew = "ZOTERO_ITEM";
    this._citSuffixNew = "CSL_CITATION";
    this._citPrefix = "ZOTERO_CITATION";
    this._bibPrefixNew = "ZOTERO_BIBL";
    this._bibSuffixNew = "CSL_BIBLIOGRAPHY";
    this._bibPrefix = "ZOTERO_BIBLIOGRAPHY";
    this._sdk = sdk;
    this._localesManager = localesManager;
    this._cslStylesManager = cslStylesManager;
    this._formatter;
    this.citationDocService = new CitationDocService(this._citPrefixNew, this._citSuffixNew, this._bibPrefixNew, this._bibSuffixNew);
    this._notesStyle;
    this._styleFormat;
}

CitationService.prototype = {
    constructor: CitationService,
    fillUrisFromId: function fillUrisFromId(item) {
        var slashFirstIndex = item.id.indexOf("/") + 1;
        var slashLastIndex = item.id.lastIndexOf("/") + 1;
        var httpIndex = item.id.indexOf("http");
        if (slashFirstIndex !== slashLastIndex && httpIndex === 0) {
            if (!item.uris) {
                item.uris = [];
            }
            item.uris.push(item.id);
        }
        if (slashLastIndex) item.id = item.id.substring(slashLastIndex);
        return item;
    },
    _formatInsertLink: function _formatInsertLink(cslCitation) {
        var self = this;
        var bUpdateItems = false;
        var keys = [];
        var keysL = [];
        return Promise.resolve().then(function() {
            cslCitation.getCitationItems().forEach(function(item) {
                if (!CSLCitationStorage.has(item.id)) {
                    bUpdateItems = true;
                }
                CSLCitationStorage.set(item.id, item);
                keys.push(item.id);
                keysL.push(item.getInfoForCitationCluster());
            });
            if (bUpdateItems) {
                var arrIds = [];
                CSLCitationStorage.forEach(function(item, id) {
                    arrIds.push(id);
                });
                self._formatter.updateItems(arrIds);
            }
        }).then(function() {
            var fragment = document.createDocumentFragment();
            var tempElement = document.createElement("div");
            fragment.appendChild(tempElement);
            tempElement.innerHTML = self._formatter.makeCitationCluster(keysL);
            cslCitation.addPlainCitation(tempElement.innerText);
            var notesStyle = null;
            if ("note" === self._styleFormat) {
                notesStyle = self._notesStyle;
            }
            return self.citationDocService.addCitation(tempElement.innerText, JSON.stringify(cslCitation.toJSON()), notesStyle);
        }).then(function() {
            return self.updateCslItems(true, true, false);
        }).then(function() {
            return keys;
        });
    },
    _getSelectedInJsonFormat: function _getSelectedInJsonFormat(items) {
        var arrUsrItems = [];
        var arrGroupsItems = {};
        for (var citationID in items) {
            var item = items[citationID];
            var userID = item["userID"];
            var _groupID = item["groupID"];
            if (userID) {
                arrUsrItems.push(item.id);
            } else if (_groupID) {
                if (!arrGroupsItems[_groupID]) {
                    arrGroupsItems[_groupID] = [];
                }
                arrGroupsItems[_groupID].push(item.id);
            }
        }
        var promises = [];
        if (arrUsrItems.length) {
            promises.push(this._sdk.getItems(null, arrUsrItems, "json").then(function(res) {
                var items = res.items || [];
                return items;
            }));
        }
        for (var groupID in arrGroupsItems) {
            if (Object.hasOwnProperty.call(arrGroupsItems, groupID)) {
                promises.push(this._sdk.getGroupItems(null, groupID, arrGroupsItems[groupID], "json").then(function(res) {
                    var items = res.items || [];
                    return items;
                }));
            }
        }
        return Promise.all(promises).then(function(res) {
            var items = [];
            res.forEach(function(resItems) {
                items = items.concat(resItems);
            });
            return items;
        });
    },
    insertSelectedCitations: function insertSelectedCitations(items) {
        var self = this;
        var cslCitation = new CSLCitation(CSLCitationStorage.size, "");
        for (var citationID in items) {
            var item = items[citationID];
            cslCitation.fillFromObject(item);
        }
        return this._getSelectedInJsonFormat(items).then(function(items) {
            items.forEach(function(item) {
                cslCitation.fillFromObject(item);
            });
            return self._formatInsertLink(cslCitation);
        });
    },
    saveAsText: function saveAsText() {
        return this.citationDocService.saveAsText();
    },
    setNotesStyle: function setNotesStyle(notesStyle) {
        this._notesStyle = notesStyle;
    },
    setStyleFormat: function setStyleFormat(styleFormat) {
        this._styleFormat = styleFormat;
    },
    _updateAllOrAddBib: function _updateAllOrAddBib(bUpdateAll, bPastBib) {
        var self = this;
        return this.citationDocService.getAddinZoteroFields().then(function(arrFields) {
            if (!arrFields.length) {
                return;
            }
            var updatedFields = [];
            var bibField = null;
            var bibFieldValue = " ";
            var fragment = document.createDocumentFragment();
            var tempElement = document.createElement("div");
            fragment.appendChild(tempElement);
            try {
                var bibItems = new Array(CSLCitationStorage.size);
                var bibObject = self._formatter.makeBibliography();
                for (var i = 0; i < bibObject[0].entry_ids.length; i++) {
                    var citationId = bibObject[0].entry_ids[i][0];
                    var citationIndex = CSLCitationStorage.getIndex(citationId);
                    var bibText = bibObject[1][i];
                    while (bibText.indexOf("\n") !== bibText.lastIndexOf("\n")) {
                        bibText = bibText.replace(/\n/, "");
                    }
                    if (/<sup[^>]*>|<\/sup>|<sub[^>]*>|<\/sub>/i.test(bibText)) {
                        bibText = bibText.replace(/<sup\b[^>]*>/gi, "&lt;sup&gt;").replace(/<\/sup>/gi, "&lt;/sup&gt;").replace(/<sub\b[^>]*>/gi, "&lt;sub&gt;").replace(/<\/sub>/gi, "&lt;/sub&gt;");
                    }
                    bibItems[citationIndex] = bibText;
                }
                tempElement.innerHTML = bibItems.join("");
            } catch (e) {
                if (false === self._cslStylesManager.isLastUsedStyleContainBibliography()) {
                    tempElement.textContent = "";
                } else {
                    console.error(e);
                    throw "Failed to apply this style.";
                }
            }
            var bibliography = tempElement.innerText;
            arrFields.forEach(function(field) {
                var citationObject;
                var citationStartIndex = field.Value.indexOf("{");
                var citationEndIndex = field.Value.lastIndexOf("}");
                if (citationStartIndex !== -1) {
                    var citationString = field.Value.slice(citationStartIndex, citationEndIndex + 1);
                    citationObject = JSON.parse(citationString);
                }
                var keysL = [];
                var cslCitation;
                if (bUpdateAll && (field.Value.indexOf(self._citPrefixNew) !== -1 || field.Value.indexOf(self._citPrefix) !== -1)) {
                    var citationID = "";
                    if (field.Value.indexOf(self._citPrefix) === -1) {
                        citationID = citationObject.citationID;
                    }
                    cslCitation = new CSLCitation(keysL.length, citationID);
                    cslCitation.fillFromObject(citationObject);
                    keysL = cslCitation.getInfoForCitationCluster();
                    tempElement.innerHTML = self._formatter.makeCitationCluster(keysL);
                    field["Content"] = tempElement.innerText;
                    cslCitation.addPlainCitation(field["Content"]);
                    if (cslCitation) {
                        field["Value"] = self._citPrefixNew + " " + self._citSuffixNew + JSON.stringify(cslCitation.toJSON());
                    }
                    updatedFields.push(field);
                } else if (field.Value.indexOf(self._bibPrefix) !== -1 || field.Value.indexOf(self._bibPrefixNew) !== -1) {
                    bibField = field;
                    bibField["Content"] = bibliography;
                    if (typeof citationObject === "object" && Object.keys(citationObject).length > 0) {
                        bibFieldValue = JSON.stringify(citationObject);
                    }
                }
            });
            if (bibField) {
                updatedFields.push(bibField);
            } else if (bPastBib) {
                if (self._cslStylesManager.isLastUsedStyleContainBibliography()) {
                    return self.citationDocService.addBibliography(bibliography, bibFieldValue).then(function() {
                        return updatedFields;
                    });
                } else {
                    throw "The current bibliographic style does not describe the bibliography";
                }
            }
            return updatedFields;
        }).then(function(updatedFields) {
            if (updatedFields && updatedFields.length) {
                return self.citationDocService.updateAddinFields(updatedFields);
            }
        });
    },
    updateCslItems: function updateCslItems(bUpdateFormatter, bUpdateAll, bPastBib) {
        CSLCitationStorage.clear();
        var self = this;
        return this.citationDocService.getAddinZoteroFields().then(function(arrFields) {
            var bibFieldValue = " ";
            if (arrFields.length) {
                var numOfItems = 0;
                var bibField = arrFields.reduce(function(accumulator, field) {
                    var citationObject;
                    var citationStartIndex = field.Value.indexOf("{");
                    var citationEndIndex = field.Value.lastIndexOf("}");
                    if (citationStartIndex !== -1 && citationEndIndex !== -1) {
                        var citationString = field.Value.slice(citationStartIndex, citationEndIndex + 1);
                        citationObject = JSON.parse(citationString);
                    }
                    if (field.Value.indexOf(self._citPrefix) !== -1 || field.Value.indexOf(self._citPrefixNew) !== -1) {
                        var citationID = "";
                        if (field.Value.indexOf(self._citPrefix) === -1) {
                            citationID = citationObject.citationID;
                        }
                        var cslCitation = new CSLCitation(numOfItems, citationID);
                        numOfItems += cslCitation.fillFromObject(citationObject);
                        cslCitation.getCitationItems().forEach(function(item) {
                            CSLCitationStorage.set(item.id, item);
                        });
                    } else if (field.Value.indexOf(self._bibPrefix) !== -1 || field.Value.indexOf(self._bibPrefixNew) !== -1) {
                        accumulator = field;
                        if (typeof citationObject === "object" && Object.keys(citationObject).length > 0) {
                            bibFieldValue = JSON.stringify(citationObject);
                        }
                    }
                    return accumulator;
                }, null);
                if (numOfItems) ; else if (bUpdateFormatter && bibField && bUpdateAll) {
                    bUpdateFormatter = false;
                    bibField["Content"] = translate(self._bibPlaceholder);
                    return self.citationDocService.updateAddinFields([ bibField ]).then(function() {
                        return bUpdateFormatter;
                    });
                }
            } else if (bUpdateFormatter && bPastBib) {
                if (self._cslStylesManager.isLastUsedStyleContainBibliography()) {
                    return self.citationDocService.addBibliography(translate(self._bibPlaceholder), bibFieldValue).then(function() {
                        return bUpdateFormatter;
                    });
                } else {
                    throw "The current bibliographic style does not describe the bibliography";
                }
            }
            return bUpdateFormatter;
        }).then(function(bUpdateFormatter) {
            if (bUpdateFormatter) return self._updateFormatter();
        }).then(function() {
            if (bUpdateAll) {
                return self._updateAllOrAddBib(bUpdateAll, bPastBib);
            }
        });
    },
    _updateFormatter: function _updateFormatter() {
        var self = this;
        var arrIds = [];
        CSLCitationStorage.forEach(function(item, id) {
            arrIds.push(id);
        });
        this._formatter = new CSL.Engine({
            retrieveLocale: function retrieveLocale(id) {
                if (self._localesManager.getLocale(id)) {
                    return self._localesManager.getLocale(id);
                }
                return self._localesManager.getLocale();
            },
            retrieveItem: function retrieveItem(id) {
                var item = CSLCitationStorage.get(id);
                var index = CSLCitationStorage.getIndex(id);
                if (!item) return null;
                return item.toFlatJSON(index);
            }
        }, this._cslStylesManager.cached(this._cslStylesManager.getLastUsedStyleIdOrDefault()), this._localesManager.getLastUsedLanguage(), true);
        if (arrIds.length) {
            this._formatter.updateItems(arrIds);
        }
        return;
    }
};

var CslStylesParser = {
    getStyleInfo: function getStyleInfo(name, style) {
        var parser = new DOMParser;
        var xmlDoc = parser.parseFromString(style, "text/xml");
        var styleInfo = {
            categories: {
                fields: [],
                format: ""
            },
            dependent: 0,
            href: "",
            name: name,
            title: "",
            updated: ""
        };
        var title = xmlDoc.querySelector("info title");
        if (title) styleInfo.title = title.textContent;
        var href = xmlDoc.querySelector('info link[rel="self"]');
        if (href) {
            var attribute = href.getAttribute("href");
            if (attribute) styleInfo.href = attribute;
        }
        var parent = xmlDoc.querySelector('info link[rel="independent-parent"]');
        if (parent) {
            var _attribute = parent.getAttribute("href");
            if (_attribute) styleInfo.parent = _attribute;
            styleInfo.dependent = 1;
        }
        var updated = xmlDoc.querySelector("info updated");
        if (updated) styleInfo.updated = updated.textContent;
        var categoryFormat = xmlDoc.querySelector("info category[citation-format]");
        if (categoryFormat) {
            var _attribute2 = categoryFormat.getAttribute("citation-format");
            if (_attribute2) styleInfo.categories.format = _attribute2;
        }
        var categoryFields = xmlDoc.querySelectorAll("info category[field]");
        if (categoryFields) {
            categoryFields.forEach(function(category) {
                var attribute = category.getAttribute("field");
                if (attribute) styleInfo.categories.fields.push(attribute);
            });
        }
        return styleInfo;
    },
    getCitationFormat: function getCitationFormat(styleContent) {
        var parser = new DOMParser;
        var xmlDoc = parser.parseFromString(styleContent, "text/xml");
        var format = xmlDoc.querySelector("info category[citation-format]");
        if (!format) throw new Error("Citation format not found");
        var type = format.getAttribute("citation-format");
        if (!type) throw new Error("Citation format not found");
        switch (type) {
          case "note":
          case "numeric":
          case "author":
          case "author-date":
          case "label":
            return type;
        }
        throw new Error("Invalid citation format");
    },
    isStyleContainBibliography: function isStyleContainBibliography(styleContent) {
        return styleContent.indexOf("<bibliography") > -1;
    }
};

function CslStylesStorage() {
    this._customStyleNamesKey = "zoteroCustomStyleNames";
    this._customStylesKey = "zoteroCustomStyles";
}

CslStylesStorage.prototype.getStyleNames = function() {
    var customStyleNames = localStorage.getItem(this._customStyleNamesKey);
    if (customStyleNames) {
        return JSON.parse(customStyleNames);
    } else {
        return [];
    }
};

CslStylesStorage.prototype._getStyles = function() {
    var customStyles = localStorage.getItem(this._customStylesKey);
    if (customStyles) {
        return JSON.parse(customStyles);
    } else {
        return [];
    }
};

CslStylesStorage.prototype.getStyle = function(name) {
    var customStyleNames = this.getStyleNames();
    var styleIndex = customStyleNames.indexOf(name);
    if (styleIndex === -1) {
        return null;
    }
    return this._getStyles()[styleIndex];
};

CslStylesStorage.prototype.getStylesInfo = function() {
    var customStyleNames = this.getStyleNames();
    var customStyles = this._getStyles();
    var styles = [];
    for (var i = 0; i < customStyleNames.length; i++) {
        var result = CslStylesParser.getStyleInfo(customStyleNames[i], customStyles[i]);
        styles.push(result);
    }
    return styles;
};

CslStylesStorage.prototype.setStyle = function(name, data) {
    var customStyleNames = this.getStyleNames();
    var customStyles = this._getStyles();
    var styleIndex = customStyleNames.indexOf(name);
    if (styleIndex === -1) {
        styleIndex = customStyleNames.length;
    }
    customStyleNames[styleIndex] = name;
    customStyles[styleIndex] = data;
    localStorage.setItem(this._customStyleNamesKey, JSON.stringify(customStyleNames));
    localStorage.setItem(this._customStylesKey, JSON.stringify(customStyles));
    return CslStylesParser.getStyleInfo(name, data);
};

CslStylesStorage.prototype.deleteStyle = function(name) {
    var customStyleNames = this.getStyleNames();
    var customStyles = this._getStyles();
    var styleIndex = customStyleNames.indexOf(name);
    if (styleIndex === -1) {
        return name;
    }
    customStyleNames.splice(styleIndex, 1);
    customStyles.splice(styleIndex, 1);
    localStorage.setItem(this._customStyleNamesKey, JSON.stringify(customStyleNames));
    localStorage.setItem(this._customStylesKey, JSON.stringify(customStyles));
    return name;
};

function CslStylesManager() {
    this._isOnlineAvailable = false;
    this._isDesktopAvailable = false;
    this._customStylesStorage = new CslStylesStorage;
    this._STYLES_JSON_URL = "https://www.zotero.org/styles-files/styles.json";
    this._STYLES_JSON_LOCAL = "./resources/csl/styles.json";
    this._STYLES_URL = "https://www.zotero.org/styles/";
    this._STYLES_LOCAL = "./resources/csl/styles/";
    this._lastStyleKey = "zoteroStyleId";
    this._lastNotesStyleKey = "zoteroNotesStyleId";
    this._lastFormatKey = "zoteroFormatId";
    this._lastUsedStyleContainBibliographyKey = "zoteroContainBibliography";
    this._defaultStyles = [ "american-medical-association", "american-political-science-association", "apa", "american-sociological-association", "chicago-author-date-17th-edition", "harvard-cite-them-right-10th-edition", "ieee", "modern-language-association-8th-edition", "nature" ];
    this._cache = {};
}

CslStylesManager.prototype.addCustomStyle = function(file) {
    var self = this;
    return new Promise(function(resolve, reject) {
        var fileName = file.name.toLowerCase();
        if (fileName.slice(-4) === ".csl" || fileName.slice(-4) === ".xml") {
            fileName = fileName.substring(0, fileName.length - 4).trim();
        } else {
            reject("Please select a .csl or .xml file.");
        }
        if (file.size > 1024 * 1024) {
            reject("Maximum file size is 1 MB.");
        }
        resolve(fileName);
    }).then(function(fileName) {
        return self._readCSLFile(file).then(function(content) {
            if (self._defaultStyles.indexOf(fileName) === -1) {
                self._defaultStyles.push(fileName);
            }
            return self._customStylesStorage.setStyle(fileName, content);
        });
    });
};

CslStylesManager.prototype.getLastUsedFormat = function() {
    var lastUsedFormat = localStorage.getItem(this._lastFormatKey);
    switch (lastUsedFormat) {
      case "note":
      case "numeric":
      case "author":
      case "author-date":
      case "label":
        return lastUsedFormat;
    }
    return "numeric";
};

CslStylesManager.prototype.getLastUsedNotesStyle = function() {
    var lastUsedNotesStyle = localStorage.getItem(this._lastNotesStyleKey);
    if (lastUsedNotesStyle === "footnotes" || lastUsedNotesStyle === "endnotes") {
        return lastUsedNotesStyle;
    }
    return "footnotes";
};

CslStylesManager.prototype.getLastUsedStyleId = function() {
    var lastUsedStyle = localStorage.getItem(this._lastStyleKey);
    if (lastUsedStyle) {
        return lastUsedStyle;
    }
    return null;
};

CslStylesManager.prototype.getLastUsedStyleIdOrDefault = function() {
    var lastUsedStyle = localStorage.getItem(this._lastStyleKey);
    if (lastUsedStyle) {
        return lastUsedStyle;
    }
    return "ieee";
};

CslStylesManager.prototype.getStyle = function(styleName) {
    var self = this;
    return Promise.resolve(styleName).then(function(styleName) {
        if (self._cache[styleName]) {
            return self._cache[styleName];
        }
        var customStyleNames = self._customStylesStorage.getStyleNames();
        if (customStyleNames.indexOf(styleName) !== -1) {
            return self._customStylesStorage.getStyle(styleName);
        }
        var url = self._STYLES_LOCAL + styleName + ".csl";
        if (self._isOnlineAvailable) {
            url = self._STYLES_URL + styleName;
        }
        return fetch(url).then(function(resp) {
            return resp.text();
        });
    }).then(function(content) {
        if (content && !self._isValidCSL(content) && self._isOnlineAvailable) {
            var styleInfo = CslStylesParser.getStyleInfo(styleName, content);
            if (styleInfo && styleInfo.dependent > 0 && styleInfo.parent) {
                return fetch(styleInfo.parent).then(function(resp) {
                    return resp.text();
                });
            }
        }
        return content;
    }).then(function(content) {
        if (content) {
            self._saveLastUsedStyle(styleName, content);
        }
        return content;
    });
};

CslStylesManager.prototype.getStylesInfo = function() {
    var self = this;
    return Promise.all([ this._getStylesJson(), this._customStylesStorage.getStylesInfo() ]).then(function(styles) {
        var lastStyle = self.getLastUsedStyleId() || "ieee";
        var resultStyles = [];
        var resultStyleNames = self._customStylesStorage.getStyleNames();
        var loadedStyles = styles[0];
        var customStyles = styles[1];
        if (self._isDesktopAvailable && !self._isOnlineAvailable) {
            loadedStyles = loadedStyles.filter(function(style) {
                return self._defaultStyles.indexOf(style.name) >= 0 || style.name == lastStyle;
            });
        }
        customStyles.forEach(function(style) {
            if (lastStyle === style.name) {
                resultStyles.unshift(style);
            } else {
                resultStyles.push(style);
            }
            if (self._defaultStyles.indexOf(style.name) === -1) {
                self._defaultStyles.push(style.name);
            }
        });
        loadedStyles.forEach(function(style) {
            if (resultStyleNames.indexOf(style.name) !== -1) {
                return;
            }
            if (lastStyle === style.name) {
                resultStyles.unshift(style);
            } else {
                resultStyles.push(style);
            }
        });
        return resultStyles;
    });
};

CslStylesManager.prototype._getStylesJson = function() {
    var url = this._STYLES_JSON_LOCAL;
    if (this._isOnlineAvailable) {
        url = this._STYLES_JSON_URL;
    }
    return fetch(url).then(function(resp) {
        return resp.json();
    });
};

CslStylesManager.prototype.cached = function(id) {
    if (Object.hasOwnProperty.call(this._cache, id)) {
        return this._cache[id];
    }
    return null;
};

CslStylesManager.prototype.isLastUsedStyleContainBibliography = function() {
    var containBibliography = localStorage.getItem(this._lastUsedStyleContainBibliographyKey);
    return containBibliography !== "false";
};

CslStylesManager.prototype.isStyleDefault = function(styleName) {
    return this._defaultStyles.indexOf(styleName) >= 0;
};

CslStylesManager.prototype._isValidCSL = function(content) {
    return content.indexOf("<?xml") > -1 && content.indexOf("<style") > -1 && content.indexOf("<macro") > -1 && content.indexOf("citation") > -1;
};

CslStylesManager.prototype._readCSLFile = function(file) {
    var self = this;
    return new Promise(function(resolve, reject) {
        var reader = new FileReader;
        reader.onload = function(e) {
            var fileContent = e.target ? String(e.target.result) : "";
            if (!self._isValidCSL(fileContent)) {
                reject("The file is not a valid CSL file");
                return;
            }
            resolve(fileContent);
        };
        reader.onerror = function() {
            reject("Failed to read file");
        };
        reader.readAsText(file);
    });
};

CslStylesManager.prototype._saveLastUsedStyle = function(id, content) {
    this._cache[id] = content;
    localStorage.setItem(this._lastStyleKey, id);
    var currentStyleFormat = CslStylesParser.getCitationFormat(content);
    localStorage.setItem(this._lastFormatKey, currentStyleFormat);
    var containBibliography = CslStylesParser.isStyleContainBibliography(content);
    localStorage.setItem(this._lastUsedStyleContainBibliographyKey, containBibliography.toString());
};

CslStylesManager.prototype.saveLastUsedNotesStyle = function(notesStyle) {
    localStorage.setItem(this._lastNotesStyleKey, notesStyle);
};

CslStylesManager.prototype.setDesktopApiAvailable = function(isApiAvailable) {
    this._isDesktopAvailable = isApiAvailable;
};

CslStylesManager.prototype.setRestApiAvailable = function(isApiAvailable) {
    this._isOnlineAvailable = isApiAvailable;
};

function LocalesManager() {
    this._isOnlineAvailable = false;
    this._isDesktopAvailable = false;
    this._LOCALES_URL = "https://raw.githubusercontent.com/citation-style-language/locales/master/";
    this._LOCALES_PATH = "./resources/csl/locales/";
    this._lastLanguageKey = "zoteroLang";
    this._selectedLanguage = null;
    this._cache = {};
}

LocalesManager.prototype.loadLocale = function(langTag) {
    var self = this;
    this._selectedLanguage = langTag;
    if (this._cache[langTag]) {
        return Promise.resolve(this._cache[langTag]);
    }
    var url = this._getLocalesUrl() + "locales-" + langTag + ".xml";
    return fetch(url).then(function(response) {
        return response.text();
    }).then(function(text) {
        self._cache[langTag] = text;
        return text;
    });
};

LocalesManager.prototype.getLastUsedLanguage = function() {
    this._selectedLanguage = this._selectedLanguage || localStorage.getItem(this._lastLanguageKey) || "en-US";
    return this._selectedLanguage;
};

LocalesManager.prototype.getLocale = function(localeId) {
    if (localeId) {
        if (this._cache[localeId]) {
            return this._cache[localeId];
        }
        return null;
    }
    if (this._selectedLanguage && this._cache[this._selectedLanguage]) {
        return this._cache[this._selectedLanguage];
    }
    return null;
};

LocalesManager.prototype.saveLastUsedLanguage = function(language) {
    this._selectedLanguage = language;
    localStorage.setItem(this._lastLanguageKey, language);
};

LocalesManager.prototype._getLocalesUrl = function() {
    return this._isOnlineAvailable ? this._LOCALES_URL : this._LOCALES_PATH;
};

LocalesManager.prototype.setDesktopApiAvailable = function(isApiAvailable) {
    this._isDesktopAvailable = isApiAvailable;
};

LocalesManager.prototype.setRestApiAvailable = function(isApiAvailable) {
    this._isOnlineAvailable = isApiAvailable;
};

function SettingsPage(router, displayNoneClass) {
    this._router = router;
    this._displayNoneClass = displayNoneClass;
    this._openSettingsBtn = new Button("settingsBtn", {
        variant: "icon-only",
        size: "small"
    });
    this._saveBtn = new Button("saveSettingsBtn", {
        variant: "primary"
    });
    this._cancelBtn = new Button("cancelBtn", {
        variant: "secondary"
    });
    this._styleSelect = new SelectBox("styleSelectList", {
        placeholder: "Enter style name"
    });
    this._styleSelectListOther = new SelectBox("styleSelectedListOther", {
        placeholder: "Enter style name",
        searchable: true
    });
    this._notesStyleWrapper = document.getElementById("notesStyle");
    if (!this._notesStyleWrapper) {
        throw new Error("notesStyleWrapper not found");
    }
    this._footNotes = new Radio("footNotes", {
        label: "Footnotes"
    });
    this._endNotes = new Radio("endNotes", {
        label: "Endnotes"
    });
    this._cslFileInput = document.getElementById("cslFileInput");
    if (!this._cslFileInput) {
        throw new Error("cslFileInput not found");
    }
    this._languageSelect = new SelectBox("styleLangList", {
        placeholder: "Select language"
    });
    this._cslStylesManager = new CslStylesManager;
    this._localesManager = new LocalesManager;
    this._selectLists = [];
    this._onChangeState = function(settings) {};
    this._styleMessage = new Message("styleMessage", {
        type: "error"
    });
    this._langMessage = new Message("langMessage", {
        type: "error"
    });
    this._LANGUAGES = [ [ "af-ZA", "Afrikaans" ], [ "ar", "Arabic" ], [ "bg-BG", "Bulgarian" ], [ "ca-AD", "Catalan" ], [ "cs-CZ", "Czech" ], [ "cy-GB", "Welsh" ], [ "da-DK", "Danish" ], [ "de-AT", "German (Austria)" ], [ "de-CH", "German (Switzerland)" ], [ "de-DE", "German (Germany)" ], [ "el-GR", "Greek" ], [ "en-GB", "English (UK)" ], [ "en-US", "English (US)" ], [ "es-CL", "Spanish (Chile)" ], [ "es-ES", "Spanish (Spain)" ], [ "es-MX", "Spanish (Mexico)" ], [ "et-EE", "Estonian" ], [ "eu", "Basque" ], [ "fa-IR", "Persian" ], [ "fi-FI", "Finnish" ], [ "fr-CA", "French (Canada)" ], [ "fr-FR", "French (France)" ], [ "he-IL", "Hebrew" ], [ "hr-HR", "Croatian" ], [ "hu-HU", "Hungarian" ], [ "id-ID", "Indonesian" ], [ "is-IS", "Icelandic" ], [ "it-IT", "Italian" ], [ "ja-JP", "Japanese" ], [ "km-KH", "Khmer" ], [ "ko-KR", "Korean" ], [ "la", "Latin" ], [ "lt-LT", "Lithuanian" ], [ "lv-LV", "Latvian" ], [ "mn-MN", "Mongolian" ], [ "nb-NO", "Norwegian (Bokmål)" ], [ "nl-NL", "Dutch" ], [ "nn-NO", "Norwegian (Nynorsk)" ], [ "pl-PL", "Polish" ], [ "pt-BR", "Portuguese (Brazil)" ], [ "pt-PT", "Portuguese (Portugal)" ], [ "ro-RO", "Romanian" ], [ "ru-RU", "Russian" ], [ "sk-SK", "Slovak" ], [ "sl-SI", "Slovenian" ], [ "sr-RS", "Serbian" ], [ "sv-SE", "Swedish" ], [ "th-TH", "Thai" ], [ "tr-TR", "Turkish" ], [ "uk-UA", "Ukrainian" ], [ "vi-VN", "Vietnamese" ], [ "zh-CN", "Chinese (PRC)" ], [ "zh-TW", "Chinese (Taiwan)" ] ];
    this._bNumFormat = false;
    this._stateSettings = {
        style: "",
        notesStyle: this._cslStylesManager.getLastUsedNotesStyle(),
        styleFormat: this._cslStylesManager.getLastUsedFormat()
    };
}

SettingsPage.prototype.getLocalesManager = function() {
    return this._localesManager;
};

SettingsPage.prototype.getStyleManager = function() {
    return this._cslStylesManager;
};

SettingsPage.prototype.getLocale = function() {
    return this._localesManager.getLocale();
};

SettingsPage.prototype.getLastUsedStyleId = function() {
    return this._cslStylesManager.getLastUsedStyleId();
};

SettingsPage.prototype.init = function() {
    var lastStyle = this._cslStylesManager.getLastUsedStyleId() || "ieee";
    var savedLang = this._localesManager.getLastUsedLanguage();
    this._addEventListeners();
    this._languageSelect.addItems(this._LANGUAGES, savedLang);
    var promises = [ this._onStyleChange(lastStyle), this._localesManager.loadLocale(savedLang), this._loadStyles() ];
    return Promise.all(promises);
};

SettingsPage.prototype.onChangeState = function(callbackFn) {
    this._onChangeState = callbackFn;
};

SettingsPage.prototype.setDesktopApiAvailable = function(isAvailable) {
    this._localesManager.setDesktopApiAvailable(isAvailable);
    this._cslStylesManager.setDesktopApiAvailable(isAvailable);
};

SettingsPage.prototype.setRestApiAvailable = function(isAvailable) {
    this._localesManager.setRestApiAvailable(isAvailable);
    this._cslStylesManager.setRestApiAvailable(isAvailable);
};

SettingsPage.prototype._addEventListeners = function() {
    var self = this;
    this._openSettingsBtn.subscribe(function(event) {
        if (event.type !== "button:click") {
            return;
        }
        self._show();
    });
    this._saveBtn.subscribe(function(event) {
        if (event.type !== "button:click") {
            return;
        }
        var selectedLang = self._languageSelect.getSelectedValue();
        if (selectedLang === null) {
            console.error("No language selected");
            return;
        }
        var promises = [];
        if (self._stateSettings.language !== selectedLang) {
            self._localesManager.saveLastUsedLanguage(selectedLang);
            promises.push(self._localesManager.loadLocale(selectedLang).catch(function(err) {
                console.error(err);
                self._langMessage.show(translate("Failed to load language"));
                throw err;
            }));
        }
        var noteValue = "footnotes";
        if (self._endNotes.getState().checked) {
            noteValue = "endnotes";
        }
        if (self._stateSettings.notesStyle !== noteValue && noteValue === "footnotes" || noteValue === "endnotes") {
            self._cslStylesManager.saveLastUsedNotesStyle(noteValue);
        }
        var selectedStyleId = self._styleSelect.getSelectedValue();
        if (self._stateSettings.style !== selectedStyleId && selectedStyleId !== null) {
            promises.push(self._onStyleChange(selectedStyleId));
        }
        if (promises.length) {
            self._showLoader();
            Promise.all(promises).then(function() {
                self._hide();
                self._hideLoader();
                self._onChangeState({
                    language: selectedLang,
                    style: self._cslStylesManager.getLastUsedStyleIdOrDefault(),
                    notesStyle: self._cslStylesManager.getLastUsedNotesStyle(),
                    styleFormat: self._cslStylesManager.getLastUsedFormat()
                });
            }).catch(function(err) {
                self._hideLoader();
            });
        } else {
            self._hide();
        }
    });
    this._cancelBtn.subscribe(function(event) {
        if (event.type !== "button:click") {
            return;
        }
        var selectedLang = self._languageSelect.getSelectedValue();
        var selectedStyleId = self._styleSelect.getSelectedValue();
        if (selectedLang !== null && self._localesManager.getLastUsedLanguage() !== selectedLang) {
            self._languageSelect.selectItems(self._localesManager.getLastUsedLanguage(), true);
        }
        if (self._stateSettings.style !== selectedStyleId && selectedStyleId !== null) {
            self._styleSelect.selectItems(self._stateSettings.style, true);
            self._styleSelectListOther.selectItems(self._stateSettings.style, true);
            self._onStyleChange(self._stateSettings.style, true).then(function() {
                self._hide();
            });
        } else {
            self._hide();
        }
    });
    this._cslFileInput.onchange = function(e) {
        if (!(e.target instanceof HTMLInputElement)) return;
        var target = e.target;
        if (!target.files) return;
        var file = target.files[0];
        if (!file) {
            console.error("No file selected");
            return;
        }
        self._cslStylesManager.addCustomStyle(file).then(function(styleValue) {
            self._addStylesToList([ styleValue ]);
        }).catch(function(error) {
            console.error(error);
            self._styleMessage.show(translate("Invalid CSL style file"));
        }).finally(function() {
            self._hideLoader();
        });
    };
    this._styleSelect.subscribe(function(event) {
        if (event.type === "selectbox:change") {
            self._styleSelectListOther.selectItems(event.detail.current.toString(), true);
            self._somethingWasChanged();
            self._onStyleChange(event.detail.current.toString(), true);
            return;
        } else if (event.type !== "selectbox:custom") {
            return;
        }
        var actionId = event.detail.current;
        if (actionId === "more_styles") {
            self._styleSelectListOther.openDropdown();
        }
    });
    self._styleSelectListOther.subscribe(function(event) {
        if (event.type !== "selectbox:change") {
            return;
        }
        if (!event.detail.items) return;
        var item = event.detail.items[0];
        self._styleSelect.addItem(item.value, item.text, true);
        self._somethingWasChanged();
        self._onStyleChange(item.value, true);
    });
    this._languageSelect.subscribe(function(event) {
        if (event.type !== "selectbox:change") {
            return;
        }
        self._somethingWasChanged();
    });
    this._footNotes.subscribe(function(event) {
        self._somethingWasChanged();
    });
    this._endNotes.subscribe(function(event) {
        self._somethingWasChanged();
    });
};

SettingsPage.prototype._hideAllMessages = function() {
    this._langMessage.close();
    this._styleMessage.close();
};

SettingsPage.prototype._hide = function() {
    this._router.openMain();
};

SettingsPage.prototype._show = function() {
    this._stateSettings = {
        language: this._localesManager.getLastUsedLanguage(),
        style: this._cslStylesManager.getLastUsedStyleIdOrDefault(),
        notesStyle: this._cslStylesManager.getLastUsedNotesStyle(),
        styleFormat: this._cslStylesManager.getLastUsedFormat()
    };
    this._saveBtn.disable();
    this._router.openSettings();
    if (this._stateSettings.notesStyle === this._endNotes.getState().value) {
        this._endNotes.check();
    } else {
        this._footNotes.check();
    }
};

SettingsPage.prototype._loadStyles = function() {
    var self = this;
    return this._cslStylesManager.getStylesInfo().then(function(stylesInfo) {
        self._addStylesToList(stylesInfo);
        self._styleSelect.addCustomItem("more_styles", "More Styles...");
        self._styleSelect.addCustomItem("cslFileInput", "Add custom style...");
    }).catch(function(err) {
        console.error(err);
    });
};

SettingsPage.prototype._addStylesToList = function(stylesInfo) {
    var self = this;
    var lastStyle = this._cslStylesManager.getLastUsedStyleIdOrDefault();
    var allStyles = stylesInfo.map(function(style) {
        return [ style.name, style.title ];
    });
    var mainStyles = allStyles.filter(function(style) {
        if (style[0] == lastStyle) return true;
        if (self._cslStylesManager.isStyleDefault(style[0])) return true;
        return false;
    });
    this._styleSelect.addItems(mainStyles, lastStyle);
    this._styleSelectListOther.addItems(allStyles, lastStyle);
};

SettingsPage.prototype._somethingWasChanged = function() {
    this._saveBtn.enable();
};

SettingsPage.prototype._onStyleChange = function(styleName, isClick) {
    var self = this;
    isClick && self._showLoader();
    return self._cslStylesManager.getStyle(styleName).then(function(style) {
        var styleFormat = self._cslStylesManager.getLastUsedFormat();
        self._bNumFormat = styleFormat == "numeric";
        if ("note" === styleFormat) {
            self._notesStyleWrapper.classList.remove(self._displayNoneClass);
        } else {
            self._notesStyleWrapper.classList.add(self._displayNoneClass);
        }
        var notesStyle = self._cslStylesManager.getLastUsedNotesStyle();
        var notesAs = self._notesStyleWrapper.querySelector('input[name="notesAs"][value="' + notesStyle + '"]');
        if (notesAs && notesAs instanceof HTMLInputElement) {
            notesAs.checked = true;
        }
        isClick && self._hideLoader();
    }).catch(function(err) {
        console.error(err);
        if (typeof err === "string") {
            self._styleMessage.show(translate(err));
        }
        isClick && self._hideLoader();
    });
};

SettingsPage.prototype._showLoader = function() {
    this._cancelBtn.disable();
    this._saveBtn.disable();
    this._styleSelect.disable();
    this._languageSelect.disable();
};

SettingsPage.prototype._hideLoader = function() {
    this._cancelBtn.enable();
    this._saveBtn.enable();
    this._styleSelect.enable();
    this._languageSelect.enable();
};

function LoginPage(router, sdk) {
    this._router = router;
    this._sdk = sdk;
    this._apiKeyLoginField = new InputField("apiKeyField", {
        autofocus: true,
        autocomplete: "on"
    });
    this._saveApiKeyBtn = new Button("saveApiKeyBtn", {
        disabled: true
    });
    this._apiKeyMessage = new Message("apiKeyMessage", {
        type: "error"
    });
    this._useDesktopMessage = new Message("useDesktopMessage", {
        type: "error"
    });
    this._connectToLocalZotero = new Button("connectToLocalZotero", {
        variant: "secondary"
    });
    this._useDesktopApp = document.getElementById("useDesktopApp");
    if (!this._useDesktopApp) {
        throw new Error("useDesktopApp not found");
    }
    this._logoutLink = document.getElementById("logoutLink");
    if (!this._logoutLink) {
        throw new Error("logoutLink not found");
    }
    this._onAuthorized = function(e) {};
    this._onChangeState = function(e) {};
    this._onOpen = function() {};
}

LoginPage.prototype.init = function() {
    var self = this;
    this._addEventListeners();
    var hasFirstAnswer = false;
    var onlineZoteroElements = document.querySelectorAll(".for-zotero-online");
    var apisChecker = ZoteroApiChecker.runApisChecker(self._sdk);
    apisChecker.subscribe(function(apis) {
        self._onChangeState(apis);
        if (!hasFirstAnswer) {
            hasFirstAnswer = true;
            if (!apis.desktopVersion && self._useDesktopApp) {
                self._useDesktopApp.classList.add("hidden");
            }
            self._onOpen();
            self._show();
        }
        if (apis.online) {
            onlineZoteroElements.forEach(function(element) {
                element.classList.remove("hidden");
            });
        } else {
            onlineZoteroElements.forEach(function(element) {
                element.classList.add("hidden");
            });
        }
        if (apis.online && apis.hasKey) {
            self._sdk.setIsOnlineAvailable(true);
            self._hide(true);
            self._onAuthorized(apis);
            return;
        } else if (apis.desktop && apis.hasPermission) {
            self._sdk.setIsOnlineAvailable(false);
            self._hide();
            self._hideAllMessages();
            self._onAuthorized(apis);
            return;
        }
    });
    var triggers = {
        onOpen: function onOpen(callbackFn) {
            self._onOpen = callbackFn;
            return triggers;
        },
        onChangeState: function onChangeState(callbackFn) {
            self._onChangeState = callbackFn;
            return triggers;
        },
        onAuthorized: function onAuthorized(callbackFn) {
            self._onAuthorized = callbackFn;
            return triggers;
        }
    };
    return triggers;
};

LoginPage.prototype._addEventListeners = function() {
    var self = this;
    this._apiKeyLoginField.subscribe(function(event) {
        if (event.type !== "inputfield:submit") ;
        if (event.type === "inputfield:input") {
            if (self._apiKeyLoginField.getValue()) {
                self._saveApiKeyBtn.enable();
            } else {
                self._saveApiKeyBtn.disable();
            }
        }
    });
    this._saveApiKeyBtn.subscribe(function(event) {
        if (event.type !== "button:click") {
            return;
        }
        self._tryToApplyKey();
    });
    this._connectToLocalZotero.subscribe(function(event) {
        if (event.type !== "button:click") {
            return;
        }
        ZoteroApiChecker.checkStatus(self._sdk).then(function(apis) {
            if (apis.desktop && apis.hasPermission) {
                self._sdk.setIsOnlineAvailable(false);
                self._hide();
                self._hideAllMessages();
            } else if (apis.desktop && !apis.hasPermission) {
                var errorMessage = "Connection to Zotero failed. " + "Please enable external connections in Zotero: " + 'Edit → Settings → Advanced → Check "Allow other ' + 'applications on this computer to communicate with Zotero"';
                self._useDesktopMessage.show(translate(errorMessage));
            } else if (!apis.desktop) {
                self._useDesktopMessage.show(translate("Connection to Zotero failed. Make sure Zotero is running."));
            }
        });
    });
    this._logoutLink.onclick = function(e) {
        self._sdk.clearSettings();
        self._show();
        return true;
    };
};

LoginPage.prototype._tryToApplyKey = function() {
    var self = this;
    var apiKey = self._apiKeyLoginField.getValue();
    if (apiKey) {
        self._sdk.setApiKey(apiKey).then(function() {
            ZoteroApiChecker.successfullyLoggedInUsingApiKey();
            self._hide(true);
        }).catch(function(err) {
            console.error(err);
            self._apiKeyMessage.show(translate("Invalid API key"));
        });
    }
};

LoginPage.prototype._hideAllMessages = function() {
    this._apiKeyMessage.close();
};

LoginPage.prototype._hide = function(bShowLogoutLink) {
    this._router.openMain();
    if (bShowLogoutLink) {
        this._logoutLink.classList.remove("hidden");
    }
};

LoginPage.prototype._show = function() {
    this._router.openLogin();
    this._logoutLink.classList.add("hidden");
};

function SearchFilterComponents() {
    this._searchField = new InputField("searchField", {
        type: "text",
        autofocus: true,
        showClear: true
    });
    this._filterButton = new Button("filterButton", {
        variant: "secondary-icon",
        size: "small"
    });
    this._librarySelectList = new SelectBox("librarySelectList", {
        placeholder: translate("No items selected"),
        multiple: true,
        description: translate("Search in:")
    });
    this._subscribers = [];
    this._addEventListeners();
}

SearchFilterComponents.prototype._addEventListeners = function() {
    var self = this;
    this._searchField.subscribe(function(e) {
        if (e.type === "inputfield:blur" || e.type === "inputfield:submit") {
            var selectedGroups = self._getSelectedGroups();
            self._subscribers.forEach(function(cb) {
                cb(e.detail.value, selectedGroups);
            });
        }
    });
    this._filterButton.subscribe(function(e) {
        if (e.type === "button:click") {
            if (!self._librarySelectList.isOpen) {
                if (e.detail.originalEvent) {
                    e.detail.originalEvent.stopPropagation();
                }
                self._librarySelectList.openDropdown();
            }
        }
    });
};

SearchFilterComponents.prototype.addGroups = function(groups) {
    var self = this;
    var savedGroups = localStorage.getItem("selectedGroups");
    var selectedItems = savedGroups ? JSON.parse(savedGroups).map(function(id) {
        return id.toString();
    }) : [ "my_library", "group_libraries" ];
    var hasSelected = false;
    groups.forEach(function(group) {
        group.id = String(group.id);
    });
    var customGroups = [ {
        id: "my_library",
        name: translate("My Library")
    }, {
        id: "group_libraries",
        name: translate("Group Libraries")
    } ];
    !hasSelected && customGroups.forEach(function(group) {
        if (selectedItems.indexOf(group.id) !== -1) {
            hasSelected = true;
        }
    });
    !hasSelected && groups.forEach(function(group) {
        if (selectedItems.indexOf(group.id.toString()) !== -1) {
            hasSelected = true;
        }
    });
    if (!hasSelected) {
        selectedItems = [ "my_library", "group_libraries" ];
    }
    var addGroupToSelectBox = function addGroupToSelectBox(id, name, selected) {
        if (typeof id === "number") {
            id = id.toString();
        }
        if (self._librarySelectList instanceof SelectBox) self._librarySelectList.addItem(id, name, selected);
    };
    for (var i = 0; i < customGroups.length; i++) {
        var id = customGroups[i].id;
        var name = customGroups[i].name;
        addGroupToSelectBox(id, name, selectedItems.indexOf(id) !== -1);
    }
    if (groups.length === 0) {
        return;
    }
    this._librarySelectList.addSeparator();
    var selected = selectedItems.indexOf("group_libraries") !== -1;
    for (var i = 0; i < groups.length; i++) {
        var _id = groups[i].id;
        var _name = groups[i].name;
        addGroupToSelectBox(_id, _name, selected || selectedItems.indexOf(_id.toString()) !== -1);
    }
    this._selectedGroupsWatcher(customGroups, groups);
};

SearchFilterComponents.prototype._getSelectedGroups = function() {
    var self = this;
    var ids = this._librarySelectList.getSelectedValues();
    if (Array.isArray(ids) === false || ids.length === 0) {
        setTimeout(function() {
            self._librarySelectList.openDropdown();
        }, 500);
    }
    if (ids === null || typeof ids === "string") {
        return [];
    }
    return ids;
};

SearchFilterComponents.prototype.subscribe = function(callback) {
    var self = this;
    this._subscribers.push(callback);
    return {
        unsubscribe: function unsubscribe() {
            self._subscribers = self._subscribers.filter(function(cb) {
                return cb !== callback;
            });
        }
    };
};

SearchFilterComponents.prototype._selectedGroupsWatcher = function(customGroups, groups) {
    var self = this;
    if (this._librarySelectList instanceof SelectBox === false) {
        return;
    }
    this._librarySelectList.subscribe(function(event) {
        if (event.type !== "selectbox:change") {
            return;
        }
        var aGroupsToSave = [];
        var values = event.detail.values;
        var current = event.detail.current;
        var bEnabled = event.detail.enabled;
        var customIds = customGroups.map(function(group) {
            return group.id;
        });
        var ids = groups.map(function(group) {
            return group.id.toString();
        });
        var bWasCustom = customIds.indexOf(String(current)) !== -1;
        if (bWasCustom) {
            if (current === "group_libraries") {
                if (bEnabled) {
                    aGroupsToSave.push("group_libraries");
                    self._librarySelectList.selectItems(ids, true);
                } else {
                    self._librarySelectList.unselectItems(ids, true);
                }
                if (values.indexOf("my_library") !== -1) {
                    aGroupsToSave.push("my_library");
                }
            } else {
                if (values.indexOf("group_libraries") !== -1) {
                    aGroupsToSave.push("group_libraries");
                    if (bEnabled) {
                        aGroupsToSave.push(current);
                    }
                } else {
                    aGroupsToSave = values.slice();
                }
            }
        } else if (!bWasCustom) {
            var bAllGroupsSelected = ids.every(function(id) {
                return values.indexOf(id) !== -1;
            });
            if (bAllGroupsSelected) {
                self._librarySelectList.selectItems("group_libraries", true);
                aGroupsToSave.push("group_libraries");
                if (values.indexOf("my_library") !== -1) {
                    aGroupsToSave.push("my_library");
                }
            } else {
                self._librarySelectList.unselectItems("group_libraries", true);
                aGroupsToSave = values.filter(function(value) {
                    return value !== "group_libraries";
                });
            }
        }
        if (aGroupsToSave.length === 0) {
            localStorage.removeItem("selectedGroups");
        } else {
            localStorage.setItem("selectedGroups", JSON.stringify(aGroupsToSave));
        }
    });
};

function SelectCitationsComponent(displayNoneClass, fLoadMore, fShouldLoadMore) {
    this._displayNoneClass = displayNoneClass;
    this._items = {};
    this._html = {};
    this._checks = {};
    this._LOCATOR_VALUES = [ [ "appendix", "Appendix" ], [ "article", "Article" ], [ "book", "Book" ], [ "chapter", "Chapter" ], [ "column", "Column" ], [ "figure", "Figure" ], [ "folio", "Folio" ], [ "issue", "Issue" ], [ "line", "Line" ], [ "note", "Note" ], [ "opus", "Opus" ], [ "page", "Page" ], [ "paragraph", "Paragraph" ], [ "part", "Part" ], [ "rule", "Rule" ], [ "section", "Section" ], [ "sub-verbo", "Sub verbo" ], [ "table", "Table" ], [ "title", "Title" ], [ "verses", "Verses" ], [ "volume", "Volume" ] ];
    this._cancelSelectBtn = document.getElementById("cancelSelectBtn");
    this._docsHolder = document.getElementById("docsHolder");
    this._docsThumb = document.getElementById("docsThumb");
    this._selectedWrapper = document.getElementById("selectedWrapper");
    this._selectedHolder = document.getElementById("selectedHolder");
    this._selectedInfo = document.getElementById("selectedInfo");
    this._selectedCount = document.getElementById("selectedCount");
    this._selectedThumb = document.getElementById("selectedThumb");
    if (this._selectedHolder && this._selectedThumb) {
        this._selectedScroller = this._initScrollBox(this._selectedHolder, this._selectedThumb, 20);
    }
    if (this._docsHolder && this._docsThumb) {
        this._docsScroller = this._initScrollBox(this._docsHolder, this._docsThumb, 40, this._checkDocsScroll.bind(this));
    }
    this._subscribers = [];
    this._fShouldLoadMore = fShouldLoadMore;
    this._fLoadMore = fLoadMore;
    this._loadTimeout;
    this._init();
}

SelectCitationsComponent.prototype._init = function() {
    var self = this;
    if (this._cancelSelectBtn) {
        this._cancelSelectBtn.onclick = function(e) {
            var ids = [];
            for (var id in self._items) {
                ids.push(id);
            }
            for (var i = 0; i < ids.length; i++) {
                self._removeSelected(ids[i]);
            }
        };
    }
};

SelectCitationsComponent.prototype.clearLibrary = function() {
    var holder = this._docsHolder;
    while (holder && holder.lastChild) {
        holder.removeChild(holder.lastChild);
    }
    if (holder) holder.scrollTop = 0;
    this._docsScroller.onscroll();
};

SelectCitationsComponent.prototype.displaySearchItems = function(append, res, err, showNotFound, first) {
    var self = this;
    var holder = this._docsHolder;
    if (!append) {
        this.clearLibrary();
    }
    var page = document.createElement("div");
    if (holder) page.classList.add("page" + holder.children.length);
    return new Promise((resolve, reject) => {
        if (res && res.items && res.items.length > 0) {
            for (var index = 0; index < res.items.length; index++) {
                var item = res.items[index];
                page.appendChild(self._buildDocElement(item));
            }
        } else if (err || first) {
            if (err) {
                reject(err);
            } else if (showNotFound) {
                var notFound = document.createElement("div");
                notFound.textContent = translate("Nothing found");
                notFound.classList.add("searchInfo");
                page.appendChild(notFound);
            }
        }
        if (holder) holder.appendChild(page);
        this._docsScroller.onscroll();
        resolve(true);
    });
};

SelectCitationsComponent.prototype.getSelectedItems = function() {
    var items = Object.assign({}, this._items || {});
    return items;
};

SelectCitationsComponent.prototype.removeItems = function(keys) {
    var self = this;
    keys.forEach(function(key) {
        self._removeSelected(key);
    });
};

SelectCitationsComponent.prototype.subscribe = function(callback) {
    var self = this;
    this._subscribers.push(callback);
    return {
        unsubscribe: function unsubscribe() {
            self._subscribers = self._subscribers.filter(function(cb) {
                return cb !== callback;
            });
        }
    };
};

SelectCitationsComponent.prototype._buildDocElement = function(item) {
    var self = this;
    var root = document.createElement("div");
    root.classList.add("doc");
    var docInfo = document.createElement("div");
    docInfo.classList.add("docInfo");
    var checkHolder = document.createElement("div");
    var label = "";
    if (item.author && item.author.length > 0) {
        label = item.author.map(function(a) {
            if (a.family && a.given) {
                return a.family.trim() + ", " + a.given.trim();
            } else if (a.family) {
                return a.family.trim();
            } else if (a.given) {
                return a.given.trim();
            }
            return "";
        }).join("; ");
    }
    var arrow = document.createElement("div");
    arrow.classList.add("selectbox-arrow");
    arrow.innerHTML = '<svg width="6" height="6" viewBox="0 0 6 6" ' + 'fill="none" xmlns="http://www.w3.org/2000/svg">' + '<path fill-rule="evenodd" clip-rule="evenodd"' + ' d="M3 0L0 2.9978L3 5.99561L6 2.9978L3 0ZM3 0.00053797L0.75' + ' 2.24889L3 4.49724L5.25 2.24889L3 0.00053797Z" ' + 'fill="currentColor"/></svg>';
    var title = document.createElement("div");
    title.textContent = item.title.trim();
    title.classList.add("truncate-text");
    title.classList.add("secondary-text");
    if (item.publisher || item["publisher-place"]) {
        title.textContent += " · " + (item.publisher || item["publisher-place"] || "");
    }
    if (item.issued && item.issued["date-parts"]) {
        var date = item.issued["date-parts"][0];
        if (label.length > 20) {
            title.textContent += " (" + date.join("-") + ")";
        } else {
            if (label.length > 0 && label.slice(-1) !== "." && label.slice(-1) !== ",") label += ".";
            label += " " + date.join("-");
        }
    }
    if (label.length === 0) {
        label = title.textContent;
    }
    title.setAttribute("title", title.textContent);
    docInfo.appendChild(title);
    var check = document.createElement("input");
    checkHolder.appendChild(check);
    var checkInput = new Checkbox(check, {
        checked: !!this._items[item.id],
        label: label,
        id: item.id
    });
    if (this._items[item.id]) {
        this._checks[item.id] = checkInput;
    }
    checkHolder.appendChild(arrow);
    root.appendChild(checkHolder);
    root.appendChild(docInfo);
    var params;
    function toggleItem() {
        root.classList.toggle("doc-open");
        if (!params) {
            params = self._buildCitationParams(item);
            root.appendChild(params);
        }
    }
    arrow.onclick = toggleItem;
    checkInput.subscribe(function(event) {
        if (event.type !== "checkbox:change") {
            return;
        }
        if (event.detail.checked) {
            self._addSelected(item, checkInput);
        } else {
            self._removeSelected(item.id);
        }
    });
    return root;
};

SelectCitationsComponent.prototype._buildCitationParams = function(item) {
    var locatorLabel = localStorage.getItem("selectedLocator") || "page";
    item.label = locatorLabel;
    var params = document.createDocumentFragment();
    var prefixSuffixContainer = document.createElement("div");
    var prefix = document.createElement("input");
    var suffix = document.createElement("input");
    var locatorContainer = document.createElement("div");
    var locatorSelect = document.createElement("div");
    var locator = document.createElement("input");
    var omitAuthorContainer = document.createElement("div");
    var omitAuthor = document.createElement("input");
    params.appendChild(prefixSuffixContainer);
    prefixSuffixContainer.appendChild(prefix);
    prefixSuffixContainer.appendChild(suffix);
    params.appendChild(locatorContainer);
    locatorContainer.appendChild(locatorSelect);
    locatorContainer.appendChild(locator);
    var locatorPlaceholder = "";
    params.appendChild(omitAuthorContainer);
    omitAuthorContainer.appendChild(omitAuthor);
    var prefixInput = new InputField(prefix, {
        type: "text",
        placeholder: "Prefix"
    });
    var suffixInput = new InputField(suffix, {
        type: "text",
        placeholder: "Suffix"
    });
    var locatorSelectbox = new SelectBox(locatorSelect, {
        placeholder: "Locator"
    });
    this._LOCATOR_VALUES.forEach(function(info) {
        var selected = info[0] === locatorLabel;
        locatorSelectbox.addItem(info[0], info[1], selected);
        if (selected) {
            locatorPlaceholder = info[1];
        }
    });
    var locatorInput = new InputField(locator, {
        type: "text",
        placeholder: locatorPlaceholder
    });
    var omitAuthorInput = new Checkbox(omitAuthor, {
        label: "Omit author"
    });
    prefixInput.subscribe(function(event) {
        if (event.type !== "inputfield:input") {
            return;
        }
        item.prefix = event.detail.value;
    });
    suffixInput.subscribe(function(event) {
        if (event.type !== "inputfield:input") {
            return;
        }
        item.suffix = event.detail.value;
    });
    locatorInput.subscribe(function(event) {
        if (event.type !== "inputfield:input") {
            return;
        }
        item.locator = event.detail.value;
    });
    locatorSelectbox.subscribe(function(event) {
        if (event.type !== "selectbox:change") {
            return;
        }
        if (!event.detail.items) {
            return;
        }
        var eventItem = event.detail.items[0];
        locatorInput.setPlaceholder(eventItem.text);
        item.label = event.detail.values[0].toString();
        localStorage.setItem("selectedLocator", item.label);
    });
    omitAuthorInput.subscribe(function(event) {
        if (event.type !== "checkbox:change") {
            return;
        }
        item["suppress-author"] = event.detail.checked;
    });
    return params;
};

SelectCitationsComponent.prototype._buildSelectedElement = function(item) {
    var self = this;
    var root = document.createElement("div");
    root.classList.add("selDoc");
    var span = document.createElement("span");
    if (item.author && item.author.length > 0) {
        span.textContent = item.author.map(function(a) {
            return a.family + ", " + a.given;
        }).join("; ");
    } else {
        span.textContent = item.title;
    }
    if (item.issued && item.issued["date-parts"]) {
        span.textContent += " " + item.issued["date-parts"][0].join("-");
    }
    span.setAttribute("title", span.textContent);
    root.appendChild(span);
    var remove = document.createElement("span");
    remove.onclick = function() {
        self._removeSelected(item.id);
    };
    remove.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">' + '<path d="M12.0718 4.6333L11.564 5.14404L10.5483 6.1665L8.70459 8.02002L10.3862 9.7124L11.4829' + " 10.8149L12.0308 11.3667L11.3218 12.0718L10.7729 11.52L9.67725 10.4175L7.99951 8.729L6.32275" + " 10.4165L5.22705 11.52L4.67822 12.0718L3.96924 11.3667L4.51709 10.8149L5.61377 9.7124L7.29443" + " 8.02002L5.45166 6.1665L4.43604 5.14404L3.92822 4.6333L4.63721 3.92822L5.14502 4.43896L6.16162" + ' 5.46143L7.99951 7.31104L9.83838 5.46143L10.855 4.43896L11.3628 3.92822L12.0718 4.6333Z"' + ' fill="currentColor" fill-opacity="0.8"/></svg>';
    root.appendChild(remove);
    return root;
};

SelectCitationsComponent.prototype._addSelected = function(item, checkbox) {
    var el = this._buildSelectedElement(item);
    this._items[item.id] = item;
    this._html[item.id] = el;
    this._checks[item.id] = checkbox;
    if (this._selectedHolder) {
        this._selectedHolder.appendChild(el);
    }
    this._docsScroller.onscroll();
    this._selectedScroller.onscroll();
    this._checkSelected();
};

SelectCitationsComponent.prototype._checkDocsScroll = function(holder, thumb) {
    var self = this;
    if (this._fShouldLoadMore(holder)) {
        if (this._loadTimeout) {
            clearTimeout(this._loadTimeout);
        }
        if (!lastSearch.obj && !lastSearch.text.trim() && !lastSearch.groups.length) return;
        this._loadTimeout = setTimeout(function() {
            if (self._fShouldLoadMore(holder)) {
                self._fLoadMore();
            }
        }, 500);
    }
};

SelectCitationsComponent.prototype._initScrollBox = function(holder, thumb, minThumbHeight, onscroll) {
    var scroller = {};
    scroller.onscroll = this._checkScroll(holder, thumb, minThumbHeight, onscroll);
    holder.onwheel = function(e) {
        holder.scrollTop += e.deltaY > 10 || e.deltaY < -10 ? e.deltaY : e.deltaY * 20;
        scroller.onscroll();
    };
    thumb.onmousedown = function(e) {
        thumb.classList.add("scrolling");
        var y = e.clientY;
        var initialPos = holder.scrollTop;
        window.onmouseup = function(e) {
            thumb.classList.remove("scrolling");
            window.onmouseup = null;
            window.onmousemove = null;
        };
        window.onmousemove = function(e) {
            var delta = e.clientY - y;
            var percMoved = delta / holder.clientHeight;
            var deltaScroll = holder.scrollHeight * percMoved;
            holder.scrollTop = initialPos + deltaScroll;
            scroller.onscroll();
        };
    };
    document.body.addEventListener("resize", function() {
        scroller.onscroll();
    });
    return scroller;
};

SelectCitationsComponent.prototype._checkScroll = function(holder, thumb, minThumbHeight, func) {
    var displayNoneClass = this._displayNoneClass;
    return function() {
        if (holder.scrollHeight <= holder.clientHeight) {
            thumb.classList.add(displayNoneClass);
        } else {
            thumb.classList.remove(displayNoneClass);
            var height = holder.clientHeight / holder.scrollHeight * holder.clientHeight;
            height = height < minThumbHeight ? minThumbHeight : height;
            thumb.style.height = height + "px";
            var scroll = holder.scrollHeight - holder.clientHeight;
            var percScrolled = holder.scrollTop / scroll;
            var margin = percScrolled * (holder.clientHeight - height);
            thumb.style.marginTop = margin + "px";
        }
        if (func) func(holder, thumb);
    };
};

SelectCitationsComponent.prototype._removeSelected = function(id) {
    var el = this._html[id];
    if (this._selectedHolder) {
        this._selectedHolder.removeChild(el);
    }
    delete this._items[id];
    delete this._html[id];
    if (this._checks[id]) {
        this._checks[id].uncheck(true);
        delete this._checks[id];
    }
    this._docsScroller.onscroll();
    this._selectedScroller.onscroll();
    this._checkSelected();
};

SelectCitationsComponent.prototype._checkSelected = function() {
    var numOfSelected = this._count();
    if (!this._selectedInfo || !this._selectedCount || !this._selectedWrapper) {
        return;
    }
    if (numOfSelected <= 0) {
        this._selectedWrapper.classList.add(this._displayNoneClass);
        this._selectedInfo.classList.add(this._displayNoneClass);
    } else {
        this._selectedWrapper.classList.remove(this._displayNoneClass);
        this._selectedInfo.classList.remove(this._displayNoneClass);
        this._selectedCount.textContent = numOfSelected + " " + translate("selected");
    }
    this._subscribers.forEach(function(cb) {
        cb(numOfSelected);
    });
};

SelectCitationsComponent.prototype._count = function() {
    var k = 0;
    for (var i in this._items) k++;
    return k;
};

(function() {
    var counter = 0;
    var displayNoneClass = "hidden";
    var blurClass = "blur";
    var router;
    var sdk;
    var settings;
    var citationService;
    var lastSearch = {
        text: "",
        obj: null,
        groups: [],
        groupsHash: ""
    };
    var searchFilter;
    var selectCitation;
    var saveAsTextBtn;
    var insertLinkBtn;
    var insertBibBtn;
    var refreshBtn;
    var elements = {};
    function initElements() {
        var loader = document.getElementById("loader");
        if (!loader) {
            throw new Error("loader not found");
        }
        var libLoader = document.getElementById("libLoader");
        if (!libLoader) {
            throw new Error("libLoader not found");
        }
        var error = document.getElementById("errorWrapper");
        if (!error) {
            throw new Error("errorWrapper not found");
        }
        var contentHolder = document.getElementById("content");
        if (!contentHolder) {
            throw new Error("contentHolder not found");
        }
        var mainState = document.getElementById("mainState");
        if (!mainState) {
            throw new Error("mainState not found");
        }
        searchFilter = new SearchFilterComponents;
        selectCitation = new SelectCitationsComponent(displayNoneClass, loadMore, shouldLoadMore);
        saveAsTextBtn = new Button("saveAsTextBtn", {
            variant: "secondary"
        });
        insertLinkBtn = new Button("insertLinkBtn", {
            disabled: true
        });
        insertBibBtn = new Button("insertBibBtn", {
            variant: "secondary"
        });
        refreshBtn = new Button("refreshBtn", {
            variant: "secondary"
        });
        elements = {
            loader: loader,
            libLoader: libLoader,
            error: error,
            contentHolder: contentHolder,
            mainState: mainState
        };
    }
    window.Asc.plugin.init = function() {
        initElements();
        showLoader(true);
        router = new Router;
        sdk = new ZoteroSdk;
        var loginPage = new LoginPage(router, sdk);
        settings = new SettingsPage(router, displayNoneClass);
        citationService = new CitationService(settings.getLocalesManager(), settings.getStyleManager(), sdk);
        var isInit = false;
        addEventListeners();
        loginPage.init().onOpen(function() {
            showLoader(false);
        }).onChangeState(function(apis) {
            settings.setDesktopApiAvailable(apis.desktop);
            settings.setRestApiAvailable(apis.online);
        }).onAuthorized(function(apis) {
            if (isInit) return;
            isInit = true;
            showLoader(true);
            Promise.all([ loadGroups(), settings.init() ]).then(function() {
                showLoader(false);
            });
        });
        window.Asc.plugin.onTranslate = applyTranslations;
    };
    function loadGroups() {
        return sdk.getUserGroups().then(function(groups) {
            searchFilter.addGroups(groups);
        });
    }
    function addEventListeners() {
        selectCitation.subscribe(checkSelected);
        function searchFor(text, selectedGroups) {
            text = text.trim();
            var groupsHash = selectedGroups.join(",");
            if (elements.mainState.classList.contains(displayNoneClass) || !text || text == lastSearch.text && groupsHash === lastSearch.groupsHash || selectedGroups.length === 0) return Promise.resolve();
            selectCitation.clearLibrary();
            var promises = [];
            return sdk.getUserGroups().then(function(userGroups) {
                var groups = selectedGroups.filter(function(group) {
                    return group !== "my_library" && group !== "group_libraries";
                });
                var append = true;
                var showLoader = true;
                var hideLoader = !groups.length;
                var bCount = true;
                if (selectedGroups.indexOf("my_library") !== -1) {
                    promises.push(loadLibrary(sdk.getItems(text), append, showLoader, hideLoader, false, bCount));
                }
                for (var i = 0; i < groups.length; i++) {
                    showLoader = i === 0 && promises.length === 0;
                    hideLoader = i === groups.length - 1;
                    promises.push(loadLibrary(sdk.getGroupItems(text, groups[i]), append, showLoader, hideLoader, true, bCount));
                }
            }).then(function() {
                lastSearch.text = text;
                lastSearch.obj = null;
                lastSearch.groups = [];
                lastSearch.groupsHash = groupsHash;
                return Promise.all(promises);
            });
        }
        searchFilter.subscribe(function(text, selectedGroups) {
            searchFor(text, selectedGroups);
        });
        refreshBtn.subscribe(function(event) {
            if (event.type !== "button:click") {
                return;
            }
            if (!settings.getLastUsedStyleId()) {
                showError(translate("Style is not selected"));
                return;
            }
            if (!settings.getLocale()) {
                showError(translate("Language is not selected"));
                return;
            }
            showLoader(true);
            citationService.updateCslItems(true, true, false).catch(function(error) {
                console.error(error);
                var message = translate("Failed to refresh");
                if (typeof error === "string") {
                    message += ". " + translate(error);
                }
                showError(message);
            }).finally(function() {
                showLoader(false);
            });
        });
        insertBibBtn.subscribe(function(event) {
            if (event.type !== "button:click") {
                return;
            }
            if (!settings.getLastUsedStyleId()) {
                showError(translate("Style is not selected"));
                return;
            }
            if (!settings.getLocale()) {
                showError(translate("Language is not selected"));
                return;
            }
            showLoader(true);
            citationService.updateCslItems(true, true, true).catch(function(error) {
                console.error(error);
                var message = translate("Failed to insert bibliography");
                if (typeof error === "string") {
                    message += ". " + translate(error);
                }
                showError(message);
            }).finally(function() {
                showLoader(false);
            });
        });
        insertLinkBtn.subscribe(function(event) {
            if (event.type !== "button:click") {
                return;
            }
            if (!settings.getLastUsedStyleId()) {
                showError(translate("Style is not selected"));
                return;
            }
            if (!settings.getLocale()) {
                showError(translate("Language is not selected"));
                return;
            }
            showLoader(true);
            citationService.updateCslItems(true, false, false).then(function() {
                var items = selectCitation.getSelectedItems();
                return citationService.insertSelectedCitations(items);
            }).then(function(keys) {
                selectCitation.removeItems(keys);
            }).catch(function(error) {
                console.error(error);
                var message = translate("Failed to insert citation");
                if (typeof error === "string") {
                    message += ". " + translate(error);
                }
                showError(message);
            }).finally(function() {
                showLoader(false);
            });
        });
        saveAsTextBtn.subscribe(function(event) {
            if (event.type !== "button:click") {
                return;
            }
            showLoader(true);
            citationService.saveAsText().then(function() {
                showLoader(false);
            });
        });
        settings.onChangeState(function(settings) {
            citationService.setNotesStyle(settings.notesStyle);
            citationService.setStyleFormat(settings.styleFormat);
            return citationService.updateCslItems(true, true, false);
        });
    }
    Asc.plugin.onThemeChanged = function(theme) {
        window.Asc.plugin.onThemeChangedBase(theme);
        Theme.fixThemeForIE(theme);
        Theme.addStylesForComponents(theme);
        var rules = "";
        rules += ".link { color : " + window.Asc.plugin.theme["text-normal"] + ";}\n";
        rules += ".doc { border-color: " + theme["border-regular-control"] + "; background-color: " + theme["background-normal"] + "; }\n";
        rules += ".scrollThumb { box-shadow: 0 0 8px 8px " + theme["highlight-button-hover"] + " inset; }\n";
        rules += ".scrollThumb:active, .scrollThumb.scrolling { box-shadow: 0 0 8px 8px " + theme["canvas-scroll-thumb-pressed"] + " inset; }\n";
        rules += ".scrollThumb:hover { box-shadow: 0 0 8px 8px " + theme["canvas-scroll-thumb-hover"] + " inset; }\n";
        if ([ "theme-white", "theme-night" ].indexOf(theme.name) !== -1 || [ "theme-white", "theme-night" ].indexOf(theme.Name) !== -1) {
            rules += ".doc { border-radius: 4px; }\n";
        }
        var styleTheme = document.getElementById("pluginStyles");
        if (!styleTheme) {
            styleTheme = document.createElement("style");
            styleTheme.id = "pluginStyles";
            styleTheme.innerHTML = rules;
            document.getElementsByTagName("head")[0].appendChild(styleTheme);
        } else {
            styleTheme.innerHTML = rules;
        }
        var themeType = theme.type || "light";
        var body = document.body;
        body.classList.remove("theme-dark");
        body.classList.remove("theme-light");
        body.classList.add("theme-" + themeType);
    };
    function applyTranslations() {
        var elements = document.getElementsByClassName("i18n");
        for (var i = 0; i < elements.length; i++) {
            var el = elements[i];
            if (el instanceof HTMLElement === false) continue;
            [ "placeholder", "title" ].forEach(attr => {
                if (el.hasAttribute(attr)) {
                    el.setAttribute(attr, translate(el.getAttribute(attr) || ""));
                }
            });
            var translated = translate(el.innerText.trim());
            if (translated) el.innerText = translated;
        }
    }
    function showError(message) {
        if (message && typeof message === "string") {
            translate("");
            switchClass(elements.error, displayNoneClass, false);
            elements.error.textContent = message;
            setTimeout(function() {
                window.onclick = function() {
                    showError(false);
                };
            }, 100);
        } else {
            switchClass(elements.error, displayNoneClass, true);
            elements.error.textContent = "";
            window.onclick = null;
        }
    }
    function showLoader(show) {
        switchClass(elements.loader, displayNoneClass, !show);
        switchClass(elements.contentHolder, blurClass, show);
    }
    function showLibLoader(show) {
        switchClass(elements.libLoader, displayNoneClass, !show);
    }
    function switchClass(el, className, add) {
        if (add) {
            el.classList.add(className);
        } else {
            el.classList.remove(className);
        }
    }
    function loadMore() {
        console.warn("Loading more...");
        if (lastSearch.obj && lastSearch.obj.next) {
            loadLibrary(lastSearch.obj.next(), true, true, !lastSearch.groups.length, false, false);
        }
        for (var i = 0; i < lastSearch.groups.length && lastSearch.groups[i].next; i++) {
            loadLibrary(sdk.getGroupItems(lastSearch.groups[i].next(), lastSearch.groups[i].id), true, false, i == lastSearch.groups.length - 1, true, false);
        }
    }
    function shouldLoadMore(holder) {
        if (router.getRoute() != "main") return false;
        if (holder.scrollTop + holder.clientHeight < holder.scrollHeight) {
            return false;
        }
        var flag = true;
        lastSearch.groups.forEach(function(el) {
            if (el.next) flag = false;
        });
        if (!lastSearch.obj || !lastSearch.obj.next || !flag) return false;
        if (!lastSearch.obj && !lastSearch.text.trim() && !lastSearch.groups.length) return false;
        return true;
    }
    function loadLibrary(promise, append, showLoader, hideLoader, isGroup, bCount) {
        if (showLoader) showLibLoader(true);
        if (bCount) counter++;
        return promise.then(function(res) {
            if (bCount) counter--;
            return displaySearchItems(append, res, null, isGroup, bCount && !counter);
        }).catch(function(err) {
            if (bCount) counter--;
            console.error(err);
            if (err.message) {
                showError(translate(err.message));
            }
            return displaySearchItems(append, null, err, isGroup, bCount && !counter);
        }).finally(function() {
            if (hideLoader) {
                showLibLoader(false);
            }
        });
    }
    function displaySearchItems(append, res, err, isGroup, showNotFound) {
        var first = false;
        if (!lastSearch.obj && res && res.items && !res.items.length) first = true;
        if (err) {
            if (first) {
                lastSearch.obj = null;
                lastSearch.groups = [];
            }
            lastSearch.obj.next = null;
        } else {
            if (isGroup && res && res.next) lastSearch.groups.push(res); else lastSearch.obj = res && res.items.length ? res : null;
        }
        if (res && res.items && res.items.length > 0) {
            for (var index = 0; index < res.items.length; index++) {
                var item = res.items[index];
                item[isGroup ? "groupID" : "userID"] = res.id;
                citationService.fillUrisFromId(item);
            }
        }
        return selectCitation.displaySearchItems(append, res, err, showNotFound, first);
    }
    function checkSelected(numOfSelected) {
        insertLinkBtn.setText(translate("Insert Citation"));
        if (numOfSelected <= 0) {
            insertLinkBtn.disable();
        } else {
            insertLinkBtn.enable();
            if (numOfSelected > 1) insertLinkBtn.setText(translate("Insert " + numOfSelected + " Citations"));
        }
    }
})();
//# sourceMappingURL=bundle.modern.js.map
